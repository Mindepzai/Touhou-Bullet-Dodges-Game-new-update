<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Touhou Bullet Dodge Game</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #1a1a2e;
            color: #e0e0e0;
            margin: 0;
            overflow-y: auto;
            padding: 20px;
            box-sizing: border-box;
        }
        .game-container {
            background-color: #2a2a4a;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            width: 500px;
            max-width: 100vw;
            position: relative;
            overflow: hidden;
            flex-grow: 1;
            justify-content: center;
            height: auto;
        }
        canvas {
            background-color: #0d0d1a;
            border: 3px solid #6a0572;
            border-radius: 10px;
            display: block;
            touch-action: none;
            width: 100vw;
            max-width: 480px;
            height: auto;
            aspect-ratio: 3/4;
            position: relative;
            z-index: 1;
        }
        @media (max-width: 768px) {
            .game-container {
                width: 100vw;
                max-width: 100vw;
                padding: 5px;
            }
            canvas {
                width: 100vw;
                max-width: 100vw;
                height: auto;
                aspect-ratio: 3/4;
            }
        }
        /* Joystick/nút ảo chỉ hiện trên mobile */
        .joystick-container, #focusButton, #skill1Button, #skill2Button {
            display: none;
        }
        @media (pointer: coarse), (max-width: 900px) {
            .joystick-container, #focusButton, #skill1Button, #skill2Button {
                display: flex !important;
            }
            .joystick-container {
                position: fixed;
                bottom: 2.5vh;
                left: 2vw;
                width: 80px;
                height: 80px;
                z-index: 150;
            }
            #skill1Button {
                position: fixed;
                bottom: 15vh;
                left: 2vw;
                width: 60px;
                height: 60px;
                font-size: 1em;
                z-index: 151;
            }
            #focusButton {
                position: fixed;
                bottom: 2.5vh;
                right: 2vw;
                width: 60px;
                height: 60px;
                font-size: 1em;
                z-index: 151;
            }
            #skill2Button {
                position: fixed;
                bottom: 15vh;
                right: 2vw;
                width: 60px;
                height: 60px;
                font-size: 1em;
                z-index: 151;
            }
        }
        /* Đảm bảo nút không đè lên canvas/gameplay */
        .main-controls-container {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            display: flex;
            justify-content: space-between;
            gap: 10px;
            z-index: 200;
            width: auto;
            padding: 0;
            box-sizing: border-box;
        }
        .button {
            min-width: 120px;
            font-size: 1.1em;
        }
        @media (max-width: 768px) {
            .button {
                min-width: 80px;
                font-size: 1em;
            }
        }
        /* Responsive font */
        html {
            font-size: 16px;
        }
        @media (max-width: 600px) {
            html {
                font-size: 13px;
            }
        }

        .star-background {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: transparent;
            overflow: hidden;
            border-radius: 15px; /* Same as game-container border-radius */
            z-index: 0; /* Ensure star background is below canvas */
        }

        .star {
            position: absolute;
            background-color: #fff;
            border-radius: 50%;
            opacity: 0;
            animation: twinkle 5s infinite ease-in-out;
        }

        @keyframes twinkle {
            0%, 100% { opacity: 0; }
            50% { opacity: 0.8; }
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            width: 100%; /* Changed from max-width to 100% */
            max-width: 480px; /* Still apply max-width for desktop */
            font-size: 1.2em;
            font-weight: bold;
            color: #a0a0ff; /* Light blue color */
            padding: 5px 0;
            border-bottom: 1px solid #4a4a6a;
            z-index: 2; /* Ensure game info is on top */
        }

        .boss-health-bar-container {
            width: 100%;
            max-width: 480px;
            height: 20px;
            background-color: #333;
            border: 2px solid #ff0000;
            border-radius: 5px;
            margin-bottom: 10px;
            overflow: hidden;
            position: relative;
            z-index: 2;
        }

        .boss-health-bar {
            height: 100%;
            background-color: #ff0000;
            width: 100%; /* Initial width */
            transition: width 0.2s ease-out;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.9em;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
        }

        .button {
            background: linear-gradient(145deg, #8a2be2, #6a0572); /* Purple gradient */
            color: white;
            border: 2px solid #a052ee; /* Lighter border */
            padding: 12px 25px;
            border-radius: 8px;
            font-size: 1.1em;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.2);
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: bold;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
            flex: 1; /* Allow buttons to stretch */
            min-width: 120px; /* Minimum width limit */
        }

        .button:hover {
            background: linear-gradient(145deg, #6a0572, #8a2be2);
            transform: translateY(-2px) scale(1.02);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.3);
        }

        .button:active {
            transform: translateY(0);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2), inset 0 1px 0 rgba(0, 0, 0, 0.1);
        }

        .control-button {
            background-color: #4a4a6a;
            color: white;
            border: none;
            padding: 15px 25px;
            border-radius: 50%;
            font-size: 1.5em;
            cursor: pointer;
            touch-action: manipulation; /* Prevent default browser behavior */
            transition: background-color 0.2s ease;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.3);
            display: flex;
            justify-content: center;
            align-items: center;
            width: 60px; /* Default larger size for better touch */
            height: 60px; /* Default larger size for better touch */
            flex-shrink: 0; /* Prevent shrinking */
        }

        .control-button.focus-button {
            border-radius: 8px; /* Rectangular focus button */
            width: auto;
            height: auto;
            padding: 12px 20px;
            font-size: 1em;
            background: linear-gradient(145deg, #28a745, #218838); /* Green color */
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .control-button.skill-button {
            background: linear-gradient(145deg, #007bff, #0056b3); /* Blue color for skill */
            border-radius: 8px;
            width: auto;
            height: auto;
            padding: 12px 20px;
            font-size: 1em;
        }
        .control-button.skill-button:disabled {
            background-color: #555;
            cursor: not-allowed;
            opacity: 0.7;
        }


        .control-button:active {
            background-color: #6a6a8a;
        }

        .game-over-screen, .paused-overlay, .start-screen, .game-win-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85); /* Darker overlay background */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #fff;
            font-size: 2em;
            text-align: center;
            z-index: 100;
            border-radius: 15px;
            gap: 20px;
            backdrop-filter: blur(5px); /* Blur effect */
            overflow-y: auto; /* Allow internal scrolling if content overflows */
            padding-top: 60px; /* Add padding to account for main controls at top */
            padding-bottom: 20px; /* Add some bottom padding */
            box-sizing: border-box; /* Include padding in height calculation */
        }

        .game-over-screen h2, .paused-overlay h2, .start-screen h2, .game-win-screen h2 {
            margin-bottom: 10px;
            color: #ff6b6b; /* Red color */
            text-shadow: 0 0 10px rgba(255, 107, 107, 0.7);
        }

        .start-screen h2 {
            color: #a0a0ff; /* Light blue for start title */
            text-shadow: 0 0 10px rgba(160, 160, 255, 0.7);
        }
        .game-win-screen h2 {
            color: #28a745; /* Green for win title */
            text-shadow: 0 0 10px rgba(40, 167, 69, 0.7);
        }

        .game-over-screen p, .start-screen p, .game-win-screen p {
            font-size: 0.8em;
            margin-bottom: 20px;
            max-width: 80%; /* Limit text width */
        }

        /* Main controls container (Pause, Music) */
        .main-controls-container {
            position: absolute; /* Position absolutely within game-container */
            top: 20px; /* Distance from top */
            left: 20px; /* Distance from left */
            right: 20px; /* Distance from right */
            display: flex;
            justify-content: space-between; /* Push buttons to edges */
            gap: 10px;
            z-index: 200;
            width: auto; /* Auto width based on left/right */
            padding: 0; /* No internal padding */
            box-sizing: border-box;
        }

        /* Adjust restart button on game over screen */
        #gameOverScreen .button, #startScreen .button, #gameWinScreen .button {
            min-width: 180px;
        }

        /* Styles for the virtual joystick */
        .joystick-container {
            display: none; /* Hidden by default on desktop */
            position: fixed; /* Fixed position relative to viewport */
            bottom: 20px; /* Increased bottom for better thumb reach */
            left: 20px; /* Increased left for better thumb reach */
            width: 90px; /* Slightly smaller default size */
            height: 90px;
            background-color: rgba(74, 74, 106, 0.7);
            border-radius: 50%;
            justify-content: center;
            align-items: center;
            touch-action: none; /* Prevent default browser touch actions */
            z-index: 150;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.5);
        }

        .joystick-handle {
            width: 35px; /* Adjusted handle size */
            height: 35px;
            background-color: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            position: absolute;
            touch-action: none;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }

        /* Focus button and Skill buttons for mobile and desktop */
        #focusButton, #skill1Button, #skill2Button {
            display: flex; /* Always display */
            position: fixed; /* Fixed position relative to viewport */
            z-index: 150;
            width: 60px; /* Consistent size for better touch */
            height: 60px;
            font-size: 1.1em;
            padding: 10px;
        }

        /* Positioning for left side buttons */
        #joystickContainer {
            bottom: 20px;
            left: 20px;
        }

        #skill1Button {
            bottom: 120px; /* Above joystick (20 + 90 + 10 margin) */
            left: 20px; /* Aligned with joystick */
        }

        /* Positioning for right side buttons */
        #focusButton {
            bottom: 20px;
            right: 20px;
        }

        #skill2Button {
            bottom: 120px; /* Above focus button (20 + 90 + 10 margin) */
            right: 20px; /* Aligned with focus button */
        }

        /* Responsive adjustments for mobile (max-width 768px) */
        @media (max-width: 768px) {
            .game-container {
                width: 95%; /* Responsive width for mobile */
                max-width: unset; /* Remove fixed max-width */
                padding: 15px;
            }
            canvas {
                width: 100%; /* Canvas takes full width of its container */
                height: auto; /* Height auto-adjusts to maintain aspect ratio */
            }
            .game-info {
                font-size: 1em;
            }
            .game-over-screen, .paused-overlay, .start-screen, .game-win-screen {
                font-size: 1.5em;
            }
            .game-over-screen p, .start-screen p, .game-win-screen p {
                font-size: 0.7em;
            }
            .button {
                padding: 10px 15px;
                font-size: 0.9em;
                min-width: unset; /* Remove min-width limit */
            }
            /* Main controls container should remain absolute within game-container */
            .main-controls-container {
                position: absolute;
                top: 15px; /* Adjust top for smaller padding */
                left: 15px;
                right: 15px;
            }
            .joystick-container {
                display: flex; /* Show joystick on mobile */
            }
        }

        /* Further adjustments for very small mobile screens (max-width 480px) */
        @media (max-width: 480px) {
            .game-container {
                padding: 10px;
            }
            .joystick-container {
                width: 80px; /* Even smaller */
                height: 80px;
                bottom: 15px; /* Even closer to edge */
                left: 15px;
            }
            .joystick-handle {
                width: 30px;
                height: 30px;
            }
            #focusButton, #skill1Button, #skill2Button {
                width: 50px; /* Even smaller */
                height: 50px;
                font-size: 0.9em;
                padding: 8px;
            }
            #focusButton.focus-button, #skill1Button.skill-button, #skill2Button.skill-button {
                padding: 8px 12px;
                font-size: 0.8em;
            }
            #skill1Button {
                bottom: 105px; /* Adjusted position (15 + 80 + 10 margin) */
                left: 15px;
            }
            #skill2Button {
                bottom: 105px; /* Adjusted position (15 + 80 + 10 margin) */
                right: 15px;
            }
            .main-controls-container {
                top: 10px; /* Adjust top for smaller padding */
                left: 10px;
                right: 10px;
            }
        }

        /* Landscape mode adjustments for mobile (orientation: landscape and max-height 768px) */
        @media (orientation: landscape) and (max-height: 768px) {
            body {
                padding: 10px; /* Reduce overall padding */
            }
            .game-container {
                flex-direction: row; /* Arrange horizontally in landscape */
                flex-wrap: nowrap; /* Prevent wrapping */
                justify-content: center;
                align-items: stretch; /* Stretch items to fill height */
                padding: 10px; /* Reduce padding */
                gap: 10px; /* Reduce gap */
                width: 100%; /* Take full width */
                height: 98vh; /* Take most of viewport height */
                max-width: unset; /* Remove fixed max-width in landscape */
            }
            canvas {
                width: auto; /* Let width adjust based on height and aspect ratio */
                height: 100%; /* Canvas takes full height of its container */
                max-width: 70%; /* Limit canvas width to leave space for controls */
            }
            .game-info {
                flex-basis: auto; /* Allow content to dictate width */
                order: unset; /* Revert order */
                font-size: 0.8em; /* Smaller font for game info */
                padding-bottom: 5px;
                border-bottom: 1px solid #4a4a6a;
                margin-bottom: 5px;
            }
            .main-controls-container {
                position: absolute; /* Keep absolute positioning in landscape */
                top: 10px; /* Adjust top for landscape */
                left: 10px;
                right: 10px;
                flex-direction: row; /* Keep buttons in a row at the top */
                justify-content: space-between;
                width: auto;
                max-width: unset;
                padding: 0;
                gap: 5px;
                align-items: center;
                margin-top: 0;
                height: auto;
                flex-grow: 0; /* Do not grow, maintain fixed height */
                min-width: unset;
            }
            .main-controls-container .button {
                padding: 6px 10px; /* Smaller padding */
                font-size: 0.7em; /* Smaller font */
                min-width: unset;
                flex: none;
            }
            /* Fixed controls for landscape - adjusted for thumb comfort */
            .joystick-container {
                bottom: 10px; /* Even closer to edge */
                left: 10px;
                width: 70px; /* Smaller size in landscape */
                height: 70px;
            }
            .joystick-handle {
                width: 25px;
                height: 25px;
            }
            #focusButton, #skill1Button, #skill2Button {
                width: 50px; /* Smaller size in landscape */
                height: 50px;
                font-size: 0.9em;
                padding: 8px;
            }
            #focusButton.focus-button, #skill1Button.skill-button, #skill2Button.skill-button {
                padding: 8px 12px;
                font-size: 0.8em;
            }
            #skill1Button {
                bottom: 90px; /* Adjusted position (10 + 70 + 10 margin) */
                left: 10px;
            }
            #skill2Button {
                bottom: 90px; /* Adjusted position (10 + 70 + 10 margin) */
                right: 10px;
            }
            .game-over-screen, .paused-overlay, .start-screen, .game-win-screen {
                font-size: 1em; /* Smaller font size */
                gap: 5px;
            }
        }

        /* Language selection buttons */
        .language-selection {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        .language-button {
            background: #4a4a6a;
            color: white;
            border: 1px solid #6a6a8a;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9em;
            transition: background-color 0.2s;
        }
        .language-button:hover {
            background: #6a6a8a;
        }
        .language-button.selected {
            background: #8a2be2;
            border-color: #a052ee;
        }

        .character-description {
            font-size: 0.9em;
            color: #ccc;
            margin-top: 10px;
            max-width: 80%;
            text-align: center;
        }
        .skill-btn {
            min-width: 60px;
            min-height: 60px;
            font-size: 18px;
            border-radius: 12px;
            border: 2px solid #5ecfff;
            background: #222c;
            color: #fff;
            font-family: inherit;
            box-shadow: 0 2px 8px #0006;
            transition: 0.2s;
            cursor: pointer;
            position: relative;
        }
        .skill-btn[disabled] {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .skill-btn span {
            font-size: 13px;
            display: block;
            margin-top: 2px;
        }
        @media (max-width: 800px) {
            #skill-buttons-container {
                bottom: 20px;
                right: 10px;
                gap: 8px;
            }
            .skill-btn {
                min-width: 48px;
                min-height: 48px;
                font-size: 15px;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="star-background" id="starBackground"></div>
        
        <!-- Main controls container moved to top absolute position -->
        <div class="main-controls-container">
            <button id="pauseButton" class="button">Pause</button>
            <button id="musicToggleButton" class="button">Toggle Music</button>
        </div>

        <h1 id="gameTitle">Touhou Bullet Dodge Game</h1>
        <div class="game-info">
            <span id="scoreDisplay">Score: 0</span>
            <span id="difficultyDisplay">Difficulty: 1</span>
            <span id="revivesDisplay">Revives: 3</span>
            <!-- Skill displays removed from here, integrated into buttons -->
        </div>
        <div class="boss-health-bar-container" id="bossHealthBarContainer" style="display: none;">
            <div class="boss-health-bar" id="bossHealthBar">BOSS HEALTH</div>
        </div>
        <canvas id="gameCanvas"></canvas>

        <!-- Joystick and Skill 1 on the left -->
        <div class="joystick-container" id="joystickContainer">
            <div class="joystick-handle" id="joystickHandle"></div>
        </div>
        <button class="control-button skill-button" id="skill1Button" aria-label="Skill 1">Skill 1: ∞</button>

        <!-- Focus and Skill 2 on the right -->
        <button class="control-button focus-button" id="focusButton" aria-label="Focus">Focus</button>
        <button class="control-button skill-button" id="skill2Button" aria-label="Skill 2">Skill 2: ∞</button>


        <div id="startScreen" class="start-screen">
            <h2 id="startScreenTitle">TOUHOU BULLET DODGE GAME</h2>
            <p id="startScreenStory">You are a fragment of forgotten magic, awakened in a chaotic realm. Dodge the relentless magical distortions and face the source of the chaos to bring temporary peace. Survive as long as you can! As you delve deeper, you sense a formidable presence, the source of these distortions, awaiting your challenge. After defeating the initial manifestations, a deeper, more ancient evil stirs, threatening to engulf all. Your journey is far from over...</p>
            <h3 id="characterSelectionTitle">Select Your Character:</h3>
            <div id="characterSelection" style="display: flex; gap: 20px; margin-bottom: 20px; flex-wrap: wrap; justify-content: center;">
                <button class="button character-button" data-character="reimu" id="reimuButton">Reimu (Balanced)</button>
                <button class="button character-button" data-character="marisa" id="marisaButton">Marisa (Fast)</button>
                <button class="button character-button" data-character="sakuya" id="sakuyaButton">Sakuya (Precise)</button>
                <button class="button character-button" data-character="youmu" id="youmuButton">Youmu (Swift)</button>
                <button class="button character-button" data-character="cirno" id="cirnoButton">Cirno (Resilient)</button>
                <button class="button character-button" data-character="gojo" id="gojoButton">Gojo (Ultimate)</button>
            </div>
            <div id="characterDescription" class="character-description"></div>
            <div class="language-selection">
                <button class="language-button" data-lang="en">English</button>
                <button class="language-button" data-lang="vi">Tiếng Việt</button>
            </div>
            <button id="guideButton" class="button">Hướng dẫn</button>
            <button id="startButton" class="button">Start Game</button>
        </div>

        <div id="gameOverScreen" class="game-over-screen" style="display: none;">
            <h2 id="gameOverTitle">GAME OVER!</h2>
            <p id="gameOverScoreText">You survived for <span id="finalScore">0</span> seconds</p>
            <button id="restartButton" class="button">Play Again</button>
            <button id="homeButtonGameOver" class="button">Home</button>
        </div>

        <div id="gameWinScreen" class="game-win-screen" style="display: none;">
            <h2 id="gameWinTitle">VICTORY!</h2>
            <p id="gameWinText">You have defeated the Boss and brought temporary peace to the realm! However, the true source of chaos remains elusive, hinting at future challenges...</p>
            <p id="finalWinScoreText">Final Score: <span id="finalWinScore">0</span></p>
            <button id="winRestartButton" class="button">Play Again</button>
            <button id="homeButtonGameWin" class="button">Home</button>
        </div>

        <div id="pausedOverlay" class="paused-overlay" style="display: none;">
            <h2 id="pausedTitle">PAUSED</h2>
            <p id="pausedHint">Press ESC or "Resume" button to continue</p>
            <button id="homeButtonPaused" class="button">Home</button>
        </div>
        <div id="guidePopup" class="game-over-screen" style="display: none; z-index: 300; background: rgba(20,20,40,0.97);">
            <h2 id="guideTitle">HƯỚNG DẪN</h2>
            <div id="guideContent" style="font-size:1em; text-align:left; max-width:90%; margin:auto; color:#fff; background:rgba(0,0,0,0.2); border-radius:10px; padding:20px 10px;"></div>
            <button id="closeGuideButton" class="button">Đóng</button>
        </div>
        <!-- Skill Buttons UI (PC & Mobile) -->
        <div id="skill-buttons-container" style="position: absolute; bottom: 30px; right: 30px; display: flex; flex-direction: row; gap: 12px; z-index: 10;">
            <button id="skill1Button" class="skill-btn">Q<br><span>Skill 1</span></button>
            <button id="skill2Button" class="skill-btn">E<br><span>Skill 2</span></button>
            <button id="skill3Button" class="skill-btn" disabled style="opacity:0.5;">R<br><span>Skill 3</span></button>
            <button id="skill4Button" class="skill-btn" disabled style="opacity:0.5;">F<br><span>Skill 4</span></button>
        </div>
    </div>

    <!-- Gojo Skill Guide Popup -->
    <div id="gojoSkillGuide" style="display:none; position:fixed; left:50%; top:18%; transform:translate(-50%,0); background:#222e; color:#fff; padding:22px 28px; border-radius:16px; z-index:1000; font-size:18px; box-shadow:0 4px 24px #000a;">
        <b>Gojo Skill Guide</b><br>
        <span id="gojoSkillGuideText"></span><br>
        <button onclick="document.getElementById('gojoSkillGuide').style.display='none'" style="margin-top:10px;">Đã hiểu</button>
    </div>
    <!-- Nút ? hiện lại hướng dẫn -->
    <button id="gojoGuideBtn" style="position:fixed; right:18px; top:18px; z-index:1001; font-size:22px; border-radius:50%; width:38px; height:38px; background:#5ecfff; color:#fff; border:none; box-shadow:0 2px 8px #0006; cursor:pointer;">?</button>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const difficultyDisplay = document.getElementById('difficultyDisplay');
        const revivesDisplay = document.getElementById('revivesDisplay');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const finalScoreDisplay = document.getElementById('finalScore');
        const restartButton = document.getElementById('restartButton');
        const pauseButton = document.getElementById('pauseButton');
        const musicToggleButton = document.getElementById('musicToggleButton');
        const pausedOverlay = document.getElementById('pausedOverlay');
        const starBackground = document.getElementById('starBackground');
        const startScreen = document.getElementById('startScreen');
        const startButton = document.getElementById('startButton');
        const gameWinScreen = document.getElementById('gameWinScreen');
        const finalWinScoreDisplay = document.getElementById('finalWinScore');
        const winRestartButton = document.getElementById('winRestartButton');

        // Home buttons
        const homeButtonGameOver = document.getElementById('homeButtonGameOver');
        const homeButtonGameWin = document.getElementById('homeButtonGameWin');
        const homeButtonPaused = document.getElementById('homeButtonPaused');


        // Boss Health Bar elements
        const bossHealthBarContainer = document.getElementById('bossHealthBarContainer');
        const bossHealthBar = document.getElementById('bossHealthBar');

        // Joystick elements
        const joystickContainer = document.getElementById('joystickContainer');
        const joystickHandle = document.getElementById('joystickHandle');
        const focusButton = document.getElementById('focusButton');
        const skill1Button = document.getElementById('skill1Button');
        const skill2Button = document.getElementById('skill2Button');

        // Character selection elements
        const characterSelectionDiv = document.getElementById('characterSelection');
        const characterButtons = document.querySelectorAll('.character-button');
        const characterDescription = document.getElementById('characterDescription');

        // Language selection elements
        const languageButtons = document.querySelectorAll('.language-button');

        // Text elements for translation
        const gameTitle = document.getElementById('gameTitle');
        const startScreenTitle = document.getElementById('startScreenTitle');
        const startScreenStory = document.getElementById('startScreenStory');
        const characterSelectionTitle = document.getElementById('characterSelectionTitle');
        const gameOverTitle = document.getElementById('gameOverTitle');
        const gameOverScoreText = document.getElementById('gameOverScoreText');
        const gameWinTitle = document.getElementById('gameWinTitle');
        const gameWinText = document.getElementById('gameWinText');
        const finalWinScoreText = document.getElementById('finalWinScoreText');
        const pausedTitle = document.getElementById('pausedTitle');
        const pausedHint = document.getElementById('pausedHint');
        const reimuButton = document.getElementById('reimuButton');
        const marisaButton = document.getElementById('marisaButton');
        const sakuyaButton = document.getElementById('sakuyaButton');
        const youmuButton = document.getElementById('youmuButton');
        const cirnoButton = document.getElementById('cirnoButton');
        const gojoButton = document.getElementById('gojoButton');


        // Canvas dimensions (will be updated dynamically)
        let CANVAS_WIDTH = 480;
        let CANVAS_HEIGHT = 640;
        const CANVAS_ASPECT_RATIO = 3 / 4; // Desired aspect ratio (width / height)

        // Global array to store active timer IDs (both setTimeout and setInterval) for cleanup
        let activeTimers = [];

        // Helper function to add timers to the tracking array
        function addTimer(type, callback, delay) {
            let id;
            if (type === 'interval') {
                id = setInterval(callback, delay);
            } else if (type === 'timeout') {
                id = setTimeout(callback, delay);
            }
            activeTimers.push({ id: id, type: type });
            return id; // Return ID in case it needs to be cleared individually
        }

        // Helper function to clear a specific timer
        function clearSpecificTimer(id) {
            const index = activeTimers.findIndex(timer => timer.id === id);
            if (index > -1) {
                const timer = activeTimers[index];
                if (timer.type === 'interval') {
                    clearInterval(timer.id);
                } else if (timer.type === 'timeout') {
                    clearTimeout(timer.id);
                }
                activeTimers.splice(index, 1);
            }
        }

        // Helper function to clear all active timers
        function clearAllTimers() {
            activeTimers.forEach(timer => {
                if (timer.type === 'interval') {
                    clearInterval(timer.id);
                } else if (timer.type === 'timeout') {
                    clearTimeout(timer.id);
                }
            });
            activeTimers = []; // Clear the array
        }

        // Function to update canvas size based on available space and aspect ratio
        function updateCanvasSize() {
            const isMobile = window.innerWidth <= 900 || window.matchMedia('(pointer: coarse)').matches;
            let newCanvasWidth = Math.min(window.innerWidth, 480);
            let newCanvasHeight = newCanvasWidth / (3/4);
            if (window.innerHeight < newCanvasHeight + 120) {
                newCanvasHeight = window.innerHeight - 120;
                newCanvasWidth = newCanvasHeight * (3/4);
            }
            CANVAS_WIDTH = newCanvasWidth;
            CANVAS_HEIGHT = newCanvasHeight;
            canvas.width = CANVAS_WIDTH;
            canvas.height = CANVAS_HEIGHT;
            // Đảm bảo player và enemy không ra ngoài canvas
            player.x = Math.min(player.x, CANVAS_WIDTH - player.width / 2);
            player.y = Math.min(player.y, CANVAS_HEIGHT - player.height / 2);
            player.x = Math.max(player.x, player.width / 2);
            player.y = Math.max(player.y, player.height / 2);
        }
        window.addEventListener('resize', updateCanvasSize);
        window.addEventListener('orientationchange', updateCanvasSize);
        // --- Ẩn/hiện nút ảo theo thiết bị ---
        function updateControlVisibility() {
            const isMobile = window.innerWidth <= 900 || window.matchMedia('(pointer: coarse)').matches;
            document.getElementById('joystickContainer').style.display = isMobile ? 'flex' : 'none';
            document.getElementById('focusButton').style.display = isMobile ? 'flex' : 'none';
            document.getElementById('skill1Button').style.display = isMobile ? 'flex' : 'none';
            document.getElementById('skill2Button').style.display = isMobile ? 'flex' : 'none';
        }
        window.addEventListener('resize', updateControlVisibility);
        window.addEventListener('orientationchange', updateControlVisibility);
        window.addEventListener('load', () => {
            updateCanvasSize();
            updateControlVisibility();
        });

        // Function to create dynamic star background
        function createStars() {
            starBackground.innerHTML = ''; // Clear old stars
            const numStars = 100;
            for (let i = 0; i < numStars; i++) {
                const star = document.createElement('div');
                star.className = 'star';
                star.style.width = `${Math.random() * 3 + 1}px`;
                star.style.height = star.style.width;
                star.style.left = `${Math.random() * 100}%`;
                star.style.top = `${Math.random() * 100}%`;
                star.style.animationDelay = `${Math.random() * 5}s`;
                starBackground.appendChild(star);
            }
        }

        // Call on page load and window resize
        window.addEventListener('load', () => {
            updateCanvasSize();
            createStars();
            // Show start screen on load instead of starting game
            startScreen.style.display = 'flex';
            setLanguage(currentLanguage); // Set initial language
            updateCharacterDescription(currentPlayerType); // Display initial character description
        });
        window.addEventListener('resize', () => {
            updateCanvasSize();
            // Redraw game elements if game is running to adapt to new canvas size
            if (gameRunning && !gamePaused) {
                // No need to restart, just ensure elements are within bounds
                enemyProjectiles.forEach(b => {
                    b.x = Math.min(b.x, CANVAS_WIDTH + b.radius);
                    b.y = Math.min(b.y, CANVAS_HEIGHT + b.radius);
                });
                playerProjectiles.forEach(b => {
                    b.x = Math.min(b.x, CANVAS_WIDTH + b.radius);
                    b.y = Math.min(b.y, CANVAS_HEIGHT + b.radius);
                });
                enemies.forEach(e => {
                    e.x = Math.min(e.x, CANVAS_WIDTH - e.width / 2);
                    e.y = Math.min(e.y, CANVAS_HEIGHT - e.height / 2);
                });
                artifacts.forEach(a => {
                    a.x = Math.min(a.x, CANVAS_WIDTH - a.radius);
                    a.y = Math.min(a.y, CANVAS_HEIGHT - a.radius);
                });
                // Reposition boss if active
                if (bossActive && boss) {
                    boss.x = Math.min(boss.x, CANVAS_WIDTH - boss.width / 2);
                    boss.y = Math.min(boss.y, CANVAS_HEIGHT - boss.height / 2);
                }
            }
        });

        // --- Game variables ---
        let gameRunning = false;
        let gamePaused = false;
        let score = 0;
        let startTime = 0;
        let lastFrameTime = 0;
        let difficultyLevel = 1;
        let difficultyTimer = 0;
        let revivesLeft = 3; // Number of revives left (Increased to 3)
        let isInvincible = false; // Invincibility status
        let invincibleTimer = 0;
        const INVINCIBLE_DURATION = 2; // Invincibility duration after revive (seconds)

        let deathCount = 0; // Consecutive deaths
        let scoreAtLastDeath = 0; // Score at last death

        const ASSIST_DEATH_THRESHOLD = 3; // Consecutive deaths to trigger assist
        const ASSIST_SCORE_THRESHOLD = 10; // If score increases less than this threshold after deaths

        const ARTIFACT_SPAWN_INTERVAL = 50; // Artifact appears every 50 points
        let nextArtifactScore = ARTIFACT_SPAWN_INTERVAL;
        const artifacts = []; // Array to hold artifacts

        // --- Skill variables ---
        let bulletSlowEffectActive = false; // For Youmu's skill
        let bulletSlowTimer = 0;
        let bossTimeStopActive = false; // For Time Manipulator's Temporal Stasis
        let bossTimeStopTimer = 0;
        let playerMovementFrozen = false; // New: For Dio's Temporal Stasis
        let playerSkillsFrozen = false; // New: For Dio's Temporal Stasis

        // --- Boss variables ---
        let boss = null;
        let bossActive = false;
        const BOSS_SPAWN_SCORE = 100; // Score to trigger boss fight
        const BOSS_PHASES = [ // Define boss phases with health and initial shoot interval
            { maxHealth: 500, shootInterval: 0.4, name: "Shadow Weaver" }, // Phase 1: Shadow Weaver (Cid)
            { maxHealth: 750, shootInterval: 0.3, name: "Lich Overlord" }, // Phase 2: Lich Overlord (Overlord)
            { maxHealth: 1000, shootInterval: 0.2, name: "Spirit of Retribution" }, // Phase 3: Spirit of Retribution (Sans)
            { maxHealth: 1500, shootInterval: 0.1, name: "Time Manipulator" } // Phase 4: Time Manipulator (Dio)
        ];
        let currentBossPhaseIndex = 0;
        let lastBossDamageTime = 0;
        const BOSS_DAMAGE_INTERVAL = 5; // Boss takes damage every 5 seconds of survival

        // --- New Attack Arrays for Boss ---
        const enemyProjectiles = []; // Traditional bullets from regular enemies
        const playerProjectiles = []; // Player's skill-based projectiles (e.g., Marisa's Spiral Orb)
        const beams = []; // For Shadow Weaver's energy beams
        const darkZones = []; // For Lich Overlord's dark zones
        const spectralSpikes = []; // For Spirit of Retribution's bone attacks
        const phantomBlasters = []; // For Spirit of Retribution's Phantom Blasters
        const crushingDescents = []; // For Time Manipulator's Crushing Descent
        const particles = []; // For skill effects
        const enemies = [];
        const MAX_ENEMIES_ON_SCREEN = 3; // Reduced number of regular enemies

        const enemyTypes = {
            slime: {
                width: 28,
                height: 20,
                color: '#7ec850', // Xanh lá cây nhạt
                shootInterval: 2.8,
                movePattern: 'slow',
                moveSpeed: 0.6,
                health: 50,
                skillType: 'slimeShot',
                inspiration: {
                    en: "Slime from Dragon Quest and isekai anime, slow and weak but classic.",
                    vi: "Slime từ Dragon Quest và anime isekai, di chuyển chậm, yếu nhưng kinh điển."
                }
            },
            fairy: {
                width: 26,
                height: 26,
                color: '#00ffcc', // Xanh ngọc
                shootInterval: 2.0,
                movePattern: 'zigzag',
                moveSpeed: 1.2,
                health: 60,
                skillType: 'fairySpread',
                inspiration: {
                    en: "Fairy from Touhou, zigzag movement and spread shot.",
                    vi: "Tiên nhỏ Touhou, di chuyển zigzag và bắn đạn tỏa tròn."
                }
            },
            yinyang: {
                width: 30,
                height: 30,
                color: '#ffffff', // Trắng
                shootInterval: 3.0,
                movePattern: 'float',
                moveSpeed: 0.8,
                health: 70,
                skillType: 'homing',
                inspiration: {
                    en: "Yin-Yang Orb from Touhou, floating and fires homing bullets.",
                    vi: "Quả cầu âm dương Touhou, bay lượn và bắn đạn tự tìm mục tiêu."
                }
            },
            bat: {
                width: 24,
                height: 16,
                color: '#a060c0', // Tím
                shootInterval: 0,
                movePattern: 'dive',
                moveSpeed: 1.7,
                health: 40,
                skillType: 'dive',
                inspiration: {
                    en: "Bat from Castlevania/Touhou, fast dive attack, no bullets.",
                    vi: "Dơi từ Castlevania/Touhou, lao nhanh vào người chơi, không bắn đạn."
                }
            },
            ghost: {
                width: 32,
                height: 32,
                color: '#eeeeee', // Trắng xám
                shootInterval: 3.5,
                movePattern: 'ghost',
                moveSpeed: 0.5,
                health: 80,
                skillType: 'ghostExplode',
                inspiration: {
                    en: "Ghost from Bleach/Touhou, moves through walls, explodes into bullets on death.",
                    vi: "Hồn ma từ Bleach/Touhou, xuyên tường, khi chết phát nổ ra nhiều đạn nhỏ."
                }
            }
        };

        // --- Player Character Definitions ---
        const playerCharacters = {
            reimu: {
                name: "Reimu",
                color: '#00ffff', // Cyan
                baseSpeed: 4.5,
                focusSpeedMultiplier: 0.4,
                hitboxRadius: 2,
                initialRevives: 4, 
                activeSkills: [
                    { id: 'spiritualSealBurst', cooldown: 3.5, clearRadius: 200, damage: 50, description: { en: "Clears all bullets on screen and deals minor damage to nearby enemies.", vi: "Xóa tất cả đạn trên màn hình và gây sát thương nhỏ cho kẻ địch gần đó." } },
                    { id: 'illusoryDuplicate', cooldown: 10, duration: 5, numClones: 2, defaultBulletDamage: 5, description: { en: "Creates temporary illusory duplicates that act as decoys and fire basic projectiles.", vi: "Tạo ra các bản sao ảo ảnh tạm thời hoạt động như mồi nhử và bắn đạn cơ bản." } }
                ],
                passive: { type: 'auraOfSerenity', value: 0.1, description: { en: "Slightly slows enemy bullets.", vi: "Làm chậm nhẹ đạn của kẻ thù." } },
                description: {
                    en: "Balanced stats. Active 1: Spiritual Seal Burst. Active 2: Illusory Duplicate. Passive: Aura of Serenity.",
                    vi: "Chỉ số cân bằng. Kỹ năng chủ động 1: Bùa Nổ Linh Hồn. Kỹ năng chủ động 2: Ảnh Phân Thân Ảo. Kỹ năng bị động: Hào Quang Thanh Tịnh."
                }
            },
            marisa: {
                name: "Marisa",
                color: '#ffcc00', // Gold
                baseSpeed: 6,
                focusSpeedMultiplier: 0.3,
                hitboxRadius: 2.5,
                initialRevives: 3, 
                activeSkills: [
                    { id: 'spiralOrbBarrage', cooldown: 7, speed: 10, radius: 25, damage: 120, piercing: true, description: { en: "Fires a large, slow, piercing energy orb dealing high damage.", vi: "Bắn ra một quả cầu năng lượng lớn, chậm, xuyên thấu gây sát thương cao." } },
                    { id: 'lightningDash', cooldown: 8, dashSpeed: 15, dashDuration: 0.5, invincibilityDuringDash: 0.6, damagePerSecond: 150, description: { en: "Dashes forward with lightning speed, becoming invincible and damaging enemies in path.", vi: "Lao về phía trước với tốc độ chớp nhoáng, trở nên bất tử và gây sát thương cho kẻ địch trên đường đi." } }
                ],
                passive: { type: 'arcaneFlow', value: 0.2, description: { en: "Reduces skill cooldowns.", vi: "Giảm thời gian hồi chiêu của các kỹ năng." } },
                description: {
                    en: "High raw speed, offensive skill. Active 1: Spiral Orb Barrage. Active 2: Lightning Dash. Passive: Arcane Flow.",
                    vi: "Tốc độ di chuyển cao, kỹ năng tấn công. Kỹ năng chủ động 1: Cầu Xoắn Năng Lượng. Kỹ năng chủ động 2: Lao Tới Sét. Kỹ năng bị động: Dòng Chảy Bí Ẩn."
                }
            },
            sakuya: {
                name: "Sakuya",
                color: '#cccccc',
                baseSpeed: 3.5,
                focusSpeedMultiplier: 0.6,
                hitboxRadius: 1.5,
                initialRevives: 5,
                activeSkills: [
                    {
                        id: 'chronosPierce',
                        cooldown: 8,
                        areaWidth: 220,
                        areaHeight: 180,
                        numDaggers: 30,
                        daggerDamage: 60,
                        description: {
                            en: "Chronos Pierce: Freeze time in a large area ahead, then unleash a barrage of time-accelerated daggers that pierce all enemies and clear bullets in the area.",
                            vi: "Xuyên Thấu Thời Gian: Ngưng đọng thời gian phía trước, phóng hàng loạt dao găm xuyên thấu, dọn sạch đạn và gây sát thương lớn trong vùng ảnh hưởng."
                        }
                    },
                    {
                        id: 'absoluteFreeze',
                        cooldown: 14,
                        freezeRadius: 180,
                        freezeDuration: 3.5,
                        description: {
                            en: "Absolute Freeze: Freeze all enemies and bullets in a large area for a long duration. Frozen enemies/bullets are destroyed or take heavy damage when the effect ends.",
                            vi: "Đóng Băng Tuyệt Đối: Đóng băng toàn bộ kẻ thù và đạn trong vùng lớn, thời gian đóng băng lâu. Khi kết thúc, mục tiêu bị phá hủy hoặc nhận sát thương lớn."
                        }
                    }
                ],
                passive: {
                    type: 'returnByDeath',
                    chance: 0.99,
                    description: {
                        en: "Return by Death: 99% chance to completely dodge any incoming damage, flashing brightly as if time reversed.",
                        vi: "Trở Về Từ Cõi Chết: Có 99% cơ hội hoàn toàn né tránh sát thương, phát sáng rực rỡ như thể thời gian vừa bị đảo ngược."
                    }
                },
                description: {
                    en: "Legendary evasion. Active 1: Chronos Pierce. Active 2: Absolute Freeze. Passive: Return by Death.",
                    vi: "Né tránh huyền thoại. Kỹ năng 1: Xuyên Thấu Thời Gian. Kỹ năng 2: Đóng Băng Tuyệt Đối. Bị động: Trở Về Từ Cõi Chết."
                }
            },
            youmu: {
                name: "Youmu",
                color: '#90ee90', // Light Green
                baseSpeed: 4.5,
                focusSpeedMultiplier: 0.35,
                hitboxRadius: 2.2,
                initialRevives: 4, 
                activeSkills: [
                    { id: 'overdrivePulse', cooldown: 10, speedMultiplier: 1.8, bulletSlowMultiplier: 0.5, duration: 4, description: { en: "Greatly increases movement speed and slows enemy bullets for a short duration.", vi: "Tăng đáng kể tốc độ di chuyển và làm chậm đạn của kẻ thù trong thời gian ngắn." } },
                    { id: 'rapidStrikeFlurry', cooldown: 6, numProjectiles: 30, speed: 15, radius: 5, damage: 30, description: { en: "Unleashes a rapid-fire barrage of strikes in a wide arc.", vi: "Tung ra một loạt đòn tấn công liên hoàn tầm ngắn theo hình vòng cung rộng." } }
                ],
                passive: { type: 'resilientSpirit', chance: 0.1, duration: 1.0, description: { en: "Chance to gain brief invincibility when hit.", vi: "Có cơ hội nhận bất tử ngắn khi bị trúng đạn." } },
                description: {
                    en: "Balanced speed, excels in evasive maneuvers. Active 1: Overdrive Pulse. Active 2: Rapid Strike Flurry. Passive: Resilient Spirit.",
                    vi: "Tốc độ cân bằng, xuất sắc trong các pha né tránh. Kỹ năng chủ động 1: Xung Lực Quá Tải. Kỹ năng chủ động 2: Bão Đòn Đánh Nhanh. Kỹ năng bị động: Tinh Thần Kiên Cường."
                }
            },
            cirno: {
                name: "Cirno",
                color: '#00bfff',
                baseSpeed: 3,
                focusSpeedMultiplier: 0.5,
                hitboxRadius: 3,
                initialRevives: 6,
                activeSkills: [
                    {
                        id: 'frostflakeArrowBarrage',
                        cooldown: 7,
                        arrowCount: 7,
                        arrowDamage: 40,
                        arrowRadius: 18,
                        shardCount: 8,
                        shardDamage: 12,
                        slowDuration: 2.5,
                        slowAmount: 0.5,
                        description: {
                            en: "Frostflake Arrow Barrage: Fire a barrage of giant cryo arrows (like Ganyu), each exploding into icy shards, dealing AoE damage and slowing enemies.",
                            vi: "Mưa Tên Băng Giá: Bắn loạt tên băng lớn, mỗi tên nổ thành nhiều mảnh nhỏ, gây sát thương diện rộng và làm chậm kẻ thù."
                        }
                    },
                    {
                        id: 'glacialWaltz',
                        cooldown: 15,
                        waltzRadius: 120,
                        waltzDuration: 4,
                        tickDamage: 30,
                        freezeDuration: 1.5,
                        description: {
                            en: "Elemental Burst: Glacial Waltz: Summon a swirling blizzard around Cirno, dealing heavy cryo damage, freezing big enemies, and clearing small bullets.",
                            vi: "Nộ Nguyên Tố: Điệu Valse Băng Giá: Tạo bão băng tuyết quanh Cirno, liên tục gây sát thương lớn, đóng băng kẻ thù lớn và phá hủy đạn nhỏ."
                        }
                    }
                ],
                passive: {
                    type: 'absoluteZeroAura',
                    bulletSlow: 0.5,
                    damageReduce: 0.6,
                    description: {
                        en: "Absolute Zero Aura: All enemy bullets are greatly slowed and Cirno takes much less damage.",
                        vi: "Hào Quang Tuyệt Đối Băng Giá: Làm chậm mạnh đạn kẻ thù và giảm lớn sát thương nhận vào."
                    }
                },
                description: {
                    en: "Cryo battlefield control. Active 1: Frostflake Arrow Barrage. Active 2: Glacial Waltz. Passive: Absolute Zero Aura.",
                    vi: "Kiểm soát chiến trường bằng Băng. Kỹ năng 1: Mưa Tên Băng Giá. Kỹ năng 2: Điệu Valse Băng Giá. Bị động: Hào Quang Tuyệt Đối Băng Giá."
                }
            },
            gojo: {
                name: "Gojo",
                color: '#5ecfff', // Xanh lam nhạt
                baseSpeed: 5.2,
                focusSpeedMultiplier: 0.5,
                hitboxRadius: 2,
                initialRevives: 4,
                activeSkills: [
                    {
                        id: 'infinity',
                        cooldown: 7,
                        duration: 2.5,
                        description: {
                            en: "Infinity: Become untouchable for a short time, all enemy bullets are stopped before reaching Gojo.",
                            vi: "Vô Hạn: Trở nên bất khả xâm phạm trong thời gian ngắn, mọi đạn kẻ địch đều bị chặn lại trước khi chạm Gojo."
                        }
                    },
                    {
                        id: 'sixEyes',
                        cooldown: 10,
                        duration: 3,
                        speedBoost: 2.2,
                        description: {
                            en: "Six Eyes: Greatly increases speed and evasion, reveals hidden bullets, and slows time for enemies.",
                            vi: "Lục Nhãn: Tăng tốc độ, né tránh, phát hiện đạn ẩn và làm chậm thời gian của kẻ địch."
                        }
                    },
                    {
                        id: 'hollowPurple',
                        cooldown: 30,
                        unlockCondition: 'energy', // unlock khi đủ năng lượng
                        damage: 400,
                        description: {
                            en: "Hollow Purple (Ultimate): Fires a massive energy beam that pierces all enemies and bosses. Unlocks after building up enough energy.",
                            vi: "Hư Thức Tử: Bắn tia năng lượng cực mạnh xuyên mọi kẻ địch và boss. Mở khi tích đủ năng lượng."
                        }
                    },
                    {
                        id: 'domainExpansion',
                        cooldown: 60,
                        unlockCondition: 'kills', // unlock khi tiêu diệt đủ quái
                        duration: 5,
                        description: {
                            en: "Domain Expansion (Ultimate): Freezes all enemies and bullets in a large area, then deals massive damage. Unlocks after defeating enough enemies.",
                            vi: "Lãnh Vực: Đóng băng toàn bộ kẻ địch và đạn trong vùng lớn, gây sát thương cực mạnh. Mở khi tiêu diệt đủ quái."
                        }
                    }
                ],
                passive: {
                    type: 'limitless',
                    value: 0.15,
                    description: {
                        en: "Limitless: Constantly regenerates a small amount of health and has a chance to dodge any attack.",
                        vi: "Vô Hạn (bị động): Tự hồi máu nhẹ và có tỉ lệ né tránh mọi đòn tấn công."
                    }
                },
                description: {
                    en: "Gojo Satoru, the strongest sorcerer. Active 1: Infinity. Active 2: Six Eyes. Ultimate 1: Hollow Purple. Ultimate 2: Domain Expansion. Passive: Limitless.",
                    vi: "Gojo Satoru, chú thuật sư mạnh nhất. Kỹ năng 1: Vô Hạn. Kỹ năng 2: Lục Nhãn. Tối thượng 1: Hư Thức Tử. Tối thượng 2: Lãnh Vực. Bị động: Vô Hạn."
                }
            }
        };
        let currentPlayerType = 'reimu'; // Default selected character

        // --- Player object (will be initialized based on selected character) ---
        const player = {
            x: CANVAS_WIDTH / 2,
            y: CANVAS_HEIGHT - 50,
            width: 20,
            height: 20,
            speed: 0, // Will be set by character
            focusSpeedMultiplier: 0, // Will be set by character
            color: '', // Will be set by character
            hitboxRadius: 0, // Will be set by character
            isFocusing: false,
            isDashing: false, // New flag for Marisa's Lightning Dash
            activeSkills: [], // Will store skill objects with lastUseTime
            passive: null, // Will be set by character
            damageBoostActive: false // For Cirno's Absolute Zero Form
        };

        // --- Keyboard input ---
        const keys = {
            ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false,
            KeyW: false, KeyA: false, KeyS: false, KeyD: false,
            ShiftLeft: false, ShiftRight: false,
            KeyZ: false, // For skill 1
            KeyX: false // For skill 2
        };

        // --- Keyboard event handling ---
        window.addEventListener('keydown', (e) => {
            if (playerMovementFrozen) return; // If player movement is frozen by boss skill

            if (keys.hasOwnProperty(e.code)) { keys[e.code] = true; }
            else if (keys.hasOwnProperty(e.key)) { keys[e.key] = true; }
            if (e.key === 'Escape' || e.code === 'Escape') { togglePause(); }

            // Handle Shift for focus
            if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') {
                player.isFocusing = true;
            }
            // Handle Z for skill 1
            if (e.code === 'KeyZ' && !e.repeat && !playerSkillsFrozen) { // !e.repeat prevents multiple triggers on hold
                useSkill(0); // Use first skill
            }
            // Handle X for skill 2
            if (e.code === 'KeyX' && !e.repeat && !playerSkillsFrozen) { // !e.repeat prevents multiple triggers on hold
                useSkill(1); // Use second skill
            }
        });

        window.addEventListener('keyup', (e) => {
            if (keys.hasOwnProperty(e.code)) { keys[e.code] = false; }
            else if (keys.hasOwnProperty(e.key)) { keys[e.key] = false; }

            // Handle Shift for focus
            if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') {
                player.isFocusing = false;
            }
        });

        // --- Joystick and mobile control handling ---
        let joystickActive = false;
        let joystickStartX = 0;
        let joystickStartY = 0;
        const joystickMaxDistance = 40; // Max distance handle can move from center

        joystickContainer.addEventListener('touchstart', (e) => {
            e.preventDefault(); // Prevent scrolling/zooming
            if (playerMovementFrozen) return; // If player movement is frozen by boss skill
            joystickActive = true;
            const touch = e.touches[0];
            const containerRect = joystickContainer.getBoundingClientRect();
            joystickStartX = containerRect.left + containerRect.width / 2;
            joystickStartY = containerRect.top + containerRect.height / 2;
            moveJoystick(touch.clientX, touch.clientY);
        });

        joystickContainer.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (joystickActive && !playerMovementFrozen) { // If player movement is frozen by boss skill
                const touch = e.touches[0];
                moveJoystick(touch.clientX, touch.clientY);
            }
        });

        joystickContainer.addEventListener('touchend', (e) => {
            e.preventDefault();
            joystickActive = false;
            resetJoystick();
            // Reset player movement keys
            keys.ArrowUp = keys.ArrowDown = keys.ArrowLeft = keys.ArrowRight = false;
        });

        joystickContainer.addEventListener('touchcancel', (e) => {
            e.preventDefault();
            joystickActive = false;
            resetJoystick();
            // Reset player movement keys
            keys.ArrowUp = keys.ArrowDown = keys.ArrowLeft = keys.ArrowRight = false;
        });

        function moveJoystick(clientX, clientY) {
            const dx = clientX - joystickStartX;
            const dy = clientY - joystickStartY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const angle = Math.atan2(dy, dx);

            let limitedDx = dx;
            let limitedDy = dy;

            if (distance > joystickMaxDistance) {
                limitedDx = Math.cos(angle) * joystickMaxDistance;
                limitedDy = Math.sin(angle) * joystickMaxDistance;
            }

            joystickHandle.style.transform = `translate(${limitedDx}px, ${limitedDy}px)`;

            // Map joystick movement to player keys
            // Reset all movement keys first
            keys.ArrowUp = keys.ArrowDown = keys.ArrowLeft = keys.ArrowRight = false;

            // Determine direction based on joystick handle position
            if (limitedDy < -10) keys.ArrowUp = true;
            if (limitedDy > 10) keys.ArrowDown = true;
            if (limitedDx < -10) keys.ArrowLeft = true;
            if (limitedDx > 10) keys.ArrowRight = true;
        }

        function resetJoystick() {
            joystickHandle.style.transform = `translate(0, 0)`;
        }

        // Focus button for mobile
        focusButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (playerMovementFrozen) return; // If player movement is frozen by boss skill
            player.isFocusing = true;
        });
        focusButton.addEventListener('touchend', (e) => {
            e.preventDefault();
            player.isFocusing = false;
        });
        focusButton.addEventListener('touchcancel', (e) => {
            e.preventDefault();
            player.isFocusing = false;
        });

        // Skill buttons for mobile
        skill1Button.addEventListener('click', () => {
            if (!playerSkillsFrozen) useSkill(0); // If player skills are not frozen by boss skill
        });
        skill2Button.addEventListener('click', () => {
            if (!playerSkillsFrozen) useSkill(1); // If player skills are not frozen by boss skill
        });


        // --- Drawing functions ---
        function drawPlayer() {
            // Draw player as a square block
            ctx.fillStyle = player.color;
            ctx.fillRect(player.x - player.width / 2, player.y - player.height / 2, player.width, player.height);
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 1;
            ctx.strokeRect(player.x - player.width / 2, player.y - player.height / 2, player.width, player.height);

            // Draw small hitbox and make it blink when focusing or invincible
            if (player.isFocusing || isInvincible || (difficultyLevel >= 5 && score % 2 === 0)) {
                ctx.beginPath();
                ctx.arc(player.x, player.y, player.hitboxRadius, 0, Math.PI * 2);
                ctx.fillStyle = isInvincible ? 'rgba(0, 255, 255, 0.5)' : 'rgba(255, 0, 0, 0.7)'; // Cyan when invincible
                ctx.fill();
                ctx.strokeStyle = isInvincible ? 'rgba(255, 255, 255, 0.9)' : 'rgba(255, 255, 255, 0.9)';
                ctx.lineWidth = 1.5;
                ctx.stroke();
            }
            drawInfinityEffect();
            drawSixEyesEffect();
            drawHollowPurpleEffect();
            drawDomainExpansionEffect();
        }

        // Bullet trail effect
        const bulletTrails = [];
        // Removed the old drawBullet function as it's replaced by the new one below
        // that handles different bullet types.

        function drawEnemy(enemy) {
            ctx.fillStyle = enemy.color;
            ctx.fillRect(enemy.x - enemy.width / 2, enemy.y - enemy.height / 2, enemy.width, enemy.height);
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.strokeRect(enemy.x - enemy.width / 2, enemy.y - enemy.height / 2, enemy.width, enemy.height);
        }

        function drawBoss(boss) {
            ctx.fillStyle = boss.color;
            ctx.fillRect(boss.x - boss.width / 2, boss.y - boss.height / 2, boss.width, boss.height);
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 3;
            ctx.strokeRect(boss.x - boss.width / 2, boss.y - boss.height / 2, boss.width, boss.height);
        }

        function updateBossHealthBar() {
            if (bossActive && boss) {
                const healthPercentage = (boss.health / boss.maxHealth) * 100;
                bossHealthBar.style.width = `${healthPercentage}%`;
                bossHealthBar.textContent = `${currentLanguage === 'en' ? 'BOSS HEALTH' : 'MÁU BOSS'} (${Math.round(healthPercentage)}%)`;
                bossHealthBarContainer.style.display = 'block';
            } else {
                bossHealthBarContainer.style.display = 'none';
            }
        }

        // --- Artifacts ---
        function createArtifact() {
            const type = Math.floor(Math.random() * 3); // 0: Slow, 1: Speed, 2: Clear
            const x = Math.random() * (CANVAS_WIDTH - 40) + 20;
            const y = Math.random() * (CANVAS_HEIGHT / 2 - 40) + 20; // Only appear in upper half of screen
            artifacts.push({
                x: x,
                y: y,
                radius: 15,
                color: type === 0 ? 'yellow' : (type === 1 ? 'lime' : 'orange'),
                type: type,
                life: 5 // Lasts 5 seconds
            });
        }

        function drawArtifact(artifact) {
            ctx.beginPath();
            ctx.arc(artifact.x, artifact.y, artifact.radius, 0, Math.PI * 2);
            ctx.fillStyle = artifact.color;
            ctx.fill();
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.fillStyle = 'black';
            ctx.font = '12px Inter';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            let text = '';
            if (artifact.type === 0) text = 'S'; // Slow
            else if (artifact.type === 1) text = 'F'; // Fast
            else text = 'C'; // Clear
            ctx.fillText(text, artifact.x, artifact.y);
        }

        function updateArtifacts(deltaTime) {
            for (let i = artifacts.length - 1; i >= 0; i--) {
                const artifact = artifacts[i];
                artifact.life -= deltaTime;
                if (artifact.life <= 0) {
                    artifacts.splice(i, 1);
                }
            }
        }

        // --- Particle System for Skill Effect ---
        function createParticle(x, y, color, size = Math.random() * 5 + 2, vx = (Math.random() - 0.5) * 10, vy = (Math.random() - 0.5) * 10, alpha = 1, decay = 0.05, shrink = 0.95) {
            particles.push({
                x: x,
                y: y,
                vx: vx,
                vy: vy,
                radius: size,
                color: color,
                alpha: alpha,
                decay: decay,
                shrink: shrink
            });
        }

        function updateParticles(deltaTime) {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx * deltaTime * 60; // Scale with deltaTime
                p.y += p.vy * deltaTime * 60;
                p.radius *= p.shrink;
                p.alpha -= p.decay;
                if (p.alpha <= 0.1 || p.radius <= 0.5) {
                    particles.splice(i, 1);
                }
            }
        }

        function drawParticles() {
            particles.forEach(p => {
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(${parseInt(p.color.slice(1, 3), 16)}, ${parseInt(p.color.slice(3, 5), 16)}, ${parseInt(p.color.slice(5, 7), 16)}, ${p.alpha})`;
                ctx.fill();
            });
        }

        // --- Update functions ---
        function updatePlayer(deltaTime) {
            // player.isFocusing is now controlled directly by event listeners (keyboard Shift or mobile focus button)
            const currentSpeed = player.isFocusing ? player.speed * player.focusSpeedMultiplier : player.speed;

            if (!playerMovementFrozen) { // Only move if not frozen by boss skill
                if (keys.ArrowUp || keys.KeyW) player.y -= currentSpeed;
                if (keys.ArrowDown || keys.KeyS) player.y += currentSpeed;
                if (keys.ArrowLeft || keys.KeyA) player.x -= currentSpeed;
                if (keys.ArrowRight || keys.KeyD) player.x += currentSpeed;
            }

            player.x = Math.max(player.width / 2, Math.min(CANVAS_WIDTH - player.width / 2, player.x));
            player.y = Math.max(player.height / 2, Math.min(CANVAS_HEIGHT - player.height / 2, player.y));

            // Update invincibility status
            if (isInvincible) {
                invincibleTimer -= deltaTime;
                if (invincibleTimer <= 0) {
                    isInvincible = false;
                    player.color = playerCharacters[currentPlayerType].color; // Revert to original character color
                } else {
                    // Blinking effect when invincible
                    player.color = (Math.floor(invincibleTimer * 10) % 2 === 0) ? playerCharacters[currentPlayerType].color : '#ff00ff'; // Blink between character color and magenta
                }
            }

            // Apply pull effect from Abyssal Vortex if active
            darkZones.forEach(zone => {
                if (zone.state === 'active' && zone.type === 'vortex') {
                    const dx = zone.x - player.x;
                    const dy = zone.y - player.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance < zone.radius) {
                        const pullStrength = 0.5; // How strongly the player is pulled
                        player.x += dx / distance * pullStrength;
                        player.y += dy / distance * pullStrength;
                    }
                }
            });
        }

        function updateEnemyProjectiles(deltaTime) {
            let bulletSpeedMultiplier = 1.0;
            // Apply Youmu's Overdrive Pulse
            if (bulletSlowEffectActive) {
                bulletSpeedMultiplier *= playerCharacters.youmu.activeSkills[0].bulletSlowMultiplier;
            }
            // Apply Reimu's Aura of Serenity passive
            if (player.passive && player.passive.type === 'auraOfSerenity') {
                bulletSpeedMultiplier *= (1 - player.passive.value);
            }
            // Apply boss time stop
            if (bossTimeStopActive) {
                bulletSpeedMultiplier = 0; // Completely stop bullets
            }


            for (let i = enemyProjectiles.length - 1; i >= 0; i--) {
                const bullet = enemyProjectiles[i];
                
                // Handle homing bullets
                if (bullet.isHoming) {
                    const angleToPlayer = Math.atan2(player.y - bullet.y, player.x - bullet.x);
                    // Gradually adjust bullet's angle towards player
                    bullet.angle = bullet.angle + (angleToPlayer - bullet.angle) * bullet.homingStrength;
                    bullet.vx = Math.cos(bullet.angle) * bullet.speed;
                    bullet.vy = Math.sin(bullet.angle) * bullet.speed;
                }

                bullet.x += bullet.vx * bulletSpeedMultiplier;
                bullet.y += bullet.vy * bulletSpeedMultiplier;

                // Handle grenade explosion
                if (bullet.type === 'grenade' && bullet.y > bullet.explosionY) {
                    explodeGrenade(bullet);
                    enemyProjectiles.splice(i, 1);
                    continue; // Skip further processing for this bullet
                }

                // Remove bullets that go off-screen
                if (bullet.x < -bullet.radius || bullet.x > CANVAS_WIDTH + bullet.radius ||
                    bullet.y < -bullet.radius || bullet.y > CANVAS_HEIGHT + bullet.radius) {
                    enemyProjectiles.splice(i, 1);
                }
            }
        }

        function updatePlayerProjectiles() {
            for (let i = playerProjectiles.length - 1; i >= 0; i--) {
                const bullet = playerProjectiles[i];
                bullet.x += bullet.vx;
                bullet.y += bullet.vy;

                // Remove bullets that go off-screen
                if (bullet.x < -bullet.radius || bullet.x > CANVAS_WIDTH + bullet.radius ||
                    bullet.y < -bullet.radius || bullet.y > CANVAS_HEIGHT + bullet.radius) {
                    playerProjectiles.splice(i, 1);
                }
            }
        }

        // Added 'source' parameter to differentiate player bullets from enemy bullets
        function createBullet(x, y, angle, speed, radius, color, targetArray = enemyProjectiles, isHoming = false, homingStrength = 0, piercing = false, type = 'default', explosionY = null) {
            targetArray.push({
                x: x,
                y: y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                radius: radius,
                color: color,
                speed: speed, // Store original speed for passive effect
                angle: angle, // Store angle for homing
                isHoming: isHoming,
                homingStrength: homingStrength,
                piercing: piercing, // New property for piercing bullets
                type: type, // New property for bullet type
                explosionY: explosionY // For grenade type
            });
        }

        // --- Drawing for Anime-style Bullets ---
        function drawBullet(bullet) {
            ctx.save();
            ctx.translate(bullet.x, bullet.y);
            // Rotate to align with movement direction, assuming 0 is right, -PI/2 is up
            // Bullets are typically drawn "pointing" along their velocity vector.
            // If the default drawing assumes a vertical orientation (e.g., a knife pointing up),
            // then rotate by `bullet.angle + Math.PI / 2` to align it with the velocity vector.
            ctx.rotate(bullet.angle + Math.PI / 2); 
            
            switch (bullet.type) {
                case 'kiBlast': // Ki Blast (Basic Enemy) - Dragon Ball Z inspired
                    ctx.beginPath();
                    ctx.arc(0, 0, bullet.radius, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(${parseInt(bullet.color.slice(1, 3), 16)}, ${parseInt(bullet.color.slice(3, 5), 16)}, ${parseInt(bullet.color.slice(5, 7), 16)}, 0.8)`;
                    ctx.shadowColor = bullet.color;
                    ctx.shadowBlur = bullet.radius * 2;
                    ctx.fill();
                    ctx.shadowBlur = 0; // Reset shadow
                    // Add a small, brighter core
                    ctx.beginPath();
                    ctx.arc(0, 0, bullet.radius * 0.5, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(255, 255, 255, 0.7)`;
                    ctx.fill();
                    break;
                case 'magicMissile': // Magic Missile (Scatter Enemy) - Fantasy Anime inspired
                    ctx.fillStyle = bullet.color;
                    ctx.beginPath();
                    ctx.moveTo(0, -bullet.radius * 1.5); // Pointy top
                    ctx.lineTo(-bullet.radius * 0.8, bullet.radius * 0.5);
                    ctx.lineTo(bullet.radius * 0.8, bullet.radius * 0.5);
                    ctx.closePath();
                    ctx.fill();
                    ctx.shadowColor = bullet.color;
                    ctx.shadowBlur = bullet.radius;
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    // Add a small trail effect
                    ctx.fillStyle = `rgba(${parseInt(bullet.color.slice(1, 3), 16)}, ${parseInt(bullet.color.slice(3, 5), 16)}, ${parseInt(bullet.color.slice(5, 7), 16)}, 0.3)`;
                    ctx.fillRect(-bullet.radius * 0.5, bullet.radius * 0.5, bullet.radius, bullet.radius * 2); // Simple rectangular trail
                    break;
                case 'energyWave': // Energy Wave (Wave Enemy) - Kamehameha/Hadoken inspired
                    ctx.fillStyle = bullet.color;
                    ctx.beginPath();
                    ctx.ellipse(0, 0, bullet.radius * 1.5, bullet.radius * 0.8, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowColor = bullet.color;
                    ctx.shadowBlur = bullet.radius * 1.5;
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    // Add subtle inner lines to suggest energy flow
                    ctx.strokeStyle = `rgba(255,255,255,0.3)`;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(0, 0, bullet.radius * 0.7, 0, Math.PI * 2);
                    ctx.stroke();
                    break;
                case 'homingBeam': // Homing Beam (Homing Enemy) - Frieza/Itachi inspired
                    ctx.fillStyle = bullet.color;
                    ctx.fillRect(-bullet.radius * 0.2, -bullet.radius * 2, bullet.radius * 0.4, bullet.radius * 4);
                    ctx.shadowColor = bullet.color;
                    ctx.shadowBlur = bullet.radius * 2;
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    // Add a brighter core line
                    ctx.fillStyle = `rgba(255, 255, 255, 0.9)`;
                    ctx.fillRect(-bullet.radius * 0.1, -bullet.radius * 2, bullet.radius * 0.2, bullet.radius * 4);
                    break;
                case 'spiralOrb': // Marisa's Spiral Orb Barrage
                    ctx.beginPath();
                    ctx.arc(0, 0, bullet.radius, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(${parseInt(bullet.color.slice(1, 3), 16)}, ${parseInt(bullet.color.slice(3, 5), 16)}, ${parseInt(bullet.color.slice(5, 7), 16)}, 0.9)`;
                    ctx.shadowColor = bullet.color;
                    ctx.shadowBlur = bullet.radius * 2;
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    // Add swirling lines
                    ctx.strokeStyle = `rgba(255,255,255,0.7)`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, bullet.radius * 0.6, performance.now() * 0.02, performance.now() * 0.02 + Math.PI * 1.5);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.arc(0, 0, bullet.radius * 0.9, -performance.now() * 0.01, -performance.now() * 0.01 + Math.PI * 1.5);
                    ctx.stroke();
                    break;
                case 'windBlade': // Sakuya's Wind Blade Volley
                    ctx.fillStyle = bullet.color;
                    // Draw a crescent shape
                    ctx.beginPath();
                    ctx.arc(0, 0, bullet.radius * 1.5, Math.PI * 0.2, Math.PI * 0.8);
                    ctx.arc(0, 0, bullet.radius * 0.5, Math.PI * 0.8, Math.PI * 0.2, true);
                    ctx.closePath();
                    ctx.fill();
                    ctx.shadowColor = bullet.color;
                    ctx.shadowBlur = bullet.radius;
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    break;
                case 'strikeProjectile': // Youmu's Rapid Strike Flurry
                    ctx.fillStyle = bullet.color;
                    ctx.beginPath();
                    ctx.arc(0, 0, bullet.radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowColor = bullet.color;
                    ctx.shadowBlur = bullet.radius * 0.5;
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    // Draw a small fist icon (simplified)
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.fillRect(-bullet.radius * 0.4, -bullet.radius * 0.5, bullet.radius * 0.8, bullet.radius);
                    ctx.fillRect(bullet.radius * 0.2, -bullet.radius * 0.5, bullet.radius * 0.2, bullet.radius * 0.5);
                    break;
                case 'glacialBeam': // Cirno's Glacial Beam
                    ctx.fillStyle = bullet.color;
                    ctx.beginPath();
                    ctx.ellipse(0, 0, bullet.radius * 2, bullet.radius, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowColor = bullet.color;
                    ctx.shadowBlur = bullet.radius * 2;
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    // Add a bright core
                    ctx.beginPath();
                    ctx.ellipse(0, 0, bullet.radius * 1.2, bullet.radius * 0.6, 0, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(255, 255, 255, 0.7)`;
                    ctx.fill();
                    break;
                case 'illusoryCloneBullet': // Reimu's Illusory Duplicate bullets
                    ctx.beginPath();
                    ctx.arc(0, 0, bullet.radius, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(${parseInt(bullet.color.slice(1, 3), 16)}, ${parseInt(bullet.color.slice(3, 5), 16)}, ${parseInt(bullet.color.slice(5, 7), 16)}, 0.6)`;
                    ctx.fill();
                    ctx.strokeStyle = `rgba(255, 255, 255, 0.5)`;
                    ctx.lineWidth = 1;
                    ctx.stroke();
                    break;
                case 'fistOfFury': // Time Manipulator's Fist of Fury Barrage
                    ctx.fillStyle = bullet.color;
                    ctx.beginPath();
                    ctx.arc(0, 0, bullet.radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowColor = bullet.color;
                    ctx.shadowBlur = bullet.radius * 0.5;
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    // Small "fist" shape
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                    ctx.fillRect(-bullet.radius * 0.4, -bullet.radius * 0.5, bullet.radius * 0.8, bullet.radius);
                    break;
                case 'grenade': // Cid's Grenade
                    ctx.beginPath();
                    ctx.arc(0, 0, bullet.radius, 0, Math.PI * 2);
                    ctx.fillStyle = bullet.color; // Dark grey for grenade
                    ctx.fill();
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    // Add a small fuse
                    ctx.fillStyle = '#8B4513'; // Brown
                    ctx.fillRect(-bullet.radius * 0.1, -bullet.radius * 1.2, bullet.radius * 0.2, bullet.radius * 0.5);
                    break;
                case 'knife': // Dio's Knife
                    ctx.fillStyle = bullet.color; // Silver for knife
                    ctx.beginPath();
                    ctx.moveTo(0, -bullet.radius * 2); // Tip
                    ctx.lineTo(bullet.radius * 0.5, 0);
                    ctx.lineTo(0, bullet.radius * 2); // End of handle
                    ctx.lineTo(-bullet.radius * 0.5, 0);
                    ctx.closePath();
                    ctx.fill();
                    ctx.shadowColor = bullet.color;
                    ctx.shadowBlur = bullet.radius;
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    break;
                default: // Default bullet drawing (fallback)
                    ctx.beginPath();
                    ctx.arc(0, 0, bullet.radius, 0, Math.PI * 2);
                    ctx.fillStyle = bullet.color;
                    ctx.fill();
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                    break;
            }
            ctx.restore();
        }

        // --- New Boss Attack Types and Functions ---

        // Beams (Shadow Weaver) - Now with warning/active states
        function createBeamHazard(startX, startY, endX, endY, width, color, warningDuration, activeDuration) {
            beams.push({
                startX: startX,
                startY: startY,
                endX: endX,
                endY: endY,
                width: width,
                color: color,
                warningTimer: warningDuration,
                activeTimer: activeDuration,
                maxWarning: warningDuration, // Store max for opacity calculation
                maxActive: activeDuration, // Store max for opacity calculation
                state: 'warning' // 'warning' or 'active'
            });
        }

        function updateBeams(deltaTime) {
            for (let i = beams.length - 1; i >= 0; i--) {
                const beam = beams[i];
                // Apply boss time stop
                const effectiveDeltaTime = bossTimeStopActive ? 0 : deltaTime;

                if (beam.state === 'warning') {
                    beam.warningTimer -= effectiveDeltaTime;
                    if (beam.warningTimer <= 0) {
                        beam.state = 'active';
                        // Play a distinct sound when beam becomes active (optional)
                        // playBeamActiveSFX();
                    }
                } else if (beam.state === 'active') {
                    beam.activeTimer -= effectiveDeltaTime;
                    if (beam.activeTimer <= 0) {
                        beams.splice(i, 1);
                    }
                }
            }
        }

        function drawBeam(beam) {
            ctx.beginPath();
            ctx.lineWidth = beam.width;

            if (beam.state === 'warning') {
                // Blinking warning line
                const alpha = (Math.floor(performance.now() / 100) % 2 === 0) ? 0.2 : 0.8; // Blink effect
                ctx.strokeStyle = `rgba(255, 0, 0, ${alpha})`; // Red warning
                ctx.lineWidth = 2; // Thin warning line
            } else { // 'active' - Mana Beam
                ctx.strokeStyle = `rgba(${parseInt(beam.color.slice(1, 3), 16)}, ${parseInt(beam.color.slice(3, 5), 16)}, ${parseInt(beam.color.slice(5, 7), 16)}, ${0.7 * (beam.activeTimer / beam.maxActive)})`; // Reduced opacity
                ctx.lineWidth = beam.width;
                ctx.shadowColor = beam.color;
                ctx.shadowBlur = beam.width * 0.5;
                ctx.lineCap = 'round'; // Rounded ends for beams
            }

            ctx.moveTo(beam.startX, beam.startY);
            ctx.lineTo(beam.endX, beam.endY);
            ctx.stroke();
            ctx.shadowBlur = 0; // Reset shadow
            ctx.lineCap = 'butt'; // Reset line cap
        }

        // Dark Zones (Lich Overlord)
        function createDarkZone(x, y, radius, damage, warningDuration, activeDuration, color, type = 'static') {
            darkZones.push({
                x: x,
                y: y,
                radius: radius,
                damage: damage,
                warningTimer: warningDuration,
                activeTimer: activeDuration,
                maxWarning: warningDuration,
                maxActive: activeDuration,
                color: color,
                state: 'warning', // 'warning' or 'active'
                type: type, // 'static', 'expanding', 'shrinking', 'vortex'
                initialRadius: radius // Store for expanding/shrinking
            });
        }

        // New function for moving dark zones
        function createMovingDarkZone(x, y, radius, damage, warningDuration, activeDuration, color, targetX, targetY, moveSpeed) {
            darkZones.push({
                x: x,
                y: y,
                radius: radius,
                damage: damage,
                warningTimer: warningDuration,
                activeTimer: activeDuration,
                maxWarning: warningDuration,
                maxActive: activeDuration,
                color: color,
                state: 'warning',
                isMoving: true, // New flag
                targetX: targetX,
                targetY: targetY,
                moveSpeed: moveSpeed,
                vx: 0, // Will be calculated
                vy: 0,  // Will be calculated
                type: 'moving'
            });
        }

        function updateDarkZones(deltaTime) {
            for (let i = darkZones.length - 1; i >= 0; i--) {
                const zone = darkZones[i];
                // Apply boss time stop
                const effectiveDeltaTime = bossTimeStopActive ? 0 : deltaTime;

                if (zone.state === 'warning') {
                    zone.warningTimer -= effectiveDeltaTime;
                    if (zone.warningTimer <= 0) {
                        zone.state = 'active';
                    }
                } else if (zone.state === 'active') {
                    zone.activeTimer -= effectiveDeltaTime;
                    if (zone.isMoving) { // Handle movement for moving dark zones
                        const angleToTarget = Math.atan2(zone.targetY - zone.y, zone.targetX - zone.x);
                        zone.vx = Math.cos(angleToTarget) * (zone.moveSpeed * effectiveDeltaTime);
                        zone.vy = Math.sin(angleToTarget) * (zone.moveSpeed * effectiveDeltaTime);
                        zone.x += zone.vx;
                        zone.y += zone.vy;

                        // Stop if reached target or gone off screen
                        const distanceToTarget = Math.sqrt(Math.pow(zone.x - zone.targetX, 2) + Math.pow(zone.y - zone.targetY, 2));
                        if (distanceToTarget < zone.moveSpeed * effectiveDeltaTime * 2 || zone.x < -zone.radius || zone.x > CANVAS_WIDTH + zone.radius || zone.y < -zone.radius || zone.y > CANVAS_HEIGHT + zone.radius) {
                            zone.activeTimer = 0; // End active phase if target reached or off-screen
                        }
                    } else if (zone.type === 'expanding') {
                        // Expand over time
                        const progress = 1 - (zone.activeTimer / zone.maxActive);
                        zone.radius = zone.initialRadius + (zone.initialRadius * 0.5 * progress); // Expand to 1.5x initial size
                    } else if (zone.type === 'shrinking') {
                        // Shrink over time
                        const progress = 1 - (zone.activeTimer / zone.maxActive);
                        zone.radius = zone.initialRadius * (1 - 0.5 * progress); // Shrink to 0.5x initial size
                        zone.radius = Math.max(5, zone.radius); // Don't shrink to zero
                    }
                    zone.activeTimer -= effectiveDeltaTime;
                    if (zone.activeTimer <= 0) {
                        darkZones.splice(i, 1);
                    }
                }
            }
        }

        function drawDarkZone(zone) {
            ctx.beginPath();
            ctx.arc(zone.x, zone.y, zone.radius, 0, Math.PI * 2);
            if (zone.state === 'warning') {
                ctx.strokeStyle = `rgba(255, 255, 0, ${0.5 + Math.sin(performance.now() * 0.01) * 0.3})`; // Blinking yellow
                ctx.lineWidth = 3;
                ctx.stroke();
            } else { // 'active' - Abyssal Zone
                ctx.fillStyle = `rgba(${parseInt(zone.color.slice(1, 3), 16)}, ${parseInt(zone.color.slice(3, 5), 16)}, ${parseInt(zone.color.slice(5, 7), 16)}, ${0.7 * (zone.activeTimer / zone.maxActive)})`;
                ctx.shadowColor = zone.color;
                ctx.shadowBlur = zone.radius * 0.5;
                ctx.fill();
                ctx.shadowBlur = 0;
                // Add subtle swirling effect
                ctx.strokeStyle = `rgba(0,0,0,0.5)`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(zone.x, zone.y, zone.radius * 0.7, performance.now() * 0.005, performance.now() * 0.005 + Math.PI * 1.5);
                ctx.stroke();
            }
        }

        // Spectral Spikes (Spirit of Retribution)
        function createSpectralSpike(x, y, width, height, vx, vy, color, type = 'normal') {
            spectralSpikes.push({
                x: x,
                y: y,
                width: width,
                height: height,
                vx: vx,
                vy: vy,
                color: color,
                type: type // 'normal', 'spiral'
            });
        }

        function updateSpectralSpikes(deltaTime) {
            for (let i = spectralSpikes.length - 1; i >= 0; i--) {
                const spike = spectralSpikes[i];
                // Apply boss time stop
                const effectiveDeltaTime = bossTimeStopActive ? 0 : deltaTime;

                spike.x += spike.vx * effectiveDeltaTime * 60;
                spike.y += spike.vy * effectiveDeltaTime * 60;

                // Remove spikes when off-screen
                if (spike.x + spike.width < 0 || spike.x > CANVAS_WIDTH ||
                    spike.y + spike.height < 0 || spike.y > CANVAS_HEIGHT) {
                    spectralSpikes.splice(i, 1);
                }
            }
        }

        function drawSpectralSpike(spike) {
            ctx.fillStyle = spike.color;
            ctx.strokeStyle = 'rgba(0,0,0,0.8)';
            ctx.lineWidth = 2;

            // Draw a stylized bone shape (simplified)
            ctx.beginPath();
            ctx.moveTo(spike.x, spike.y + spike.height * 0.2);
            ctx.lineTo(spike.x + spike.width * 0.2, spike.y);
            ctx.lineTo(spike.x + spike.width * 0.8, spike.y);
            ctx.lineTo(spike.x + spike.width, spike.y + spike.height * 0.2);
            ctx.lineTo(spike.x + spike.width, spike.y + spike.height * 0.8);
            ctx.lineTo(spike.x + spike.width * 0.8, spike.y + spike.height);
            ctx.lineTo(spike.x + spike.width * 0.2, spike.y + spike.height);
            ctx.lineTo(spike.x, spike.y + spike.height * 0.8);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Add a subtle inner shadow/detail
            ctx.fillStyle = 'rgba(0,0,0,0.1)';
            ctx.beginPath();
            ctx.arc(spike.x + spike.width * 0.25, spike.y + spike.height * 0.25, spike.width * 0.1, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(spike.x + spike.width * 0.75, spike.y + spike.height * 0.25, spike.width * 0.1, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(spike.x + spike.width * 0.25, spike.y + spike.height * 0.75, spike.width * 0.1, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(spike.x + spike.width * 0.75, spike.y + spike.height * 0.75, spike.width * 0.1, 0, Math.PI * 2);
            ctx.fill();
        }

        // Phantom Blasters (Spirit of Retribution)
        function createPhantomBlaster(x, y, targetX, targetY, size, chargeDuration, fireDuration, color) {
            phantomBlasters.push({
                x: x,
                y: y,
                targetX: targetX,
                targetY: targetY,
                angle: Math.atan2(targetY - y, targetX - x),
                size: size, // Scale of the blaster
                chargeTimer: chargeDuration,
                fireTimer: fireDuration,
                maxCharge: chargeDuration,
                maxFire: fireDuration,
                color: color,
                state: 'charging' // 'charging', 'firing', 'cooldown'
            });
        }

        function updatePhantomBlasters(deltaTime) {
            for (let i = phantomBlasters.length - 1; i >= 0; i--) {
                const blaster = phantomBlasters[i];
                // Apply boss time stop
                const effectiveDeltaTime = bossTimeStopActive ? 0 : deltaTime;

                if (blaster.state === 'charging') {
                    blaster.chargeTimer -= effectiveDeltaTime;
                    if (blaster.chargeTimer <= 0) {
                        blaster.state = 'firing';
                        // Play blaster sound here
                    }
                } else if (blaster.state === 'firing') {
                    blaster.fireTimer -= effectiveDeltaTime;
                    if (blaster.fireTimer <= 0) {
                        phantomBlasters.splice(i, 1);
                    }
                }
            }
        }

        function drawPhantomBlaster(blaster) {
            ctx.save();
            ctx.translate(blaster.x, blaster.y);
            ctx.rotate(blaster.angle);

            const bodyWidth = blaster.size;
            const bodyHeight = blaster.size * 0.6;
            const headRadius = blaster.size * 0.4;
            const eyeSize = blaster.size * 0.1;

            // Blaster body (skull-like shape)
            ctx.fillStyle = blaster.color;
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;

            ctx.beginPath();
            ctx.ellipse(0, 0, bodyWidth * 0.5, bodyHeight * 0.5, 0, 0, Math.PI * 2); // Main body
            ctx.fill();
            ctx.stroke();

            // Head/Muzzle (front part)
            ctx.beginPath();
            ctx.arc(bodyWidth * 0.4, 0, headRadius, -Math.PI / 2, Math.PI / 2);
            ctx.lineTo(bodyWidth * 0.4, -headRadius);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Eye socket (simple circle)
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(bodyWidth * 0.2, -headRadius * 0.4, eyeSize, 0, Math.PI * 2);
            ctx.fill();

            if (blaster.state === 'charging') {
                // Draw charging effect in the eye
                const chargeProgress = 1 - (blaster.chargeTimer / blaster.maxCharge);
                ctx.fillStyle = `rgba(255, 255, 0, ${chargeProgress * 0.8})`;
                ctx.beginPath();
                ctx.arc(bodyWidth * 0.2, -headRadius * 0.4, eyeSize * 0.8 * chargeProgress, 0, Math.PI * 2);
                ctx.fill();
            } else if (blaster.state === 'firing') {
                // Draw laser beam from muzzle
                ctx.fillStyle = `rgba(0, 255, 255, ${blaster.fireTimer / blaster.maxFire})`; // Cyan laser
                ctx.shadowColor = `rgba(0, 255, 255, ${blaster.fireTimer / blaster.maxFire})`;
                ctx.shadowBlur = 15;
                ctx.fillRect(bodyWidth * 0.4 + headRadius, -blaster.size * 0.05, CANVAS_WIDTH, blaster.size * 0.1); // Long rectangle for laser
                ctx.shadowBlur = 0;
            }

            ctx.restore();
        }

        // Crushing Descent (Time Manipulator)
        function createCrushingDescent(x, y, width, height, vy, color) {
            crushingDescents.push({
                x: x,
                y: y,
                width: width,
                height: height,
                vy: vy,
                color: color
            });
        }

        function updateCrushingDescents(deltaTime) {
            for (let i = crushingDescents.length - 1; i >= 0; i--) {
                const roller = crushingDescents[i];
                // Apply boss time stop
                const effectiveDeltaTime = bossTimeStopActive ? 0 : deltaTime;

                roller.y += roller.vy * effectiveDeltaTime * 60; // Move downwards

                if (roller.y > CANVAS_HEIGHT + roller.height) {
                    crushingDescents.splice(i, 1); // Remove when off-screen
                }
            }
        }

        function drawCrushingDescent(roller) {
            ctx.fillStyle = roller.color;
            ctx.strokeStyle = '#333333';
            ctx.lineWidth = 3;

            // Main body of the road roller (simplified rectangle)
            ctx.fillRect(roller.x, roller.y, roller.width, roller.height);
            ctx.strokeRect(roller.x, roller.y, roller.width, roller.height);

            // Wheels (simplified circles)
            ctx.beginPath();
            ctx.arc(roller.x + roller.width * 0.2, roller.y + roller.height, roller.height * 0.3, 0, Math.PI * 2);
            ctx.fillStyle = '#555555';
            ctx.fill();
            ctx.stroke();

            ctx.beginPath();
            ctx.arc(roller.x + roller.width * 0.8, roller.y + roller.height, roller.height * 0.3, 0, Math.PI * 2);
            ctx.fillStyle = '#555555';
            ctx.fill();
            ctx.stroke();

            // Cabin (small rectangle on top)
            ctx.fillStyle = '#880000'; // Dark red
            ctx.fillRect(roller.x + roller.width * 0.6, roller.y - roller.height * 0.3, roller.width * 0.3, roller.height * 0.3);
            ctx.strokeRect(roller.x + roller.width * 0.6, roller.y - roller.height * 0.3, roller.width * 0.3, roller.height * 0.3);
        }


        // --- Enemy and Boss logic ---
        function createEnemy(enemyType) {
            const type = enemyTypes[enemyType];
            const x = Math.random() * (CANVAS_WIDTH - type.width) + type.width / 2;
            const y = Math.random() * (CANVAS_HEIGHT / 4) + type.height / 2; // Spawn in upper quarter
            enemies.push({
                x: x,
                y: y,
                width: type.width,
                height: type.height,
                color: type.color,
                shootInterval: type.shootInterval,
                lastShotTime: 0,
                movePattern: type.movePattern,
                moveSpeed: type.moveSpeed || 0,
                health: type.health,
                maxHealth: type.health,
                moveDirection: (Math.random() > 0.5) ? 1 : -1, // Initial direction for horizontal/zigzag
                skillType: type.skillType, // New: skill type
                skillInterval: type.skillInterval, // New: skill interval
                lastSkillTime: 0, // New: last skill time
                isCharging: false, // For charger enemy
                chargeTimer: 0,
                chargeTargetX: 0,
                chargeTargetY: 0,
                originalColor: type.color, // Store original color for frozen effect
                // For rapidFire
                rapidFireCount: type.rapidFireCount || 0,
                rapidFireDelay: type.rapidFireDelay || 0,
                lastRapidFireBulletTime: 0,
                bulletsShotInBurst: 0,
                // For wave shooter
                waveDirection: type.waveDirection || null,
                // For homing shooter
                homingBullet: null, // To store the single homing bullet
                // For hybrid enemy
                attackPatterns: type.attackPatterns || [],
                currentAttackIndex: 0,
                attackSwitchInterval: type.attackSwitchInterval || 0,
                lastAttackSwitchTime: 0
            });
        }

        // Helper functions for enemy specific attacks
        function shootRapidFire(entity, deltaTime) {
            if (entity.bulletsShotInBurst > 0) { // If a burst is active
                entity.lastRapidFireBulletTime += deltaTime;
                if (entity.lastRapidFireBulletTime >= entity.rapidFireDelay) {
                    entity.lastRapidFireBulletTime = 0;
                    const bulletSpeed = 4 + difficultyLevel * 0.2; // Faster bullets
                    const bulletRadius = 5 + difficultyLevel * 0.1;
                    const bulletColor = '#ff0000'; // Red for basic
                    // Make spread wider at higher difficulties
                    const spread = (difficultyLevel >= 10) ? Math.PI / 8 : 0;
                    const angleToPlayer = Math.atan2(player.y - entity.y, player.x - entity.x) + (Math.random() - 0.5) * spread;
                    createBullet(entity.x, entity.y + entity.height / 2, angleToPlayer, bulletSpeed, bulletRadius, bulletColor, enemyProjectiles, false, 0, false, 'kiBlast'); // Added type
                    entity.bulletsShotInBurst--;
                }
            } else if (entity.lastShotTime >= entity.shootInterval) { // Start a new burst
                entity.lastShotTime = 0;
                entity.bulletsShotInBurst = entity.rapidFireCount + Math.floor(difficultyLevel / 7); // More bullets in burst
                entity.lastRapidFireBulletTime = 0; // Reset for the new burst
            }
        }

        function shootScatterShot(entity, deltaTime) {
            if (entity.lastSkillTime >= entity.skillInterval) {
                entity.lastSkillTime = 0;
                const numBullets = enemyTypes.scatter.scatterCount + Math.floor(difficultyLevel / 3); // Scale with difficulty
                const bulletSpeed = enemyTypes.scatter.scatterSpeed + difficultyLevel * 0.2; // Scale with difficulty
                const bulletRadius = 7;
                const bulletColor = '#ff00ff'; // Magenta for scatter bullets
                
                for (let p = 0; p < 5; p++) {
                    createParticle(entity.x, entity.y, bulletColor);
                }

                const startAngle = Math.atan2(player.y - entity.y, player.x - entity.x) - (Math.PI / 4);
                const endAngle = startAngle + (Math.PI / 2);
                for (let i = 0; i < numBullets; i++) {
                    const angle = startAngle + (i / (numBullets - 1)) * (endAngle - startAngle);
                    createBullet(entity.x, entity.y + entity.height / 2, angle, bulletSpeed, bulletRadius, bulletColor, enemyProjectiles, false, 0, false, 'magicMissile'); // Added type
                }
            }
        }

        function shootWaveShot(entity, deltaTime) {
            if (entity.lastSkillTime >= entity.skillInterval) {
                entity.lastSkillTime = 0;
                const numBullets = enemyTypes.wave.waveCount + Math.floor(difficultyLevel / 2);
                const bulletSpeed = enemyTypes.wave.waveSpeed + difficultyLevel * 0.15;
                const bulletRadius = 8;
                const bulletColor = '#00ffff'; // Cyan for wave bullets

                const waveDirection = entity.waveDirection || (Math.random() > 0.5 ? 'horizontal' : 'vertical');

                if (waveDirection === 'horizontal') {
                    const startY = entity.y + entity.height / 2;
                    const spacing = CANVAS_WIDTH / (numBullets + 1);
                    for (let i = 0; i < numBullets; i++) {
                        const x = (i + 1) * spacing;
                        createBullet(x, startY, Math.PI / 2, bulletSpeed, bulletRadius, bulletColor, enemyProjectiles, false, 0, false, 'energyWave'); // Added type
                    }
                } else { // vertical
                    const startX = entity.x + entity.width / 2;
                    const spacing = CANVAS_HEIGHT / (numBullets + 1);
                    for (let i = 0; i < numBullets; i++) {
                        const y = (i + 1) * spacing;
                        createBullet(startX, y, 0, bulletSpeed, bulletRadius, bulletColor, enemyProjectiles, false, 0, false, 'energyWave'); // Added type
                    }
                    if (difficultyLevel >= 15) {
                        const secondStartX = CANVAS_WIDTH - startX;
                        for (let i = 0; i < numBullets; i++) {
                            const y = (i + 1) * spacing;
                            createBullet(secondStartX, y, Math.PI, bulletSpeed, bulletRadius, bulletColor, enemyProjectiles, false, 0, false, 'energyWave'); // Added type
                        }
                    }
                }
            }
        }

        function shootHomingShot(entity, deltaTime) {
            if (entity.lastSkillTime >= entity.skillInterval) {
                entity.lastSkillTime = 0;
                const bulletSpeed = enemyTypes.homing.homingSpeed + difficultyLevel * 0.1;
                const homingStrength = enemyTypes.homing.homingStrength + difficultyLevel * 0.005;
                const bulletRadius = 10;
                const bulletColor = '#ff66b2'; // Pink for homing bullets

                const angleToPlayer = Math.atan2(player.y - entity.y, player.x - entity.x);
                createBullet(entity.x, entity.y + entity.height / 2, angleToPlayer, bulletSpeed, bulletRadius, bulletColor, enemyProjectiles, true, homingStrength, false, 'homingBeam'); // Added type

                if (difficultyLevel >= 18) {
                    const numHoming = 2 + Math.floor((difficultyLevel - 18) / 2);
                    const spreadAngle = Math.PI / 6;
                    for (let i = 0; i < numHoming; i++) {
                        const angleOffset = (i - (numHoming - 1) / 2) * (spreadAngle / numHoming);
                        createBullet(entity.x, entity.y + entity.height / 2, angleToPlayer + angleOffset, bulletSpeed * 0.8, bulletRadius * 0.8, bulletColor, enemyProjectiles, true, homingStrength * 0.8, false, 'homingBeam'); // Added type
                    }
                }
            }
        }


        function updateEnemies(deltaTime) {
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                const effectiveDeltaTime = bossTimeStopActive ? 0 : deltaTime;
                if (enemy.frozen) {
                    enemy.freezeTimer -= effectiveDeltaTime;
                    if (enemy.freezeTimer <= 0) {
                        enemy.frozen = false;
                        enemy.color = enemy.originalColor;
                    } else {
                        continue;
                    }
                }
                // --- Slime ---
                if (enemy.skillType === 'slimeShot') {
                    // Di chuyển chậm, thỉnh thoảng nhảy lên
                    if (!enemy.jumpTimer) enemy.jumpTimer = Math.random() * 3 + 2;
                    enemy.jumpTimer -= effectiveDeltaTime;
                    if (enemy.jumpTimer <= 0) {
                        enemy.vy = -2.5;
                        enemy.jumpTimer = Math.random() * 3 + 2;
                    }
                    if (!enemy.vy) enemy.vy = 0;
                    enemy.vy += 0.12; // Gravity
                    enemy.y += enemy.vy;
                    if (enemy.y > CANVAS_HEIGHT / 2 - enemy.height / 2) {
                        enemy.y = CANVAS_HEIGHT / 2 - enemy.height / 2;
                        if (enemy.vy > 1.5) {
                            // Khi rơi xuống, văng ra 2 đạn nhỏ
                            for (let b = -1; b <= 1; b += 2) {
                                createBullet(enemy.x, enemy.y + enemy.height / 2, Math.PI / 2 + b * Math.PI / 8, 2, 5, '#7ec850', enemyProjectiles, false, 0, false, 'slimeSplit');
                            }
                        }
                        enemy.vy = 0;
                    }
                    // Bắn đạn nhầy
                    enemy.lastShotTime += effectiveDeltaTime;
                    if (enemy.lastShotTime >= enemy.shootInterval) {
                        enemy.lastShotTime = 0;
                        createBullet(enemy.x, enemy.y + enemy.height / 2, Math.PI / 2, 1.5, 8, '#7ec850', enemyProjectiles, false, 0, false, 'slimeShot');
                    }
                // --- Fairy ---
                } else if (enemy.skillType === 'fairySpread') {
                            enemy.x += enemy.moveSpeed * enemy.moveDirection * effectiveDeltaTime;
                    enemy.y += Math.sin(performance.now() * 0.005 + enemy.x) * enemy.moveSpeed * 0.7 * effectiveDeltaTime;
                            if (enemy.x - enemy.width / 2 < 0 || enemy.x + enemy.width / 2 > CANVAS_WIDTH) {
                                enemy.moveDirection *= -1;
                            }
                    // Bắn danmaku tỏa tròn 8 hướng, cầu vồng
                    enemy.lastShotTime += effectiveDeltaTime;
                    let fairyFireRate = enemy.health < 20 ? 0.7 : enemy.shootInterval;
                    if (enemy.lastShotTime >= fairyFireRate) {
                        enemy.lastShotTime = 0;
                        for (let b = 0; b < 8; b++) {
                            const angle = (Math.PI * 2 / 8) * b;
                            const colors = ['#ff6666','#ffcc66','#66ff66','#66ccff','#cc66ff','#ff66cc','#ffff66','#66ffff'];
                            createBullet(enemy.x, enemy.y, angle, 2.2, 7, colors[b], enemyProjectiles, false, 0, false, 'fairyDanmaku');
                        }
                    }
                    // Gần chết tăng tốc
                    if (enemy.health < 20) enemy.moveSpeed = 2.2;
                // --- Yin-Yang Orb ---
                } else if (enemy.skillType === 'homing') {
                    // Bay lượn, bắn đạn homing xoay quanh rồi lao vào player
                    if (!enemy.floatAngle) enemy.floatAngle = Math.random() * Math.PI * 2;
                    enemy.floatAngle += 0.7 * effectiveDeltaTime;
                    enemy.x += Math.cos(enemy.floatAngle) * 0.7;
                    enemy.y += Math.sin(enemy.floatAngle) * 0.5;
                    // Clamp
                    enemy.x = Math.max(enemy.width / 2, Math.min(CANVAS_WIDTH - enemy.width / 2, enemy.x));
                    enemy.y = Math.max(enemy.height / 2, Math.min(CANVAS_HEIGHT / 2 - enemy.height / 2, enemy.y));
                    // Bắn đạn homing
                    enemy.lastShotTime += effectiveDeltaTime;
                    if (enemy.lastShotTime >= enemy.shootInterval) {
                        enemy.lastShotTime = 0;
                        let angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                        createBullet(enemy.x, enemy.y, angle, 2.3, 9, '#ff2222', enemyProjectiles, true, 0.08, false, 'yinyangHoming');
                    }
                // --- Bat ---
                } else if (enemy.skillType === 'dive') {
                    // Di chuyển nhanh, thỉnh thoảng lướt cực nhanh
                    if (!enemy.diveTimer) enemy.diveTimer = Math.random() * 3 + 2;
                    enemy.diveTimer -= effectiveDeltaTime;
                    if (enemy.diveTimer <= 0) {
                        enemy.diveSpeed = 7;
                        enemy.diveAngle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                        enemy.diveTimer = Math.random() * 3 + 2;
                    }
                    if (enemy.diveSpeed && enemy.diveSpeed > 0.5) {
                        enemy.x += Math.cos(enemy.diveAngle) * enemy.diveSpeed;
                        enemy.y += Math.sin(enemy.diveAngle) * enemy.diveSpeed;
                        enemy.diveSpeed *= 0.92;
                } else {
                        enemy.x += enemy.moveSpeed * enemy.moveDirection * effectiveDeltaTime;
                        if (enemy.x - enemy.width / 2 < 0 || enemy.x + enemy.width / 2 > CANVAS_WIDTH) {
                            enemy.moveDirection *= -1;
                        }
                    }
                // --- Ghost ---
                } else if (enemy.skillType === 'ghostExplode') {
                    enemy.y += enemy.moveSpeed * effectiveDeltaTime;
                    // Đạn linh hồn xuyên tường
                    enemy.lastShotTime += effectiveDeltaTime;
                    if (enemy.lastShotTime >= enemy.shootInterval) {
                        enemy.lastShotTime = 0;
                        createBullet(enemy.x, enemy.y + enemy.height / 2, Math.PI / 2, 2.1, 8, '#66ccff', enemyProjectiles, false, 0, false, 'ghostSoul');
                    }
                }
                // Clamp vị trí cho các loại không xuyên tường
                if (enemy.skillType !== 'ghostExplode') {
                enemy.x = Math.max(enemy.width / 2, Math.min(CANVAS_WIDTH - enemy.width / 2, enemy.x));
                    enemy.y = Math.max(enemy.height / 2, Math.min(CANVAS_HEIGHT / 2 - enemy.height / 2, enemy.y));
                }
                // --- Bat khi chết phát nổ thành 3 đạn hình cánh dơi ---
                if (enemy.health <= 0) {
                    if (enemy.skillType === 'bat') {
                        for (let b = 0; b < 3; b++) {
                            const angle = (Math.PI * 2 / 3) * b;
                            createBullet(enemy.x, enemy.y, angle, 2.5, 8, '#a060c0', enemyProjectiles, false, 0, false, 'batWing');
                        }
                    }
                    // --- Ghost phát nổ thành vòng tròn đạn lớn, đạn mờ dần ---
                    if (enemy.skillType === 'ghostExplode') {
                        const numBullets = 12;
                        for (let b = 0; b < numBullets; b++) {
                            const angle = (Math.PI * 2 / numBullets) * b;
                            createBullet(enemy.x, enemy.y, angle, 2.2, 7, '#66ccff', enemyProjectiles, false, 0, false, 'ghostExplode');
                        }
                    }
                    enemies.splice(i, 1);
                    score += 20;
                    playBossHitSFX();
                }
            }
        }

        // Dispatcher function for enemy shooting (excluding hybrid which has its own logic)
        function enemyShootDispatcher(entity, deltaTime, skillType) {
            entity.lastShotTime += deltaTime;
            entity.lastSkillTime += deltaTime;

            if (skillType === 'rapidFire') {
                shootRapidFire(entity, deltaTime);
            } else if (skillType === 'scatterShot') {
                shootScatterShot(entity, deltaTime);
            } else if (skillType === 'waveShot') {
                shootWaveShot(entity, deltaTime);
            } else if (skillType === 'homingShot') {
                shootHomingShot(entity, deltaTime);
            }
            // Charger enemy doesn't shoot regular bullets while charging, handled in updateEnemies
        }


        function createBoss() {
            currentBossPhaseIndex = 0; // Start at phase 0
            const initialPhase = BOSS_PHASES[currentBossPhaseIndex];
            boss = {
                x: CANVAS_WIDTH / 2,
                y: 100,
                width: 80,
                height: 80,
                color: '#ff4500', // OrangeRed
                health: initialPhase.maxHealth,
                maxHealth: initialPhase.maxHealth,
                shootInterval: initialPhase.shootInterval,
                lastShotTime: 0,
                moveSpeed: 2, // Boss horizontal movement speed
                moveDirection: 1 // 1 for right, -1 for left
            };
            bossActive = true;
            enemies.length = 0; // Clear regular enemies (INTENTIONAL GAME DESIGN)
            enemyProjectiles.length = 0; // Clear existing bullets
            playerProjectiles.length = 0; // Clear player bullets
            bulletTrails.length = 0;
            artifacts.length = 0; // Clear artifacts
            particles.length = 0;
            beams.length = 0; // Clear beams
            darkZones.length = 0; // Clear dark zones
            spectralSpikes.length = 0;
            phantomBlasters.length = 0;
            crushingDescents.length = 0; // Clear crushing descents
            bossTimeStopActive = false; // Reset boss time stop
            playerMovementFrozen = false; // Reset player freeze
            playerSkillsFrozen = false; // Reset player skills freeze

            difficultyLevel = 1; // Reset difficulty for boss fight patterns
            difficultyDisplay.textContent = `${currentLanguage === 'en' ? 'Difficulty: BOSS PHASE' : 'Độ khó: BOSS GIAI ĐOẠN'} ${currentBossPhaseIndex + 1}`;
            lastBossDamageTime = performance.now(); // Reset damage timer
            updateBossHealthBar();
        }

        function updateBoss(deltaTime) {
            if (!boss) return;

            // Boss movement (simple horizontal patrol) - ALWAYS MOVE UNLESS FROZEN by player skill
            if (!boss.frozen) {
                boss.x += boss.moveSpeed * boss.moveDirection * deltaTime;
                if (boss.x + boss.width / 2 > CANVAS_WIDTH || boss.x - boss.width / 2 < 0) {
                    boss.moveDirection *= -1; // Reverse direction
                }
            }

            // Always decrement boss's attack cooldown timer
            boss.lastShotTime += deltaTime;

            // Handle boss time stop (from its own Temporal Stasis skill)
            // This timer ALWAYS decrements, regardless of other states
            if (bossTimeStopActive) {
                bossTimeStopTimer -= deltaTime;
                if (bossTimeStopTimer <= 0) {
                    bossTimeStopActive = false;
                    playerMovementFrozen = false; // Unfreeze player movement
                    playerSkillsFrozen = false; // Unfreeze player skills
                    // Time Manipulator performs an attack immediately after time stop ends
                    if (currentBossPhaseIndex === 3) { // Ensure it's the Time Manipulator
                        const patternRoll = Math.random();
                        if (patternRoll < 0.5) {
                            shootFistOfFuryBarrage(boss);
                        } else {
                            createCrushingDescent(Math.random() * (CANVAS_WIDTH - 100), -200, 100, 150, 2);
                        }
                    }
                }
            }

            // Handle boss frozen state (from player skills like Cirno's Absolute Zero Form)
            // This will affect boss's own attacks and damage over time
            let effectiveDeltaTimeForAttacks = deltaTime;
            if (boss.frozen) {
                boss.freezeTimer -= deltaTime; // Freeze timer always decrements
                if (boss.freezeTimer <= 0) {
                    boss.frozen = false;
                    boss.color = boss.originalColor;
                }
                effectiveDeltaTimeForAttacks = 0; // If frozen, no attacks, no damage over time
            }

            // Boss takes damage over time (survival damage) - ONLY IF NOT FROZEN
            if (!boss.frozen && performance.now() - lastBossDamageTime >= BOSS_DAMAGE_INTERVAL * 1000) {
                boss.health -= 100;
                lastBossDamageTime = performance.now();
                playBossHitSFX();
                console.log(`Boss health: ${boss.health}`);
            }

            // Check for phase transition
            const currentPhaseData = BOSS_PHASES[currentBossPhaseIndex];
            if (boss.health <= 0 && currentBossPhaseIndex < BOSS_PHASES.length - 1) {
                currentBossPhaseIndex++;
                const nextPhaseData = BOSS_PHASES[currentBossPhaseIndex];
                boss.maxHealth = nextPhaseData.maxHealth;
                boss.health = nextPhaseData.maxHealth; // Reset health for new phase
                boss.shootInterval = nextPhaseData.shootInterval;
                // Clear all boss-specific attacks on phase transition
                beams.length = 0;
                darkZones.length = 0;
                spectralSpikes.length = 0;
                phantomBlasters.length = 0;
                crushingDescents.length = 0;
                enemyProjectiles.length = 0;
                bulletTrails.length = 0;
                bossTimeStopActive = false; // Reset boss time stop
                playerMovementFrozen = false; // Reset player freeze
                playerSkillsFrozen = false; // Reset player skills freeze

                difficultyDisplay.textContent = `${currentLanguage === 'en' ? 'Difficulty: BOSS PHASE' : 'Độ khó: BOSS GIAI ĐOẠN'} ${currentBossPhaseIndex + 1}`;
                playDifficultyUpSFX();
            } else if (boss.health <= 0 && currentBossPhaseIndex === BOSS_PHASES.length - 1) {
                gameWin();
                return;
            }

            // Boss attack patterns based on current phase
            // Only trigger attacks if not in own time stop and not frozen by player
            if (!bossTimeStopActive && !boss.frozen && boss.lastShotTime >= boss.shootInterval) { // Added boss.lastShotTime check here
                boss.lastShotTime = 0; // Reset cooldown ONLY when an attack is triggered
                bossAttack(boss, effectiveDeltaTimeForAttacks, currentBossPhaseIndex);
            }

            updateBossHealthBar();
        }

        // --- Boss Specific Attack Patterns ---
        function bossAttack(bossEntity, deltaTime, phaseIndex) {
            // The bossEntity.lastShotTime is now incremented in updateBoss, so we just check it here.
            // This function is only called if !bossTimeStopActive && !boss.frozen
            // So, we just need to choose an attack.

            // bossEntity.lastShotTime is reset to 0 in updateBoss right before calling this function
            // if it's time to attack. So we don't need to check bossEntity.lastShotTime here.
            // We just need to choose an attack.

            switch (phaseIndex) {
                case 0: // Shadow Weaver Phase (Cid): Energy Beams, Grenade Barrage
                    const patternRollP1 = Math.random();
                    if (patternRollP1 < 0.6) { // Existing beam attacks
                        const beamWidth = 8 + difficultyLevel * 0.2; // Scale beam width
                        const beamLength = CANVAS_WIDTH * 1.5;
                        let warningDuration = 1.5 - difficultyLevel * 0.05; // Shorter warning
                        let activeDuration = 1.8 - difficultyLevel * 0.05; // Shorter active
                        const beamColor = '#00ff00';

                        const subPatternRoll = Math.random();
                        if (subPatternRoll < 0.3) { // Horizontal sweeping beam (common)
                            const startY = Math.random() * (CANVAS_HEIGHT / 2) + 50;
                            const numSweeps = 2 + Math.floor(difficultyLevel / 10); // More sweeps
                            for (let i = 0; i < numSweeps; i++) {
                                addTimer('timeout', () => {
                                    createBeamHazard(0, startY + i * 40, CANVAS_WIDTH, startY + i * 40, beamWidth, beamColor, warningDuration, activeDuration);
                                }, i * (200 - difficultyLevel * 5)); // Faster sweeps
                            }
                        } else if (subPatternRoll < 0.6) { // Aimed cross beams (common)
                            const angleToPlayer = Math.atan2(player.y - bossEntity.y, player.x - bossEntity.x);
                            const numCrossBeams = 3 + Math.floor(difficultyLevel / 8); // More cross beams
                            for (let i = 0; i < numCrossBeams; i++) {
                                const angleOffset = (i - (numCrossBeams - 1) / 2) * (Math.PI / 6); // Spread
                                createBeamHazard(bossEntity.x, bossEntity.y, bossEntity.x + Math.cos(angleToPlayer + angleOffset) * beamLength, bossEntity.y + Math.sin(angleToPlayer + angleOffset) * beamLength, beamWidth, beamColor, warningDuration, activeDuration);
                            }
                        } else if (subZonePatternRoll < 0.8) { // Converging Beams (new, moderate difficulty)
                            const numConvergingBeams = 3 + Math.floor(difficultyLevel / 6);
                            for (let i = 0; i < numConvergingBeams; i++) {
                                const startX = (i / (numConvergingBeams - 1)) * CANVAS_WIDTH;
                                const startY = (i % 2 === 0) ? 0 : CANVAS_HEIGHT;
                                addTimer('timeout', () => {
                                    createBeamHazard(startX, startY, player.x, player.y, beamWidth * 0.8, beamColor, warningDuration * 0.8, activeDuration * 0.8);
                                }, i * (150 - difficultyLevel * 3));
                            }
                        } else { // Grid Beams (new, harder, but scaled down)
                            const numGridLines = 3 + Math.floor(difficultyLevel / 5);
                            for (let i = 0; i < numGridLines; i++) {
                                // Horizontal
                                createBeamHazard(0, (i + 1) * (CANVAS_HEIGHT / (numGridLines + 1)), CANVAS_WIDTH, (i + 1) * (CANVAS_HEIGHT / (numGridLines + 1)), beamWidth * 0.7, beamColor, warningDuration * 0.7, activeDuration * 0.7);
                                // Vertical
                                createBeamHazard((i + 1) * (CANVAS_WIDTH / (numGridLines + 1)), 0, (i + 1) * (CANVAS_WIDTH / (numGridLines + 1)), CANVAS_HEIGHT, beamWidth * 0.7, beamColor, warningDuration * 0.7, activeDuration * 0.7);
                            }
                        }
                    } else { // New: Grenade Barrage (Cid)
                        shootGrenadeBarrage(bossEntity);
                    }
                    break;

                case 1: // Lich Overlord Phase (Overlord): Dark Zones, Abyssal Vortex
                    const zonePatternRollP2 = Math.random();
                    let zoneRadius = 50 + difficultyLevel * 1.5; // Scale radius
                    const zoneDamage = 1;
                    let warningDurationZone = 1.2 - difficultyLevel * 0.03;
                    let activeDurationZone = 2.5 - difficultyLevel * 0.05;
                    const zoneColor = '#330033';

                    if (zonePatternRollP2 < 0.5) { // Existing dark zone attacks
                        const subZonePatternRoll = Math.random();
                        if (subZonePatternRoll < 0.35) { // Static zones at player and random spots
                            createDarkZone(player.x, player.y, zoneRadius, zoneDamage, warningDurationZone, activeDurationZone, zoneColor);
                            const numRandomZones = 1 + Math.floor(difficultyLevel / 9); // More random zones
                            for (let i = 0; i < numRandomZones; i++) {
                                const randX = Math.random() * CANVAS_WIDTH;
                                const randY = Math.random() * (CANVAS_HEIGHT - 100) + 50;
                                createDarkZone(randX, randY, zoneRadius * 0.7, zoneDamage, warningDurationZone * 0.8, activeDurationZone * 0.8, zoneColor);
                            }
                        } else if (subZonePatternRoll < 0.65) { // Moving dark zones
                            const numMovingZones = 1 + Math.floor(difficultyLevel / 7);
                            for (let i = 0; i < numMovingZones; i++) {
                                const startX = Math.random() * CANVAS_WIDTH;
                                const startY = Math.random() * (CANVAS_HEIGHT / 2);
                                const targetX = Math.random() * CANVAS_WIDTH;
                                const targetY = Math.random() * (CANVAS_HEIGHT / 2);
                                const moveSpeed = 30 + difficultyLevel * 0.5; // Faster moving zones
                                createMovingDarkZone(startX, startY, zoneRadius * 0.8, zoneDamage, warningDurationZone, activeDurationZone, zoneColor, targetX, targetY, moveSpeed);
                            }
                        } else if (subZonePatternRoll < 0.85) { // Expanding/Shrinking Zones (new)
                            const zoneType = Math.random() < 0.5 ? 'expanding' : 'shrinking';
                            const x = Math.random() * (CANVAS_WIDTH - zoneRadius * 2) + zoneRadius;
                            const y = Math.random() * (CANVAS_HEIGHT / 2 - zoneRadius * 2) + zoneRadius;
                            createDarkZone(x, y, zoneRadius, zoneDamage, warningDurationZone * 0.9, activeDurationZone * 0.9, zoneColor, zoneType);
                        } else { // Chaining Zones (new, slightly harder)
                            const numChains = 3 + Math.floor(difficultyLevel / 6);
                            for (let i = 0; i < numChains; i++) {
                                addTimer('timeout', () => {
                                    const x = Math.random() * (CANVAS_WIDTH - zoneRadius * 2) + zoneRadius;
                                    const y = Math.random() * (CANVAS_HEIGHT / 2 - zoneRadius * 2) + zoneRadius;
                                    createDarkZone(x, y, zoneRadius * 0.7, zoneDamage, warningDurationZone * 0.7, activeDurationZone * 0.7, zoneColor);
                                }, i * (500 - difficultyLevel * 10)); // Faster chaining
                            }
                        }
                    } else { // New: Abyssal Vortex (Overlord)
                        createAbyssalVortex(bossEntity);
                    }
                    break;

                case 2: // Spirit of Retribution Phase (Sans): Spectral Spikes, Phantom Blasters, Bone Walls, Gaster Blaster Barrage
                    const retributionPatternP3 = Math.random();
                    let spikeSpeed = 3 + difficultyLevel * 0.1;
                    let blasterSize = 40;
                    let blasterChargeDuration = 1.2 - difficultyLevel * 0.03;
                    let blasterFireDuration = 0.7 - difficultyLevel * 0.02;

                    if (retributionPatternP3 < 0.3) { // Spectral Spike attack (common)
                        const spikeWidth = 20 + difficultyLevel * 0.1;
                        const spikeHeight = 80 + difficultyLevel * 0.1;
                        const spikeColor = '#ffffff';

                        // Horizontal spike wall with gaps
                        const numSpikes = Math.floor(CANVAS_WIDTH / (spikeWidth + 40));
                        const gapPosition = Math.floor(Math.random() * (numSpikes - 1));
                        const startY = bossEntity.y + bossEntity.height / 2 + 50;

                        for (let i = 0; i < numSpikes; i++) {
                            if (i !== gapPosition && i !== gapPosition + 1) {
                                createSpectralSpike(i * (spikeWidth + 40), startY, spikeWidth, spikeHeight, 0, spikeSpeed, spikeColor);
                            }
                        }
                    } else if (retributionPatternP3 < 0.5) { // Phantom Blaster attack (common)
                        const blasterColor = '#3333ff';
                        createPhantomBlaster(bossEntity.x, bossEntity.y, player.x, player.y, blasterSize, blasterChargeDuration, blasterFireDuration, blasterColor);
                    } else if (retributionPatternP3 < 0.7) { // New: Bone Walls (Sans)
                        createBoneWall(bossEntity, Math.random() < 0.5); // Randomly vertical or horizontal
                    } else { // New: Gaster Blaster Barrage (Sans)
                        createGasterBlasterBarrage(bossEntity);
                    }
                    break;
                case 3: // Time Manipulator Phase (Dio): Crushing Descent, Fist of Fury Barrage, Temporal Stasis, Knife Throw
                    const timeManipulatorPatternP4 = Math.random();
                    if (timeManipulatorPatternP4 < 0.3) { // Fist of Fury Barrage
                        shootFistOfFuryBarrage(bossEntity);
                    } else if (timeManipulatorPatternP4 < 0.6) { // Crushing Descent
                        const rollerWidth = 120;
                        const rollerHeight = 180;
                        const rollerSpeed = 1.5 + difficultyLevel * 0.05;
                        const rollerColor = '#a0a0a0';
                        createCrushingDescent(Math.random() * (CANVAS_WIDTH - rollerWidth), -rollerHeight, rollerWidth, rollerHeight, rollerSpeed, rollerColor);
                    } else if (timeManipulatorPatternP4 < 0.8) { // Temporal Stasis
                        const timeStopDuration = 2 + difficultyLevel * 0.05;
                        activateBossTemporalStasis(bossEntity, timeStopDuration);
                    } else { // New: Knife Throw (Dio)
                        shootKnifeThrow(bossEntity);
                    }
                    break;
            }
        }

        // --- NEW BOSS ATTACK FUNCTIONS ---

        // Phase 1 (Cid) - Grenade Barrage
        function shootGrenadeBarrage(bossEntity) {
            const numGrenades = 3 + Math.floor(difficultyLevel / 5); // More grenades
            const grenadeSpeed = 3 + difficultyLevel * 0.1; // Faster initial speed
            const grenadeRadius = 15;
            const grenadeColor = '#666666'; // Dark grey
            const explosionY = player.y - (50 + difficultyLevel * 5); // Explode closer to player at higher difficulty

            for (let i = 0; i < numGrenades; i++) {
                const angle = Math.atan2(explosionY - bossEntity.y, player.x - bossEntity.x) + (Math.random() - 0.5) * (Math.PI / (8 - difficultyLevel * 0.1)); // Aimed with slight spread
                addTimer('timeout', () => {
                    createBullet(bossEntity.x, bossEntity.y, angle, grenadeSpeed, grenadeRadius, grenadeColor, enemyProjectiles, false, 0, false, 'grenade', explosionY);
                }, i * (300 - difficultyLevel * 5)); // Staggered launch, faster
            }
            // Play a grenade launch SFX
            playGrenadeLaunchSFX();
        }

        function explodeGrenade(grenade) {
            const numShrapnel = 12 + Math.floor(difficultyLevel / 3);
            const shrapnelSpeed = 5 + difficultyLevel * 0.1;
            const shrapnelRadius = 5;
            const shrapnelColor = '#ff8c00'; // Dark orange for explosion

            for (let i = 0; i < numShrapnel; i++) {
                const angle = (i / numShrapnel) * Math.PI * 2;
                createBullet(grenade.x, grenade.y, angle, shrapnelSpeed, shrapnelRadius, shrapnelColor, enemyProjectiles, false, 0, false, 'kiBlast'); // Use kiBlast type for shrapnel
            }
            // Play an explosion SFX
            playExplosionSFX();
        }

        // Phase 2 (Overlord) - Abyssal Vortex
        function createAbyssalVortex(bossEntity) {
            const vortexRadius = 80 + difficultyLevel * 2; // Scales with difficulty
            const vortexDamage = 1;
            const warningDurationVortex = 1.8 - difficultyLevel * 0.05;
            const activeDurationVortex = 4 - difficultyLevel * 0.08;
            const vortexColor = '#1a001a'; // Very dark purple
            const vortexSpeed = 0.5 + difficultyLevel * 0.02; // Slow movement

            // Spawn vortex at boss's current position, moving towards player
            const angleToPlayer = Math.atan2(player.y - bossEntity.y, player.x - bossEntity.x);
            const targetX = bossEntity.x + Math.cos(angleToPlayer) * 200; // Target a point in player's direction
            const targetY = bossEntity.y + Math.sin(angleToPlayer) * 200;

            createMovingDarkZone(bossEntity.x, bossEntity.y, vortexRadius, vortexDamage, warningDurationVortex, activeDurationVortex, vortexColor, targetX, targetY, vortexSpeed);
            playVortexSFX();
        }

        // Phase 3 (Sans) - Bone Walls
        function createBoneWall(bossEntity, isVertical) {
            const boneWidth = 25 + difficultyLevel * 0.1;
            const boneHeight = 70 + difficultyLevel * 0.1;
            const boneColor = '#f0f0f0'; // Light grey
            const wallSpeed = 2 + difficultyLevel * 0.05;

            if (isVertical) {
                const numBones = Math.floor(CANVAS_HEIGHT / (boneHeight + 20));
                const gapSize = 2 - Math.floor(difficultyLevel / 15); // Smaller gap at higher difficulty
                const gapPosition = Math.floor(Math.random() * (numBones - gapSize));
                const startX = Math.random() < 0.5 ? 0 : CANVAS_WIDTH - boneWidth; // From left or right

                for (let i = 0; i < numBones; i++) {
                    if (i < gapPosition || i >= gapPosition + gapSize) { // Create a gap of `gapSize` bones
                        createSpectralSpike(startX, i * (boneHeight + 20), boneWidth, boneHeight, startX === 0 ? wallSpeed : -wallSpeed, 0, boneColor);
                    }
                }
            } else { // Horizontal
                const numBones = Math.floor(CANVAS_WIDTH / (boneWidth + 20));
                const gapSize = 2 - Math.floor(difficultyLevel / 15); // Smaller gap at higher difficulty
                const gapPosition = Math.floor(Math.random() * (numBones - gapSize));
                const startY = Math.random() < 0.5 ? 0 : CANVAS_HEIGHT - boneHeight; // From top or bottom

                for (let i = 0; i < numBones; i++) {
                    if (i < gapPosition || i >= gapPosition + gapSize) { // Create a gap of `gapSize` bones
                        createSpectralSpike(i * (boneWidth + 20), startY, boneWidth, boneHeight, 0, startY === 0 ? wallSpeed : -wallSpeed, boneColor);
                    }
                }
            }
            playBoneWallSFX();
        }

        // Phase 3 (Sans) - Gaster Blaster Barrage
        function createGasterBlasterBarrage(bossEntity) {
            const numBlasters = 3 + Math.floor(difficultyLevel / 5);
            const blasterSize = 35 + difficultyLevel * 0.2;
            const blasterChargeDuration = 0.8 - difficultyLevel * 0.02;
            const blasterFireDuration = 0.5 - difficultyLevel * 0.01;
            const blasterColor = '#00ffff'; // Cyan for Gaster Blasters

            for (let i = 0; i < numBlasters; i++) {
                const angleOffset = (i - (numBlasters - 1) / 2) * (Math.PI / (10 - difficultyLevel * 0.1)); // Spread angle
                const targetAngle = Math.atan2(player.y - bossEntity.y, player.x - bossEntity.x) + angleOffset;
                addTimer('timeout', () => {
                    createPhantomBlaster(bossEntity.x, bossEntity.y, bossEntity.x + Math.cos(targetAngle) * 500, bossEntity.y + Math.sin(targetAngle) * 500, blasterSize, blasterChargeDuration, blasterFireDuration, blasterColor);
                }, i * (200 - difficultyLevel * 4)); // Staggered firing, faster
            }
            // Blaster SFX are handled in updatePhantomBlasters
        }

        // Phase 4 (Dio) - Fist of Fury Barrage
        function shootFistOfFuryBarrage(bossEntity) {
            const numPunches = 10 + Math.floor(difficultyLevel / 2);
            const punchSpeed = 10 + difficultyLevel * 0.2;
            const punchRadius = 6;
            const punchColor = '#ff0000'; // Red for Fist of Fury

            for (let i = 0; i < numPunches; i++) {
                const angle = Math.atan2(player.y - bossEntity.y, player.x - bossEntity.x) + (Math.random() - 0.5) * (Math.PI / (6 - difficultyLevel * 0.05)); // Aimed with slight spread
                addTimer('timeout', () => {
                    createBullet(bossEntity.x, bossEntity.y, angle, punchSpeed, punchRadius, punchColor, enemyProjectiles, false, 0, false, 'fistOfFury');
                }, i * (50 - difficultyLevel)); // Rapid fire, faster
            }
            playFistOfFurySFX();
        }

        // Phase 4 (Dio) - Temporal Stasis
        function activateBossTemporalStasis(bossEntity, duration) {
            bossTimeStopActive = true;
            bossTimeStopTimer = duration; // This timer will be decremented in updateBoss
            playerMovementFrozen = true; // Freeze player movement
            playerSkillsFrozen = true; // Freeze player skills
            playTemporalStasisSFX();

            // Move boss to a new random position during time stop
            bossEntity.x = Math.random() * (CANVAS_WIDTH - bossEntity.width) + bossEntity.width / 2;
            bossEntity.y = Math.random() * (CANVAS_HEIGHT / 3 - bossEntity.height) + bossEntity.height / 2;
            
            // Clear all current player projectiles during boss time stop
            playerProjectiles.length = 0;
            bulletTrails.length = 0;
        }

        // Phase 4 (Dio) - Knife Throw
        function shootKnifeThrow(bossEntity) {
            const numKnives = 5 + Math.floor(difficultyLevel / 4);
            const knifeSpeed = 12 + difficultyLevel * 0.3;
            const knifeRadius = 8;
            const knifeColor = '#cccccc'; // Silver

            for (let i = 0; i < numKnives; i++) {
                const angle = Math.atan2(player.y - bossEntity.y, player.x - bossEntity.x) + (i - (numKnives - 1) / 2) * (Math.PI / (12 - difficultyLevel * 0.1)); // Fan spread
                addTimer('timeout', () => {
                    createBullet(bossEntity.x, bossEntity.y, angle, knifeSpeed, knifeRadius, knifeColor, enemyProjectiles, false, 0, false, 'knife');
                }, i * (80 - difficultyLevel * 2)); // Staggered throw, faster
            }
            playKnifeThrowSFX();
        }


        // --- Collision detection (circle vs circle) ---
        function checkCollision(circle1, circle2) {
            const dx = circle1.x - circle2.x;
            const dy = circle1.y - circle2.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            return distance < circle1.radius + circle2.radius;
        }

        // Collision for Player (rectangle) and Beam (line segment)
        function checkBeamCollision(playerRect, beam) {
            // Only active beams cause damage
            if (beam.state !== 'active') return false;

            // Simplified line-rectangle collision: check if any of the beam's endpoints are inside the player
            // or if the beam crosses any of the player's rectangle sides.
            // For a thin beam, checking if the player's hitbox overlaps the beam's path is more accurate.
            // Approximate player as a circle for simpler collision with beam line.
            const playerCircle = { x: playerRect.x, y: playerRect.y, radius: playerRect.hitboxRadius };

            // Line segment (beam) defined by (x1, y1) to (x2, y2)
            const x1 = beam.startX;
            const y1 = beam.startY;
            const x2 = beam.endX;
            const y2 = beam.endY;

            // Closest point on the line segment to the player's circle center
            const lenSq = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
            let t = ((playerCircle.x - x1) * (x2 - x1) + (playerCircle.y - y1) * (y2 - y1)) / lenSq;
            t = Math.max(0, Math.min(1, t)); // Clamp t to [0, 1] for segment

            const closestX = x1 + t * (x2 - x1);
            const closestY = y1 + t * (y2 - y1);

            const dx = playerCircle.x - closestX;
            const dy = playerCircle.y - closestY;
            const distanceSq = dx * dx + dy * dy;

            // Check if distance to closest point on segment is less than player's radius + beam width/2
            return distanceSq < (playerCircle.radius + beam.width / 2) * (playerCircle.radius + beam.width / 2);
        }

        // Collision for Player (rectangle) and Dark Zone (circle)
        function checkDarkZoneCollision(playerRect, darkZone) {
            // Player is approximated as a circle for this collision
            const playerCircle = { x: playerRect.x, y: playerRect.y, radius: playerRect.hitboxRadius };
            const dx = playerCircle.x - darkZone.x;
            const dy = playerCircle.y - darkZone.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            return distance < playerCircle.radius + darkZone.radius;
        }

        // Collision for Player (rectangle) and Spectral Spike (rectangle)
        function checkSpectralSpikeCollision(playerRect, spikeRect) {
            // Player's actual rectangle bounds
            const pLeft = playerRect.x - playerRect.width / 2;
            const pRight = playerRect.x + playerRect.width / 2;
            const pTop = playerRect.y - playerRect.height / 2;
            const pBottom = playerRect.y + playerRect.height / 2;

            // Spike's rectangle bounds
            const sLeft = spikeRect.x;
            const sRight = spikeRect.x + spikeRect.width;
            const sTop = spikeRect.y;
            const sBottom = spikeRect.y + spikeRect.height;

            // Check for overlap
            return pLeft < sRight && pRight > sLeft && pTop < sBottom && pBottom > sTop;
        }

        // Collision for Player (rectangle) and Phantom Blaster laser (line)
        function checkPhantomBlasterCollision(playerRect, blaster) {
            if (blaster.state !== 'firing') return false;

            // Player's actual rectangle bounds
            const pLeft = playerRect.x - playerRect.width / 2;
            const pRight = playerRect.x + playerRect.width / 2;
            const pTop = playerRect.y - playerRect.height / 2;
            const pBottom = playerRect.y + playerRect.height / 2;

            // Laser is a line segment from blaster's muzzle to far end, rotated
            // For simplicity, let's assume the laser is a rectangle aligned with its angle
            // This is a complex geometric collision. For game purposes, approximate.
            // A simpler approach: check if player's hitbox (circle) intersects the laser's path.
            // The laser is a thick line. Treat it as a rectangle for collision.

            // Calculate laser end points in global coordinates
            const laserStartX = blaster.x + Math.cos(blaster.angle) * (blaster.size * 0.5);
            const laserStartY = blaster.y + Math.sin(blaster.angle) * (blaster.size * 0.5);
            const laserEndX = blaster.x + Math.cos(blaster.angle) * (blaster.size * 0.5 + CANVAS_WIDTH); // Extend far
            const laserEndY = blaster.y + Math.sin(blaster.angle) * (blaster.size * 0.5 + CANVAS_WIDTH);
            const laserWidth = blaster.size * 0.2; // Thickness of the laser

            // Create a simplified collision check for the laser as a fat line segment
            // using the same logic as checkBeamCollision, but with player's hitboxRadius
            const playerCircle = { x: playerRect.x, y: playerRect.y, radius: playerRect.hitboxRadius };

            const x1 = laserStartX;
            const y1 = laserStartY;
            const x2 = laserEndX;
            const y2 = laserEndY;

            const lenSq = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
            let t = ((playerCircle.x - x1) * (x2 - x1) + (playerCircle.y - y1) * (y2 - y1)) / lenSq;
            t = Math.max(0, Math.min(1, t)); // Clamp t to [0, 1] for segment

            const closestX = x1 + t * (x2 - x1);
            const closestY = y1 + t * (y2 - y1);

            const dx = playerCircle.x - closestX;
            const dy = playerCircle.y - closestY;
            const distanceSq = dx * dx + dy * dy;

            return distanceSq < (playerCircle.radius + laserWidth / 2) * (playerCircle.radius + laserWidth / 2);
        }

        // Collision for Player (rectangle) and Crushing Descent (rectangle)
        function checkCrushingDescentCollision(playerRect, rollerRect) {
            // Player's actual rectangle bounds
            const pLeft = playerRect.x - playerRect.width / 2;
            const pRight = playerRect.x + playerRect.width / 2;
            const pTop = playerRect.y - playerRect.height / 2;
            const pBottom = playerRect.y + playerRect.height / 2;

            // Roller's rectangle bounds
            const rLeft = rollerRect.x;
            const rRight = rollerRect.x + rollerRect.width;
            const rTop = rollerRect.y;
            const rBottom = rollerRect.y + rollerRect.height;

            // Check for overlap
            return pLeft < rRight && pRight > rLeft && pTop < rBottom && pBottom > rTop;
        }


        // --- Background music (using Tone.js) ---
        let synth;
        let bassSynth;
        let drumSynth;
        let reverb;
        let delay;
        let masterGain;
        let melodyLoop;
        let bassLoop;
        let drumLoop;
        let isMusicPlaying = false;

        function initMusic() {
            if (!synth) {
                // Ensure Tone.js context is started before creating nodes
                Tone.start().then(() => {
                    // Reverb and Delay effects
                    reverb = new Tone.Reverb(2).toDestination();
                    delay = new Tone.FeedbackDelay("8n", 0.5).toDestination();

                    // Synth for main melody
                    synth = new Tone.PolySynth(Tone.Synth, {
                        oscillator: { type: "triangle" },
                        envelope: { attack: 0.01, decay: 0.2, sustain: 0.4, release: 0.8 }
                    }).chain(reverb, delay, Tone.Destination);

                    // Synth for bassline
                    bassSynth = new Tone.Synth({
                        oscillator: { type: "sine" },
                        envelope: { attack: 0.01, decay: 0.1, sustain: 0.5, release: 1.2 }
                    }).chain(reverb, Tone.Destination);

                    // Synth for simple drums (kick and snare)
                    drumSynth = new Tone.MembraneSynth({
                        pitchDecay: 0.05,
                        octaves: 10,
                        envelope: {
                            attack: 0.001,
                            decay: 0.4,
                            sustain: 0.01,
                            release: 1.4,
                            attackCurve: "exponential"
                        }
                    }).toDestination();
                    drumSynth.volume.value = -10; // Reduce drum volume

                    masterGain = new Tone.Gain(0.4).toDestination();
                    synth.connect(masterGain);
                    bassSynth.connect(masterGain);
                    drumSynth.connect(masterGain);

                    // Main melody
                    const melodyNotes = [
                        "C4", "E4", "G4", "A4",
                        "G4", "E4", "C4", "F4",
                        "E4", "G4", "C5", "A4",
                        "G4", "E4", "D4", "C4"
                    ];
                    let melodyIndex = 0;
                    melodyLoop = new Tone.Loop((time) => {
                        synth.triggerAttackRelease(melodyNotes[melodyIndex % melodyNotes.length], "8n", time);
                        melodyIndex++;
                    }, "4n").start(0);

                    // Bassline
                    const bassNotes = ["C2", "C2", "F2", "F2", "G2", "G2", "C2", "C2"];
                    let bassIndex = 0;
                    bassLoop = new Tone.Loop((time) => {
                        bassSynth.triggerAttackRelease(bassNotes[bassIndex % bassNotes.length], "2n", time);
                        bassIndex++;
                    }, "2n").start(0);

                    // Simple drum beat
                    const drumPattern = [
                        ["C1"], [], ["C1"], [],
                        ["C1"], [], ["C1"], [],
                        ["C1"], [], ["C1"], [],
                        ["C1"], [], ["C1"], []
                    ]; // Kick drum on quarter notes
                    let drumIndex = 0;
                    drumLoop = new Tone.Sequence((time, note) => {
                        drumSynth.triggerAttackRelease(note, "16n", time);
                    }, drumPattern, "8n").start(0); // Every 1/8th note

                    Tone.Transport.bpm.value = 140;
                }).catch(e => console.error("Error starting Tone.js context:", e));
            }
        }

        async function toggleMusic() {
            if (Tone.context.state !== 'running') {
                await Tone.start();
            }
            initMusic(); // Ensure music components are initialized

            if (isMusicPlaying) {
                Tone.Transport.stop();
                musicToggleButton.textContent = texts[currentLanguage].toggleMusic;
                masterGain.gain.linearRampToValueAtTime(0, Tone.context.currentTime + 0.5);
            } else {
                Tone.Transport.start();
                musicToggleButton.textContent = texts[currentLanguage].toggleMusic;
                masterGain.gain.linearRampToValueAtTime(0.4, Tone.context.currentTime + 0.2);
            }
            isMusicPlaying = !isMusicPlaying;
        }

        // --- Sound effects (SFX) ---
        let hitSynth;
        let difficultyUpSynth;
        let artifactCollectSynth; // SFX for artifacts
        let skillActivateSynth; // SFX for skill
        let bossHitSynth; // SFX for boss taking damage
        let marisaSkillSynth; // SFX for Marisa's Spiral Orb
        let sakuyaSkillSynth; // SFX for Sakuya's Temporal Blink/Wind Blade
        let blasterChargeSFX; // New SFX for Phantom Blaster charge
        let blasterFireSFX; // New SFX for Phantom Blaster fire
        let lightningDashSFX; // New SFX for Marisa's Lightning Dash
        let windBladeSFX; // New SFX for Sakuya's Wind Blade Volley
        let rapidStrikeSFX; // New SFX for Youmu's Rapid Strike Flurry
        let glacialBeamSFX; // New SFX for Cirno's Glacial Beam
        let temporalStasisSFX; // New SFX for Time Manipulator's Temporal Stasis
        let fistOfFurySFX; // New SFX for Time Manipulator's Fist of Fury Barrage
        let grenadeLaunchSFX; // New SFX for Cid's Grenade Barrage
        let explosionSFX; // New SFX for grenade explosion
        let vortexSFX; // New SFX for Overlord's Abyssal Vortex
        let boneWallSFX; // New SFX for Sans' Bone Walls
        let knifeThrowSFX; // New SFX for Dio's Knife Throw


        function initSFX() {
            // Initialize only once
            if (!hitSynth) {
                Tone.start().then(() => { // Ensure context is running for SFX too
                    hitSynth = new Tone.NoiseSynth({
                        envelope: {
                            attack: 0.001,
                            decay: 0.1,
                            sustain: 0,
                            release: 0.1
                        },
                        noise: { type: 'white' }
                    }).toDestination();
                    hitSynth.volume.value = -10; // Reduce volume

                    difficultyUpSynth = new Tone.Synth({
                        oscillator: { type: 'square' },
                        envelope: { attack: 0.01, decay: 0.1, sustain: 0.0, release: 0.2 }
                    }).toDestination();
                    difficultyUpSynth.volume.value = -10; // Reduce volume

                    artifactCollectSynth = new Tone.Synth({
                        oscillator: { type: 'sine' },
                        envelope: { attack: 0.005, decay: 0.05, sustain: 0.0, release: 0.1 }
                    }).toDestination();
                    artifactCollectSynth.volume.value = -8; // Increase artifact SFX volume

                    skillActivateSynth = new Tone.PolySynth(Tone.Synth, {
                        oscillator: { type: "sawtooth" },
                        envelope: { attack: 0.01, decay: 0.05, sustain: 0.0, release: 0.2 }
                    }).toDestination();
                    skillActivateSynth.volume.value = -5;

                    bossHitSynth = new Tone.MembraneSynth({
                        pitchDecay: 0.02,
                        octaves: 5,
                        envelope: {
                            attack: 0.001,
                            decay: 0.2,
                            sustain: 0.01,
                            release: 0.5,
                            attackCurve: "exponential"
                        }
                    }).toDestination();
                    bossHitSynth.volume.value = -10;

                    marisaSkillSynth = new Tone.PolySynth(Tone.Synth, { // Now for Spiral Orb
                        oscillator: { type: "square" },
                        envelope: { attack: 0.005, decay: 0.1, sustain: 0.0, release: 0.3 }
                    }).toDestination();
                    marisaSkillSynth.volume.value = -7;

                    sakuyaSkillSynth = new Tone.PolySynth(Tone.Synth, { // Now for Temporal Blink/Wind Blade
                        oscillator: { type: "sine" },
                        envelope: { attack: 0.001, decay: 0.05, sustain: 0.0, release: 0.1 }
                    }).toDestination();
                    sakuyaSkillSynth.volume.value = -12;

                    // New SFX for Phantom Blaster
                    blasterChargeSFX = new Tone.Synth({
                        oscillator: { type: 'sawtooth' },
                        envelope: { attack: 0.01, decay: 0.5, sustain: 0.1, release: 0.2 }
                    }).toDestination();
                    blasterChargeSFX.volume.value = -15;

                    blasterFireSFX = new Tone.NoiseSynth({
                        envelope: {
                            attack: 0.001,
                            decay: 0.2,
                            sustain: 0,
                            release: 0.1
                        },
                        noise: { type: 'pink' }
                    }).toDestination();
                    blasterFireSFX.volume.value = -8;

                    lightningDashSFX = new Tone.Synth({ // For Marisa's Lightning Dash
                        oscillator: { type: 'triangle' },
                        envelope: { attack: 0.001, decay: 0.1, sustain: 0, release: 0.2 }
                    }).toDestination();
                    lightningDashSFX.volume.value = -8;

                    windBladeSFX = new Tone.PolySynth(Tone.Synth, { // For Sakuya's Wind Blade Volley
                        oscillator: { type: 'sawtooth' },
                        envelope: { attack: 0.001, decay: 0.05, sustain: 0, release: 0.1 }
                    }).toDestination();
                    windBladeSFX.volume.value = -10;

                    rapidStrikeSFX = new Tone.PolySynth(Tone.Synth, { // For Youmu's Rapid Strike Flurry
                        oscillator: { type: 'square' },
                        envelope: { attack: 0.001, decay: 0.05, sustain: 0, release: 0.1 }
                    }).toDestination();
                    rapidStrikeSFX.volume.value = -10;

                    glacialBeamSFX = new Tone.Synth({ // For Cirno's Glacial Beam
                        oscillator: { type: 'sine' },
                        envelope: { attack: 0.01, decay: 0.3, sustain: 0.1, release: 0.5 }
                    }).toDestination();
                    glacialBeamSFX.volume.value = -8;

                    temporalStasisSFX = new Tone.Synth({ // For Time Manipulator's Temporal Stasis
                        oscillator: { type: 'square' },
                        envelope: { attack: 0.001, decay: 0.5, sustain: 0.1, release: 0.8 }
                    }).toDestination();
                    temporalStasisSFX.volume.value = -10;

                    fistOfFurySFX = new Tone.PolySynth(Tone.Synth, { // For Time Manipulator's Fist of Fury Barrage
                        oscillator: { type: 'triangle' },
                        envelope: { attack: 0.001, decay: 0.02, sustain: 0, release: 0.05 }
                    }).toDestination();
                    fistOfFurySFX.volume.value = -12;

                    grenadeLaunchSFX = new Tone.Synth({ // For Cid's Grenade Launch
                        oscillator: { type: 'square' },
                        envelope: { attack: 0.01, decay: 0.1, sustain: 0, release: 0.1 }
                    }).toDestination();
                    grenadeLaunchSFX.volume.value = -10;

                    explosionSFX = new Tone.NoiseSynth({ // For Grenade Explosion
                        envelope: { attack: 0.001, decay: 0.3, sustain: 0, release: 0.2 },
                        noise: { type: 'brown' }
                    }).toDestination();
                    explosionSFX.volume.value = -8;

                    vortexSFX = new Tone.Synth({ // For Overlord's Abyssal Vortex
                        oscillator: { type: 'sawtooth' },
                        envelope: { attack: 0.5, decay: 1, sustain: 0.5, release: 1 }
                    }).toDestination();
                    vortexSFX.volume.value = -12;

                    boneWallSFX = new Tone.MembraneSynth({ // For Sans' Bone Walls
                        pitchDecay: 0.05,
                        octaves: 5,
                        envelope: { attack: 0.001, decay: 0.1, sustain: 0, release: 0.1 }
                    }).toDestination();
                    boneWallSFX.volume.value = -10;

                    knifeThrowSFX = new Tone.Synth({ // For Dio's Knife Throw
                        oscillator: { type: 'triangle' },
                        envelope: { attack: 0.001, decay: 0.05, sustain: 0, release: 0.05 }
                    }).toDestination();
                    knifeThrowSFX.volume.value = -15;

                }).catch(e => console.error("Error starting Tone.js context:", e));
            }
        }

        async function playHitSFX() {
            if (Tone.context.state !== 'running') await Tone.start();
            if (hitSynth) hitSynth.triggerAttackRelease("C3", "8n");
        }

        async function playDifficultyUpSFX() {
            if (Tone.context.state !== 'running') await Tone.start();
            if (difficultyUpSynth) {
                difficultyUpSynth.triggerAttackRelease("C5", "16n", Tone.now());
                difficultyUpSynth.triggerAttackRelease("G5", "16n", Tone.now() + 0.1);
            }
        }

        async function playArtifactCollectSFX() {
            if (Tone.context.state !== 'running') await Tone.start();
            if (artifactCollectSynth) {
                artifactCollectSynth.triggerAttackRelease("E6", "16n");
                artifactCollectSynth.triggerAttackRelease("G6", "16n", Tone.now() + 0.05);
            }
        }

        async function playSkillActivateSFX() {
            if (Tone.context.state !== 'running') await Tone.start();
            if (skillActivateSynth) skillActivateSynth.triggerAttackRelease(["C5", "E5", "G5"], "8n");
        }

        async function playBossHitSFX() {
            if (Tone.context.state !== 'running') await Tone.start();
            if (bossHitSynth) bossHitSynth.triggerAttackRelease("C2", "8n");
        }

        async function playMarisaSkillSFX() { // Now for Spiral Orb
            if (Tone.context.state !== 'running') await Tone.start();
            if (marisaSkillSynth) marisaSkillSynth.triggerAttackRelease(["C4", "E4", "G4", "C5"], "16n");
        }

        async function playSakuyaSkillSFX() { // Now for Temporal Blink/Wind Blade
            if (Tone.context.state !== 'running') await Tone.start();
            if (sakuyaSkillSynth) sakuyaSkillSynth.triggerAttackRelease(["A4", "F4", "D4"], "32n");
        }

        async function playBlasterChargeSFX() {
            if (Tone.context.state !== 'running') await Tone.start();
            if (blasterChargeSFX) blasterChargeSFX.triggerAttackRelease("C3", "1s");
        }

        async function playBlasterFireSFX() {
            if (Tone.context.state !== 'running') await Tone.start();
            if (blasterFireSFX) blasterFireSFX.triggerAttackRelease("8n");
        }

        async function playLightningDashSFX() { // For Marisa's Lightning Dash
            if (Tone.context.state !== 'running') await Tone.start();
            if (lightningDashSFX) lightningDashSFX.triggerAttackRelease("E5", "0.2s");
        }

        async function playWindBladeSFX() { // For Sakuya's Wind Blade Volley
            if (Tone.context.state !== 'running') await Tone.start();
            if (windBladeSFX) windBladeSFX.triggerAttackRelease(["D5", "F5", "A5"], "32n");
        }

        async function playRapidStrikeSFX() { // For Youmu's Rapid Strike Flurry
            if (Tone.context.state !== 'running') await Tone.start();
            if (rapidStrikeSFX) rapidStrikeSFX.triggerAttackRelease(["C4", "E4"], "64n");
        }

        async function playGlacialBeamSFX() { // For Cirno's Glacial Beam
            if (Tone.context.state !== 'running') await Tone.start();
            if (glacialBeamSFX) glacialBeamSFX.triggerAttackRelease("G3", "0.5s");
        }

        async function playTemporalStasisSFX() { // For Time Manipulator's Temporal Stasis
            if (Tone.context.state !== 'running') await Tone.start();
            if (temporalStasisSFX) temporalStasisSFX.triggerAttackRelease("C6", "0.5s");
        }

        async function playFistOfFurySFX() { // For Time Manipulator's Fist of Fury Barrage
            if (Tone.context.state !== 'running') await Tone.start();
            if (fistOfFurySFX) fistOfFurySFX.triggerAttackRelease("C4", "128n");
        }

        async function playGrenadeLaunchSFX() {
            if (Tone.context.state !== 'running') await Tone.start();
            if (grenadeLaunchSFX) grenadeLaunchSFX.triggerAttackRelease("G3", "0.1s");
        }

        async function playExplosionSFX() {
            if (Tone.context.state !== 'running') await Tone.start();
            if (explosionSFX) explosionSFX.triggerAttackRelease("0.3s");
        }

        async function playVortexSFX() {
            if (Tone.context.state !== 'running') await Tone.start();
            if (vortexSFX) vortexSFX.triggerAttackRelease("C2", "1s");
        }

        async function playBoneWallSFX() {
            if (Tone.context.state !== 'running') await Tone.start();
            if (boneWallSFX) boneWallSFX.triggerAttackRelease("C3", "0.1s");
        }

        async function playKnifeThrowSFX() {
            if (Tone.context.state !== 'running') await Tone.start();
            if (knifeThrowSFX) knifeThrowSFX.triggerAttackRelease("F5", "0.05s");
        }


        // --- Assist function ---
        function triggerAssist() {
            enemyProjectiles.length = 0; // Clear all bullets
            bulletTrails.length = 0; // Clear bullet trails
            beams.length = 0; // Clear boss attacks
            darkZones.length = 0;
            spectralSpikes.length = 0;
            phantomBlasters.length = 0;
            crushingDescents.length = 0; // Clear crushing descents
            isInvincible = true;
            let currentInvincibleDuration = INVINCIBLE_DURATION * 1.5;
            // Cirno's passive: Icy Resilience
            if (player.passive && player.passive.type === 'icyResilience') {
                currentInvincibleDuration += player.passive.shieldDuration; // Extend invincibility as a shield
            }
            invincibleTimer = currentInvincibleDuration;
            player.x = CANVAS_WIDTH / 2;
            player.y = CANVAS_HEIGHT - player.height / 2 - 30; // Move player to safe position relative to its height
            playDifficultyUpSFX(); // Play assist sound
            console.log("Assist Mode Activated!");
        }

        // --- Skill function ---
        function useSkill(skillIndex) {
            const currentTime = performance.now() / 1000; // in seconds
            const skill = player.activeSkills[skillIndex];
            if (!skill) return; // Should not happen if skillIndex is 0 or 1

            let actualSkillCooldown = skill.cooldown;
            // Marisa's passive: Arcane Flow skill cooldown reduction
            if (player.passive && player.passive.type === 'arcaneFlow') {
                actualSkillCooldown *= (1 - player.passive.value);
            }

            if ((currentTime - skill.lastUseTime) >= actualSkillCooldown && gameRunning && !gamePaused) {
                // Create particles for skill effect (general for all skills)
                for (let i = 0; i < 50; i++) {
                    createParticle(player.x, player.y, player.color);
                }

                switch (skill.id) {
                    case 'spiritualSealBurst': // Reimu Skill 1
                        enemyProjectiles.length = 0;
                        bulletTrails.length = 0;
                        beams.length = 0; // Clear boss attacks too
                        darkZones.length = 0;
                        spectralSpikes.length = 0;
                        phantomBlasters.length = 0;
                        crushingDescents.length = 0; // Clear crushing descents
                        // Add a visual burst effect
                        for (let i = 0; i < 100; i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const speed = Math.random() * 10 + 5;
                            createParticle(player.x, player.y, '#ff4500', Math.random() * 8 + 3, Math.cos(angle) * speed, Math.sin(angle) * speed, 1, 0.03, 0.9);
                        }
                        // Deal damage to nearby enemies/boss
                        enemies.forEach(enemy => {
                            const dx = player.x - enemy.x;
                            const dy = player.y - enemy.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            if (distance < skill.clearRadius) {
                                enemy.health -= skill.damage;
                            }
                        });
                        if (bossActive && boss) {
                            const dx = player.x - boss.x;
                            const dy = player.y - boss.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            if (distance < skill.clearRadius + Math.max(boss.width, boss.height) / 2) {
                                boss.health -= skill.damage * 0.5; // Less damage to boss
                            }
                        }
                        playSkillActivateSFX();
                        break;
                    case 'illusoryDuplicate': // Reimu Skill 2
                        const numClones = skill.numClones;
                        const cloneBulletSpeed = 5;
                        const cloneBulletRadius = 4;
                        const cloneColor = '#00ffff'; // Reimu's color
                        const cloneBulletDamage = skill.defaultBulletDamage; // Use skill's default bullet damage
                        playSkillActivateSFX();

                        for (let i = 0; i < numClones; i++) {
                            const cloneX = player.x + (Math.random() - 0.5) * 100;
                            const cloneY = player.y + (Math.random() - 0.5) * 50;
                            // Create a temporary "clone" that shoots
                            addTimer('interval', () => { // Use addTimer
                                if (gameRunning && !gamePaused) {
                                    const target = bossActive && boss ? boss : enemies[0];
                                    if (target) {
                                        const angleToTarget = Math.atan2(target.y - cloneY, target.x - cloneX);
                                        createBullet(cloneX, cloneY, angleToTarget, cloneBulletSpeed, cloneBulletRadius, cloneColor, playerProjectiles, false, 0, false, 'illusoryCloneBullet', null, cloneBulletDamage);
                                    }
                                }
                            }, 500); // Shoot every 0.5 seconds
                        }
                        // Clones will disappear after skill.duration
                        addTimer('timeout', () => {
                            // Logic to remove clones or stop their shooting (if implemented as actual objects)
                            // This implementation assumes the clones are just temporary shooting effects.
                        }, skill.duration * 1000);
                        break;
                    case 'spiralOrbBarrage': // Marisa Skill 1
                        playMarisaSkillSFX();
                        createBullet(player.x, player.y, -Math.PI / 2, skill.speed, skill.radius, '#0000ff', playerProjectiles, false, 0, skill.piercing, 'spiralOrb', null, skill.damage);
                        break;
                    case 'lightningDash': // Marisa Skill 2
                        playLightningDashSFX();
                        const dashTargetY = player.y - 200; // Dash upwards
                        const originalPlayerSpeed = player.speed;
                        player.speed = skill.dashSpeed; // Temporarily increase speed for dash
                        isInvincible = true;
                        invincibleTimer = skill.invincibilityDuringDash;
                        player.isDashing = true; // Set dashing flag

                        // Store the interval ID for cleanup
                        let lightningDashIntervalId = addTimer('interval', () => { // Use addTimer
                            if (player.y > dashTargetY && gameRunning && !gamePaused && !playerMovementFrozen) { // Check playerMovementFrozen
                                player.y -= player.speed * (1/60); // Move frame by frame
                                // Clear bullets during dash and damage enemies
                                for (let i = enemyProjectiles.length - 1; i >= 0; i--) {
                                    const bullet = enemyProjectiles[i];
                                    const dx = player.x - bullet.x;
                                    const dy = player.y - bullet.y;
                                    const distance = Math.sqrt(dx * dx + dy * dy);
                                    if (distance < 50) { // Clear bullets in a small radius
                                        enemyProjectiles.splice(i, 1);
                                    }
                                }
                                enemies.forEach(enemy => {
                                    const dx = player.x - enemy.x;
                                    const dy = player.y - enemy.y;
                                    const distance = Math.sqrt(dx * dx + dy * dy);
                                    if (distance < player.width / 2 + enemy.width / 2) { // Collision with enemy
                                        enemy.health -= skill.damagePerSecond * (1/60); // Continuous damage during dash
                                    }
                                });
                                if (bossActive && boss) {
                                    const dx = player.x - boss.x;
                                    const dy = player.y - boss.y;
                                    const distance = Math.sqrt(dx * dx + dy * dy);
                                    if (distance < player.width / 2 + boss.width / 2) {
                                        boss.health -= skill.damagePerSecond * 0.5 * (1/60); // Continuous damage to boss
                                    }
                                }
                                // Add dash particles/afterimage
                                createParticle(player.x + (Math.random() - 0.5) * 10, player.y + (Math.random() - 0.5) * 10, player.color, Math.random() * 3 + 1, (Math.random() - 0.5) * 5, (Math.random() - 0.5) * 5, 0.5, 0.05, 0.9);
                            } else {
                                clearSpecificTimer(lightningDashIntervalId); // Clear this specific interval
                                player.speed = originalPlayerSpeed; // Revert speed
                                player.isDashing = false; // Reset dashing flag when dash ends
                            }
                        }, 1000 / 60); // 60 FPS update

                        addTimer('timeout', () => { // Use addTimer
                            isInvincible = false;
                        }, skill.invincibilityDuringDash * 1000);
                        break;
                    case 'temporalBlink': // Sakuya Skill 1
                        playSakuyaSkillSFX();
                        const dashAngle = -Math.PI / 2; // Always dash upwards for now
                        player.x += Math.cos(dashAngle) * skill.dashDistance;
                        player.y += Math.sin(dashAngle) * skill.dashDistance;
                        player.x = Math.max(player.width / 2, Math.min(CANVAS_WIDTH - player.width / 2, player.x));
                        player.y = Math.max(player.height / 2, Math.min(CANVAS_HEIGHT - player.height / 2, player.y));
                        isInvincible = true;
                        invincibleTimer = skill.invincibilityDuration;
                        break;
                    case 'windBladeVolley': // Sakuya Skill 2
                        playWindBladeSFX();
                        const numWindBlades = skill.numProjectiles;
                        const windBladeSpeed = skill.speed;
                        const windBladeRadius = skill.radius;
                        const windBladeColor = '#87ceeb'; // Light blue for air blades

                        for (let i = 0; i < numWindBlades; i++) {
                            const angle = -Math.PI / 2 + (i - (numWindBlades - 1) / 2) * (Math.PI / 6); // Cone spread
                            createBullet(player.x, player.y, angle, windBladeSpeed, windBladeRadius, windBladeColor, playerProjectiles, false, 0, false, 'windBlade', null, skill.damage);
                        }
                        break;
                    case 'overdrivePulse': // Youmu Skill 1
                        playSkillActivateSFX(); // General skill activate for Youmu
                        const originalYoumuSpeed = player.speed;
                        const originalYoumuBulletSlowActive = bulletSlowEffectActive;
                        const originalYoumuBulletSlowTimer = bulletSlowTimer;

                        player.speed *= skill.speedMultiplier;
                        bulletSlowEffectActive = true;
                        bulletSlowTimer = skill.duration;

                        addTimer('timeout', () => {
                            player.speed = originalYoumuSpeed;
                            bulletSlowEffectActive = originalYoumuBulletSlowActive;
                            bulletSlowTimer = originalYoumuBulletSlowTimer;
                        }, skill.duration * 1000);
                        break;
                    case 'rapidStrikeFlurry': // Youmu Skill 2
                        playRapidStrikeSFX();
                        const numRapidStrikes = skill.numProjectiles;
                        const rapidStrikeSpeed = skill.speed;
                        const rapidStrikeRadius = skill.radius;
                        const rapidStrikeColor = '#ff0000'; // Red for strikes

                        for (let i = 0; i < numRapidStrikes; i++) {
                            const angle = -Math.PI / 2 + (i - (numRapidStrikes - 1) / 2) * (Math.PI / 4); // Wide cone
                            addTimer('timeout', () => {
                                createBullet(player.x, player.y, angle, rapidStrikeSpeed, rapidStrikeRadius, rapidStrikeColor, playerProjectiles, false, 0, false, 'strikeProjectile', null, skill.damage);
                            }, i * 30); // Very rapid fire
                        }
                        break;
                    case 'absoluteZeroForm': // Cirno Skill 1
                        playSkillActivateSFX(); // General skill activate for Cirno
                        isInvincible = true;
                        invincibleTimer = skill.invincibilityDuration;
                        player.damageBoostActive = true; // Activate damage boost
                        // Clear all bullets and boss attacks
                        enemyProjectiles.length = 0;
                        bulletTrails.length = 0;
                        beams.length = 0;
                        darkZones.length = 0;
                        spectralSpikes.length = 0;
                        phantomBlasters.length = 0;
                        crushingDescents.length = 0;

                        // Visual effect for Absolute Zero Form
                        for (let i = 0; i < 150; i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const speed = Math.random() * 15 + 5;
                            createParticle(player.x, player.y, '#ffffff', Math.random() * 10 + 5, Math.cos(angle) * speed, Math.sin(angle) * speed, 1, 0.02, 0.9);
                        }

                        addTimer('timeout', () => {
                            player.damageBoostActive = false; // Deactivate damage boost
                        }, skill.duration * 1000);
                        break;
                    case 'glacialBeam': // Cirno Skill 2
                        playGlacialBeamSFX();
                        const glacialBeamSpeed = skill.speed;
                        const glacialBeamWidth = skill.width;
                        const glacialBeamLength = skill.length;
                        const glacialBeamDamagePerSecond = skill.damagePerSecond; // Damage per second
                        const glacialBeamColor = '#00e0ff'; // Brighter blue for Glacial Beam

                        // Create a temporary beam that moves with the player
                        const glacialBeam = {
                            startX: player.x,
                            startY: player.y,
                            endX: player.x,
                            endY: player.y - glacialBeamLength,
                            width: glacialBeamWidth,
                            color: glacialBeamColor,
                            activeTimer: 1.0, // Glacial Beam fires for a short duration
                            maxActive: 1.0,
                            state: 'active',
                            isPlayerSpark: true, // Custom property to identify
                            damagePerSecond: glacialBeamDamagePerSecond, // Damage per second
                            piercing: skill.piercing
                        };
                        beams.push(glacialBeam);
                        break;
                    case 'chronosPierce': // Sakuya Skill 1
                        playSkillActivateSFX(); // General skill activate for Sakuya
                        const originalSakuyaSpeed = player.speed;
                        const originalSakuyaBulletSlowActive = bulletSlowEffectActive;
                        const originalSakuyaBulletSlowTimer = bulletSlowTimer;

                        player.speed *= skill.speedMultiplier;
                        bulletSlowEffectActive = true;
                        bulletSlowTimer = skill.duration;

                        addTimer('timeout', () => {
                            player.speed = originalSakuyaSpeed;
                            bulletSlowEffectActive = originalSakuyaBulletSlowActive;
                            bulletSlowTimer = originalSakuyaBulletSlowTimer;
                        }, skill.duration * 1000);
                        break;
                    case 'absoluteFreeze': // Sakuya Skill 2
                        playSkillActivateSFX(); // General skill activate for Sakuya
                        isInvincible = true;
                        invincibleTimer = skill.freezeDuration;
                        player.damageBoostActive = true; // Activate damage boost
                        // Clear all bullets and boss attacks
                        enemyProjectiles.length = 0;
                        bulletTrails.length = 0;
                        beams.length = 0;
                        darkZones.length = 0;
                        spectralSpikes.length = 0;
                        phantomBlasters.length = 0;
                        crushingDescents.length = 0;

                        // Visual effect for Absolute Freeze
                        for (let i = 0; i < 150; i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const speed = Math.random() * 15 + 5;
                            createParticle(player.x, player.y, '#ffffff', Math.random() * 10 + 5, Math.cos(angle) * speed, Math.sin(angle) * speed, 1, 0.02, 0.9);
                        }

                        addTimer('timeout', () => {
                            player.damageBoostActive = false; // Deactivate damage boost
                        }, skill.freezeDuration * 1000);
                        break;
                }

                skill.lastUseTime = currentTime; // Set last use time for cooldown
                updateSkillButtonState();
            }
        }

        function updateSkillButtonState() {
            const currentTime = performance.now() / 1000;
            
            player.activeSkills.forEach((skill, index) => {
                let actualSkillCooldown = skill.cooldown;
                if (player.passive && player.passive.type === 'arcaneFlow') {
                    actualSkillCooldown *= (1 - player.passive.value);
                }

                const timeSinceLastUse = currentTime - skill.lastUseTime;
                const button = index === 0 ? skill1Button : skill2Button;
                
                if (timeSinceLastUse < actualSkillCooldown) {
                    button.disabled = true;
                    const timeLeft = Math.ceil(actualSkillCooldown - timeSinceLastUse);
                    button.textContent = `${texts[currentLanguage][`skill${index + 1}`]}: (${timeLeft}s)`;
                } else {
                    button.disabled = false;
                    button.textContent = `${texts[currentLanguage][`skill${index + 1}`]}: ∞`;
                }
                // Disable if player skills are frozen by boss
                if (playerSkillsFrozen) {
                    button.disabled = true;
                    button.textContent = `${texts[currentLanguage][`skill${index + 1}`]}: --`; // Indicate frozen
                }
            });
            
            // Schedule next update to show countdown if any skill is on cooldown
            if (player.activeSkills.some(skill => (currentTime - skill.lastUseTime) < (player.passive && player.passive.type === 'arcaneFlow' ? skill.cooldown * (1 - player.passive.value) : skill.cooldown)) && !playerSkillsFrozen) {
                addTimer('timeout', updateSkillButtonState, 1000); // Use addTimer
            }
        }


        // --- Pause/Resume game function ---
        function togglePause() {
            if (!gameRunning) return;

            gamePaused = !gamePaused;
            if (gamePaused) {
                pauseButton.textContent = texts[currentLanguage].resume;
                pausedOverlay.style.display = 'flex';
                if (isMusicPlaying) {
                    Tone.Transport.pause();
                    masterGain.gain.linearRampToValueAtTime(0, Tone.context.currentTime + 0.5);
                }
            } else {
                pauseButton.textContent = texts[currentLanguage].pause;
                pausedOverlay.style.display = 'none';
                lastFrameTime = performance.now();
                if (isMusicPlaying) {
                    Tone.Transport.start();
                    masterGain.gain.linearRampToValueAtTime(0.4, Tone.context.currentTime + 0.2);
                }
                requestAnimationFrame(gameLoop);
            }
        }

        // --- Main game loop ---
        function gameLoop(currentTime) {
            if (!gameRunning || gamePaused) return;

            const deltaTime = (currentTime - lastFrameTime) / 1000;
            lastFrameTime = currentTime;

            score = Math.floor((currentTime - startTime) / 1000);
            scoreDisplay.textContent = `${texts[currentLanguage].score}: ${score}`;

            // Handle Youmu's Overdrive Pulse effect (bullet slow)
            if (bulletSlowEffectActive) {
                bulletSlowTimer -= deltaTime;
                if (bulletSlowTimer <= 0) {
                    bulletSlowEffectActive = false;
                }
            }

            // Check for boss spawn
            if (!bossActive && score >= BOSS_SPAWN_SCORE) {
                createBoss();
            }

            // Update difficulty or boss
            if (!bossActive) {
                difficultyTimer += deltaTime;
                const difficultyIncreaseInterval = 4;
                if (difficultyTimer >= difficultyIncreaseInterval) {
                    difficultyLevel++;
                    difficultyTimer = 0;
                    difficultyDisplay.textContent = `${texts[currentLanguage].difficulty}: ${difficultyLevel}`;
                    playDifficultyUpSFX(); // Play SFX when difficulty increases
                }

                // Sửa đoạn random enemyType khi spawn enemy
                if (enemies.length < MAX_ENEMIES_ON_SCREEN) {
                    const enemyTypesArray = Object.keys(enemyTypes); // Lấy đúng các key hiện tại
                    const randomEnemyType = enemyTypesArray[Math.floor(Math.random() * enemyTypesArray.length)];
                    createEnemy(randomEnemyType);
                }
            } else {
                updateBoss(deltaTime);
                updateBossHealthBar();
            }


            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            updatePlayer(deltaTime);
            drawPlayer();

            // Update and draw regular enemy projectiles
            updateEnemyProjectiles(deltaTime); // Pass deltaTime to update bullet speed based on boss time stop
            enemyProjectiles.forEach(drawBullet);

            // Update and draw player skill projectiles
            updatePlayerProjectiles();
            playerProjectiles.forEach(drawBullet);

            updateArtifacts(deltaTime);
            artifacts.forEach(drawArtifact);

            updateParticles(deltaTime); // Update particles
            drawParticles(); // Draw particles

            if (!bossActive) { // Only draw regular enemies if boss is not active
                updateEnemies(deltaTime); // Update enemy positions/logic
                enemies.forEach(enemy => {
                    drawEnemy(enemy);
                });
                // Create artifact only if boss is not active
                if (score >= nextArtifactScore) {
                    createArtifact();
                    nextArtifactScore += ARTIFACT_SPAWN_INTERVAL;
                }
            } else { // Draw boss and its unique attacks if active
                drawBoss(boss);
                // Update and draw boss-specific attacks
                updateBeams(deltaTime);
                beams.forEach(drawBeam);

                updateDarkZones(deltaTime);
                darkZones.forEach(drawDarkZone);

                updateSpectralSpikes(deltaTime);
                spectralSpikes.forEach(drawSpectralSpike);

                updatePhantomBlasters(deltaTime);
                phantomBlasters.forEach(blaster => {
                    drawPhantomBlaster(blaster);
                    // Play SFX for Phantom Blaster
                    if (blaster.state === 'charging' && blaster.chargeTimer > 0.05 && blaster.chargeTimer <= blaster.maxCharge - 0.05) { // Play once at start of charge
                        playBlasterChargeSFX();
                    } else if (blaster.state === 'firing' && blaster.fireTimer > 0.05 && blaster.fireTimer <= blaster.maxFire - 0.05) { // Play once at start of fire
                        playBlasterFireSFX();
                    }
                });

                updateCrushingDescents(deltaTime);
                crushingDescents.forEach(drawCrushingDescent);
            }

            // --- Collision checks ---

            // Player-enemyProjectile collision (using player's hitboxRadius)
            if (!isInvincible) {
                for (let i = enemyProjectiles.length - 1; i >= 0; i--) { // Iterate backwards for safe removal
                    const bullet = enemyProjectiles[i];
                    if (checkCollision({ x: player.x, y: player.y, radius: player.hitboxRadius }, bullet)) {
                        
                        // Sakuya's passive: Evasive Insight
                        if (player.passive && player.passive.type === 'evasiveInsight' && Math.random() < player.passive.chance) {
                            bulletSlowEffectActive = true;
                            bulletSlowTimer = player.passive.duration;
                            // Clear bullets in radius
                            for (let j = enemyProjectiles.length - 1; j >= 0; j--) { // Iterate backwards for safe removal
                                const b = enemyProjectiles[j];
                                const dx = player.x - b.x;
                                const dy = player.y - b.y;
                                const distance = Math.sqrt(dx * dx + dy * dy);
                                if (distance < player.passive.radius) {
                                    enemyProjectiles.splice(j, 1);
                                }
                            }
                            bulletTrails.length = 0; // Clear trails too
                            playSakuyaSkillSFX(); // Use Sakuya's skill SFX for dodge slow
                            enemyProjectiles.splice(i, 1); // Remove the bullet that was "dodged"
                            continue; // Skip damage and revive logic
                        }

                        // Youmu's passive: Resilient Spirit invincibility on hit
                        if (player.passive && player.passive.type === 'resilientSpirit' && Math.random() < player.passive.chance) {
                            isInvincible = true;
                            invincibleTimer = player.passive.duration;
                            playDifficultyUpSFX(); // Play a sound indicating invincibility
                            enemyProjectiles.splice(i, 1); // Remove the bullet that hit
                            continue; // Skip damage and revive logic
                        }


                        playHitSFX(); // Play SFX when hit

                        // Check assist conditions
                        deathCount++;
                        if (deathCount >= ASSIST_DEATH_THRESHOLD && (score - scoreAtLastDeath < ASSIST_SCORE_THRESHOLD)) {
                             triggerAssist();
                             deathCount = 0; // Reset death counter after assist
                             scoreAtLastDeath = score; // Update score at assist
                        } else if (revivesLeft > 0) {
                            revivesLeft--;
                            revivesDisplay.textContent = `${texts[currentLanguage].revives}: ${revivesLeft}`;
                            isInvincible = true;
                            let currentInvincibleDuration = INVINCIBLE_DURATION;
                            // Cirno's passive: Icy Resilience
                            if (player.passive && player.passive.type === 'icyResilience') {
                                currentInvincibleDuration += player.passive.shieldDuration; // Extend invincibility as a shield
                            }
                            invincibleTimer = currentInvincibleDuration;
                            player.x = CANVAS_WIDTH / 2;
                            player.y = CANVAS_HEIGHT - player.height / 2 - 30; // Move player to safe position
                            enemyProjectiles.length = 0; // Clear all bullets on screen
                            bulletTrails.length = 0; // Clear bullet trails
                            beams.length = 0; // Clear all boss attacks
                            darkZones.length = 0;
                            spectralSpikes.length = 0;
                            phantomBlasters.length = 0;
                            crushingDescents.length = 0; // Clear crushing descents
                            enemyProjectiles.length = 0;
                            bulletTrails.length = 0;
                            scoreAtLastDeath = score; // Update score at revive
                        } else {
                            gameOver();
                            return;
                        }
                        enemyProjectiles.splice(i, 1); // Remove the bullet that hit the player
                        break; // Exit loop to avoid multiple collisions
                    }
                }

                // Player-Beam collision (Shadow Weaver)
                for (let i = beams.length - 1; i >= 0; i--) {
                    const beam = beams[i];
                    if (checkBeamCollision(player, beam)) {
                        playHitSFX();
                        if (revivesLeft > 0) {
                            revivesLeft--;
                            revivesDisplay.textContent = `${texts[currentLanguage].revives}: ${revivesLeft}`;
                            isInvincible = true;
                            let currentInvincibleDuration = INVINCIBLE_DURATION;
                            if (player.passive && player.passive.type === 'icyResilience') {
                                currentInvincibleDuration += player.passive.shieldDuration;
                            }
                            invincibleTimer = currentInvincibleDuration;
                            player.x = CANVAS_WIDTH / 2;
                            player.y = CANVAS_HEIGHT - player.height / 2 - 30;
                            // Clear all boss attacks on screen for a moment of relief
                            beams.length = 0;
                            darkZones.length = 0;
                            spectralSpikes.length = 0;
                            phantomBlasters.length = 0;
                            crushingDescents.length = 0; // Clear crushing descents
                            enemyProjectiles.length = 0;
                            bulletTrails.length = 0;
                        } else {
                            gameOver();
                            return;
                        }
                        // Beams are not removed on hit, they fade naturally
                        break;
                    }
                }

                // Player-DarkZone collision (Lich Overlord)
                for (let i = darkZones.length - 1; i >= 0; i--) {
                    const zone = darkZones[i];
                    if (zone.state === 'active' && checkDarkZoneCollision(player, zone)) {
                        playHitSFX();
                        if (revivesLeft > 0) {
                            revivesLeft--;
                            revivesDisplay.textContent = `${texts[currentLanguage].revives}: ${revivesLeft}`;
                            isInvincible = true;
                            let currentInvincibleDuration = INVINCIBLE_DURATION;
                            if (player.passive && player.passive.type === 'icyResilience') {
                                currentInvincibleDuration += player.passive.shieldDuration;
                            }
                            invincibleTimer = currentInvincibleDuration;
                            player.x = CANVAS_WIDTH / 2;
                            player.y = CANVAS_HEIGHT - player.height / 2 - 30;
                            // Clear all boss attacks on screen for a moment of relief
                            beams.length = 0;
                            darkZones.length = 0;
                            spectralSpikes.length = 0;
                            phantomBlasters.length = 0;
                            crushingDescents.length = 0; // Clear crushing descents
                            enemyProjectiles.length = 0;
                            bulletTrails.length = 0;
                        } else {
                            gameOver();
                            return;
                        }
                        darkZones.splice(i, 1); // Remove active zone on hit
                        break;
                    }
                }

                // Player-SpectralSpike collision (Spirit of Retribution)
                for (let i = spectralSpikes.length - 1; i >= 0; i--) {
                    const spike = spectralSpikes[i];
                    if (checkSpectralSpikeCollision(player, spike)) {
                        playHitSFX();
                        if (revivesLeft > 0) {
                            revivesLeft--;
                            revivesDisplay.textContent = `${texts[currentLanguage].revives}: ${revivesLeft}`;
                            isInvincible = true;
                            let currentInvincibleDuration = INVINCIBLE_DURATION;
                            if (player.passive && player.passive.type === 'icyResilience') {
                                currentInvincibleDuration += player.passive.shieldDuration;
                            }
                            invincibleTimer = currentInvincibleDuration;
                            player.x = CANVAS_WIDTH / 2;
                            player.y = CANVAS_HEIGHT - player.height / 2 - 30;
                            // Clear all boss attacks on screen for a moment of relief
                            beams.length = 0;
                            darkZones.length = 0;
                            spectralSpikes.length = 0;
                            phantomBlasters.length = 0;
                            crushingDescents.length = 0; // Clear crushing descents
                            enemyProjectiles.length = 0;
                            bulletTrails.length = 0;
                        } else {
                            gameOver();
                            return;
                        }
                        // Spikes are not removed on hit, they move naturally
                        break;
                    }
                }

                // Player-PhantomBlaster collision (Spirit of Retribution)
                for (let i = phantomBlasters.length - 1; i >= 0; i--) {
                    const blaster = phantomBlasters[i];
                    if (checkPhantomBlasterCollision(player, blaster)) {
                        playHitSFX();
                        if (revivesLeft > 0) {
                            revivesLeft--;
                            revivesDisplay.textContent = `${texts[currentLanguage].revives}: ${revivesLeft}`;
                            isInvincible = true;
                            let currentInvincibleDuration = INVINCIBLE_DURATION;
                            if (player.passive && player.passive.type === 'icyResilience') {
                                currentInvincibleDuration += player.passive.shieldDuration;
                            }
                            invincibleTimer = currentInvincibleDuration;
                            player.x = CANVAS_WIDTH / 2;
                            player.y = CANVAS_HEIGHT - player.height / 2 - 30;
                            // Clear all boss attacks on screen for a moment of relief
                            beams.length = 0;
                            darkZones.length = 0;
                            spectralSpikes.length = 0;
                            phantomBlasters.length = 0;
                            crushingDescents.length = 0; // Clear crushing descents
                            enemyProjectiles.length = 0;
                            bulletTrails.length = 0;
                        } else {
                            gameOver();
                            return;
                        }
                        // Blasters are not removed on hit, they fire and fade
                        break;
                    }
                }

                // Player-CrushingDescent collision (Time Manipulator)
                for (let i = crushingDescents.length - 1; i >= 0; i--) {
                    const roller = crushingDescents[i];
                    if (checkCrushingDescentCollision(player, roller)) {
                        playHitSFX();
                        if (revivesLeft > 0) {
                            revivesLeft--;
                            revivesDisplay.textContent = `${texts[currentLanguage].revives}: ${revivesLeft}`;
                            isInvincible = true;
                            let currentInvincibleDuration = INVINCIBLE_DURATION;
                            if (player.passive && player.passive.type === 'icyResilience') {
                                currentInvincibleDuration += player.passive.shieldDuration;
                            }
                            invincibleTimer = currentInvincibleDuration;
                            player.x = CANVAS_WIDTH / 2;
                            player.y = CANVAS_HEIGHT - player.height / 2 - 30;
                            // Clear all boss attacks on screen for a moment of relief
                            beams.length = 0;
                            darkZones.length = 0;
                            spectralSpikes.length = 0;
                            phantomBlasters.length = 0;
                            crushingDescents.length = 0;
                            enemyProjectiles.length = 0;
                            bulletTrails.length = 0;
                        } else {
                            gameOver();
                            return;
                        }
                        crushingDescents.splice(i, 1); // Remove crushing descent on hit
                        break;
                    }
                }
            }

            // Player skill bullets hitting enemies/boss
            for (let i = playerProjectiles.length - 1; i >= 0; i--) {
                const bullet = playerProjectiles[i];
                let hitSomething = false;
                let damageMultiplier = player.damageBoostActive ? (1 + playerCharacters[currentPlayerType].activeSkills[0].damageBoost) : 1; // For Cirno's Absolute Zero Form

                if (bossActive && boss) {
                    // Check collision with boss
                    const dx = bullet.x - boss.x;
                    const dy = bullet.y - boss.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance < bullet.radius + Math.max(boss.width, boss.height) / 2) {
                        let damage = bullet.damage || 5; // Default player bullet damage reduced
                        
                        boss.health -= damage * damageMultiplier; // Player bullet deals more damage to boss
                        playBossHitSFX();
                        hitSomething = true;
                    }
                } else {
                    // Check collision with regular enemies
                    for (let j = enemies.length - 1; j >= 0; j--) { // Iterate backwards for safe removal
                        const enemy = enemies[j];
                        // Check collision between player bullet and enemy
                        const dx = bullet.x - enemy.x;
                        const dy = enemy.y - bullet.y; // Bullet is moving upwards, enemy is above
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        if (distance < bullet.radius + Math.max(enemy.width, enemy.height) / 2) {
                            let damage = bullet.damage || 5; // Default player bullet damage reduced

                            enemy.health -= damage * damageMultiplier; // Player bullet deals more damage to enemy
                            playBossHitSFX(); // Use boss hit SFX for enemy hit
                            hitSomething = true;
                            if (!bullet.piercing) { // If not piercing, remove bullet and break
                                playerProjectiles.splice(i, 1);
                                break;
                            }
                        }
                    }
                }
                if (hitSomething && !bullet.piercing) {
                    playerProjectiles.splice(i, 1); // Remove bullet if it hit and is not piercing
                }
            }

            // Marisa's Lightning Dash damage to enemies/boss during dash
            if (player.isDashing) {
                const lightningDashDamagePerSecond = playerCharacters.marisa.activeSkills[1].damagePerSecond;
                for (let i = enemies.length - 1; i >= 0; i--) {
                    const enemy = enemies[i];
                    const pLeft = player.x - player.width / 2;
                    const pRight = player.x + player.width / 2;
                    const pTop = player.y - player.height / 2;
                    const pBottom = player.y + player.height / 2;

                    const eLeft = enemy.x - enemy.width / 2;
                    const eRight = enemy.x + enemy.width / 2;
                    const eTop = enemy.y - enemy.height / 2;
                    const eBottom = enemy.y + enemy.height / 2;

                    if (pLeft < eRight && pRight > eLeft && pTop < eBottom && pBottom > eTop) {
                        enemy.health -= lightningDashDamagePerSecond * deltaTime; // Continuous damage
                        playBossHitSFX();
                    }
                }
                if (bossActive && boss) {
                    const pLeft = player.x - player.width / 2;
                    const pRight = player.x + player.width / 2;
                    const pTop = player.y - player.height / 2;
                    const pBottom = player.y + player.height / 2;

                    const bLeft = boss.x - boss.width / 2;
                    const bRight = boss.x + boss.width / 2;
                    const bTop = boss.y - boss.height / 2;
                    const bBottom = boss.y + boss.height / 2;

                    if (pLeft < bRight && pRight > bLeft && pTop < bBottom && pBottom > bTop) {
                        boss.health -= lightningDashDamagePerSecond * 0.5 * deltaTime; // Continuous damage to boss
                        playBossHitSFX();
                    }
                }
            }

            // Cirno's Glacial Beam damage to enemies/boss
            for (let i = beams.length - 1; i >= 0; i--) {
                const beam = beams[i];
                if (beam.isPlayerSpark && beam.state === 'active') {
                    const glacialBeamDamagePerSecond = beam.damagePerSecond;
                    // Check collision with regular enemies
                    for (let j = enemies.length - 1; j >= 0; j--) {
                        const enemy = enemies[j];
                        if (checkBeamCollision(enemy, beam)) { // Check if enemy is in the beam path
                            enemy.health -= glacialBeamDamagePerSecond * deltaTime;
                            playBossHitSFX();
                        }
                    }
                    // Check collision with boss
                    if (bossActive && boss) {
                        if (checkBeamCollision(boss, beam)) { // Check if boss is in the beam path
                            boss.health -= glacialBeamDamagePerSecond * deltaTime;
                            playBossHitSFX();
                        }
                    }
                }
            }


            // Player-artifact collision
            for (let i = artifacts.length - 1; i >= 0; i--) {
                const artifact = artifacts[i];
                // For artifact collision, use the player's full visual bounds for easier collection
                // (Simple rectangle-circle check or approximate with player's width/height)
                const dx = player.x - artifact.x;
                const dy = player.y - artifact.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance < (Math.max(player.width, player.height)/2 + artifact.radius)) { // Check collision with player's bounding box
                    playArtifactCollectSFX(); // Play SFX when collecting artifact
                    // Activate artifact effect
                    if (artifact.type === 0) { // Slow
                        // Apply slow to enemy projectiles
                        enemyProjectiles.forEach(b => b.speed *= 0.6); 
                        // Apply slow to spectralSpikes
                        spectralSpikes.forEach(b => { b.vx *= 0.6; b.vy *= 0.6; });
                        // Apply slow to Phantom Blaster charge/fire timers
                        phantomBlasters.forEach(gb => {
                            gb.chargeTimer *= 0.6;
                            gb.fireTimer *= 0.6;
                        });
                        // Apply slow to Crushing Descents
                        crushingDescents.forEach(rr => rr.vy *= 0.6);

                        addTimer('timeout', () => { // Use addTimer
                            enemyProjectiles.forEach(b => b.speed /= 0.6); 
                            spectralSpikes.forEach(b => { b.vx /= 0.6; b.vy /= 0.6; });
                            phantomBlasters.forEach(gb => {
                                gb.chargeTimer /= 0.6;
                                gb.fireTimer /= 0.6;
                            });
                            crushingDescents.forEach(rr => rr.vy /= 0.6);
                        }, 3000); // Lasts 3 seconds
                    } else if (artifact.type === 1) { // Speed
                        player.speed *= 1.5; // Increase player speed
                        addTimer('timeout', () => { // Use addTimer
                            player.speed /= 1.5; // Revert to original speed
                        }, 3000); // Lasts 3 seconds
                    } else if (artifact.type === 2) { // Clear
                        enemyProjectiles.length = 0; // Clear all bullets on screen
                        bulletTrails.length = 0;
                        beams.length = 0; // Clear beams
                        darkZones.length = 0; // Clear dark zones
                        spectralSpikes.length = 0; // Clear spikes
                        phantomBlasters.length = 0; // Clear blasters
                        crushingDescents.length = 0; // Clear crushing descents
                    }
                    artifacts.splice(i, 1); // Remove collected artifact
                }
            }

            updateSkillButtonState(); // Update skill button state continuously

            requestAnimationFrame(gameLoop);
        }

        // --- Character Selection Logic ---
        characterButtons.forEach(button => {
            button.addEventListener('click', () => {
                // Remove 'selected' class from all buttons
                characterButtons.forEach(btn => btn.classList.remove('selected'));
                // Add 'selected' class to the clicked button
                button.classList.add('selected');
                currentPlayerType = button.dataset.character;
                updateCharacterDescription(currentPlayerType); // Update description on selection
                console.log(`Selected character: ${currentPlayerType}`);
            });
        });

        // Function to update character description
        function updateCharacterDescription(characterType) {
            const charData = playerCharacters[characterType];
            const t = texts[currentLanguage];
            let desc = charData.description[currentLanguage];

            // Append specific skill descriptions for clarity
            desc += `<br><br><b>${t.activeSkills}:</b><br>`;
            charData.activeSkills.forEach((skill, index) => {
                desc += `- ${t[`skill${index + 1}`]}: ${skill.description[currentLanguage]} (CD: ${skill.cooldown}s)<br>`;
            });
            desc += `<br><b>${t.passiveSkill}:</b> ${charData.passive.description[currentLanguage]}`;

            characterDescription.innerHTML = desc;
        }

        // Set default selected character (Reimu) and its description
        document.querySelector('.character-button[data-character="reimu"]').classList.add('selected');


        // --- Language Translation ---
        const texts = {
            en: {
                gameTitle: "Touhou Bullet Dodge Game",
                startScreenTitle: "TOUHOU BULLET DODGE GAME",
                startScreenStory: "You are a fragment of forgotten magic, awakened in a chaotic realm. Dodge the relentless magical distortions and face the source of the chaos to bring temporary peace. Survive as long as you can! As you delve deeper, you sense a formidable presence, the source of these distortions, awaiting your challenge. After defeating the initial manifestations, a deeper, more ancient evil stirs, threatening to engulf all. Your journey is far from over...",
                characterSelectionTitle: "Select Your Character:",
                reimu: "Reimu (Balanced)",
                marisa: "Marisa (Fast)",
                sakuya: "Sakuya (Precise)",
                youmu: "Youmu (Swift)",
                cirno: "Cirno (Resilient)",
                gojo: "Gojo (Ultimate)",
                startButton: "Start Game",
                gameOverTitle: "GAME OVER!",
                gameOverScoreText: "You survived for ",
                playAgain: "Play Again",
                home: "Home",
                gameWinTitle: "VICTORY!",
                gameWinText: "You have defeated the Boss and brought temporary peace to the realm! However, the true source of chaos remains elusive, hinting at future challenges...",
                finalScore: "Final Score: ",
                pausedTitle: "PAUSED",
                pausedHint: "Press ESC or \"Resume\" button to continue",
                pause: "Pause",
                resume: "Resume",
                toggleMusic: "Toggle Music",
                score: "Score",
                difficulty: "Difficulty",
                revives: "Revives",
                skill1: "Skill 1",
                skill2: "Skill 2",
                bossHealth: "BOSS HEALTH",
                bossPhase: "BOSS PHASE",
                activeSkills: "Active Skills",
                passiveSkill: "Passive Skill",
                enemyInspirations: "Enemy Inspirations"
            },
            vi: {
                gameTitle: "Trò chơi Touhou: Né đạn",
                startScreenTitle: "TRÒ CHƠI TOUHOU: NÉ ĐẠN",
                startScreenStory: "Bạn là một mảnh vỡ của ma thuật bị lãng quên, thức tỉnh trong một vương quốc hỗn loạn. Né tránh những biến dạng ma thuật không ngừng và đối mặt với nguồn gốc của sự hỗn loạn để mang lại hòa bình tạm thời. Sống sót càng lâu càng tốt! Khi bạn đi sâu hơn, bạn cảm nhận một sự hiện diện đáng gờm, nguồn gốc của những biến dạng này, đang chờ đợi thử thách của bạn. Sau khi đánh bại những biểu hiện ban đầu, một thế lực tà ác sâu xa, cổ xưa hơn đang trỗi dậy, đe dọa nhấn chìm tất cả. Cuộc hành trình của bạn còn lâu mới kết thúc...",
                characterSelectionTitle: "Chọn nhân vật của bạn:",
                reimu: "Reimu (Cân bằng)",
                marisa: "Marisa (Nhanh nhẹn)",
                sakuya: "Sakuya (Chính xác)",
                youmu: "Youmu (Né tránh)",
                cirno: "Cirno (Kiên cường)",
                gojo: "Gojo (Tối thượng)",
                startButton: "Bắt đầu trò chơi",
                gameOverTitle: "HẾT GAME!",
                gameOverScoreText: "Bạn đã sống sót trong ",
                playAgain: "Chơi lại",
                home: "Trang chủ",
                gameWinTitle: "CHIẾN THẮNG!",
                gameWinText: "Bạn đã đánh bại Boss và mang lại hòa bình tạm thời cho vương quốc! Tuy nhiên, nguồn gốc thực sự của sự hỗn loạn vẫn còn khó nắm bắt, báo hiệu những thử thách trong tương lai...",
                finalScore: "Điểm cuối cùng: ",
                pausedTitle: "TẠM DỪNG",
                pausedHint: "Nhấn ESC hoặc nút \"Tiếp tục\" để tiếp tục",
                pause: "Tạm dừng",
                resume: "Tiếp tục",
                toggleMusic: "Bật/Tắt nhạc",
                score: "Điểm",
                difficulty: "Độ khó",
                revives: "Hồi sinh",
                skill1: "Kỹ năng 1",
                skill2: "Kỹ năng 2",
                bossHealth: "MÁU BOSS",
                bossPhase: "BOSS GIAI ĐOẠN",
                activeSkills: "Kỹ năng chủ động",
                passiveSkill: "Kỹ năng bị động",
                enemyInspirations: "Nguồn cảm hứng quái vật"
            }
        };

        let currentLanguage = 'vi'; // Default language

        function setLanguage(lang) {
            currentLanguage = lang;
            const t = texts[lang];

            // Update static texts
            gameTitle.textContent = t.gameTitle;
            startScreenTitle.textContent = t.startScreenTitle;
            startScreenStory.textContent = t.startScreenStory;
            characterSelectionTitle.textContent = t.characterSelectionTitle;
            startButton.textContent = t.startButton;
            gameOverTitle.textContent = t.gameOverTitle;
            gameOverScoreText.childNodes[0].nodeValue = t.gameOverScoreText; // Update only the text node
            restartButton.textContent = t.playAgain;
            homeButtonGameOver.textContent = t.home; // Home button text
            gameWinTitle.textContent = t.gameWinTitle;
            gameWinText.textContent = t.gameWinText;
            finalWinScoreText.childNodes[0].nodeValue = t.finalScore; // Update only the text node
            winRestartButton.textContent = t.playAgain;
            homeButtonGameWin.textContent = t.home; // Home button text
            pausedTitle.textContent = t.pausedTitle;
            pausedHint.textContent = t.pausedHint;
            homeButtonPaused.textContent = t.home; // Home button text
            pauseButton.textContent = gamePaused ? t.resume : t.pause; // Update based on current state
            musicToggleButton.textContent = t.toggleMusic;

            // Update character button texts and descriptions
            document.getElementById('reimuButton').textContent = t.reimu;
            document.getElementById('marisaButton').textContent = t.marisa;
            document.getElementById('sakuyaButton').textContent = t.sakuya;
            document.getElementById('youmuButton').textContent = t.youmu;
            document.getElementById('cirnoButton').textContent = t.cirno;
            document.getElementById('gojoButton').textContent = t.gojo;

            // Update dynamic game info texts (if game is running)
            if (gameRunning) {
                scoreDisplay.textContent = `${t.score}: ${score}`;
                if (bossActive) {
                    difficultyDisplay.textContent = `${t.difficulty}: ${t.bossPhase} ${currentBossPhaseIndex + 1}`;
                } else {
                    difficultyDisplay.textContent = `${t.difficulty}: ${difficultyLevel}`;
                }
                revivesDisplay.textContent = `${t.revives}: ${revivesLeft}`;
                // Skill display updated by updateSkillButtonState
                updateSkillButtonState(); // Update skill button text immediately
                updateBossHealthBar(); // Update boss health bar text
            } else {
                updateCharacterDescription(currentPlayerType); // Update description on start screen
            }

            // Update language button selected state
            languageButtons.forEach(btn => {
                if (btn.dataset.lang === lang) {
                    btn.classList.add('selected');
                } else {
                    btn.classList.remove('selected');
                }
            });
        }

        // Add event listeners for language buttons
        languageButtons.forEach(button => {
            button.addEventListener('click', () => {
                setLanguage(button.dataset.lang);
            });
        });


        // --- Start game function ---
        async function startGame() {
            updateCanvasSize(); // Update canvas size before starting
            createStars();
            gameRunning = true;
            gamePaused = false;
            score = 0;
            difficultyLevel = 1;
            difficultyTimer = 0;

            // Initialize player stats based on selected character
            const selectedChar = playerCharacters[currentPlayerType];
            player.speed = selectedChar.baseSpeed;
            player.focusSpeedMultiplier = selectedChar.focusSpeedMultiplier;
            player.color = selectedChar.color;
            player.hitboxRadius = selectedChar.hitboxRadius;
            player.passive = selectedChar.passive; // Assign passive skill
            player.activeSkills = selectedChar.activeSkills.map(s => ({ ...s, lastUseTime: -s.cooldown })); // Initialize active skills with cooldowns
            revivesLeft = selectedChar.initialRevives; // Set revives based on character
            
            isInvincible = false;
            invincibleTimer = 0;
            deathCount = 0; // Reset death count
            scoreAtLastDeath = 0; // Reset score at death
            nextArtifactScore = ARTIFACT_SPAWN_INTERVAL; // Reset artifact spawn threshold
            startTime = performance.now();
            lastFrameTime = startTime;

            updateSkillButtonState(); // Initialize skill button display

            boss = null; // Reset boss
            bossActive = false;
            currentBossPhaseIndex = 0; // Reset boss phase
            bossHealthBarContainer.style.display = 'none'; // Hide boss health bar

            player.x = CANVAS_WIDTH / 2;
            player.y = CANVAS_HEIGHT - player.height / 2 - 30; // Position player block correctly
            player.isFocusing = false;
            player.isDashing = false; // Reset dashing flag
            player.damageBoostActive = false; // Reset damage boost

            // Reset skill effect states
            bulletSlowEffectActive = false;
            bulletSlowTimer = 0;
            bossTimeStopActive = false; // Reset boss time stop
            bossTimeStopTimer = 0;
            playerMovementFrozen = false; // Reset player freeze
            playerSkillsFrozen = false; // Reset player skills freeze

            // Clear all game elements to ensure a clean start
            enemyProjectiles.length = 0;
            playerProjectiles.length = 0;
            bulletTrails.length = 0;
            artifacts.length = 0;
            particles.length = 0;
            beams.length = 0;
            darkZones.length = 0;
            spectralSpikes.length = 0;
            phantomBlasters.length = 0;
            crushingDescents.length = 0; // Clear crushing descents
            enemies.length = 0; // Clear all regular enemies

            clearAllTimers(); // Clear any lingering intervals/timeouts from previous games
            // Stop Tone.js transport explicitly
            if (Tone.Transport.state !== 'stopped') {
                Tone.Transport.stop();
            }


            // Spawn initial enemy
            const initialEnemyTypes = Object.keys(enemyTypes); // Get all enemy types
            const randomInitialEnemyType = initialEnemyTypes[Math.floor(Math.random() * initialEnemyTypes.length)]; // Fixed typo here
            createEnemy(randomInitialEnemyType);

            gameOverScreen.style.display = 'none';
            pausedOverlay.style.display = 'none';
            startScreen.style.display = 'none';
            gameWinScreen.style.display = 'none';

            // Update game info displays with current language
            scoreDisplay.textContent = `${texts[currentLanguage].score}: 0`;
            difficultyDisplay.textContent = `${texts[currentLanguage].difficulty}: 1`;
            revivesDisplay.textContent = `${texts[currentLanguage].revives}: ${revivesLeft}`;
            pauseButton.textContent = texts[currentLanguage].pause;
            musicToggleButton.textContent = texts[currentLanguage].toggleMusic;

            initMusic();
            initSFX();
            // Start music if not already playing or paused
            if (!isMusicPlaying) {
                await toggleMusic();
            } else {
                if (Tone.Transport.state === 'paused' || Tone.Transport.state === 'stopped') {
                    Tone.Transport.start();
                }
                masterGain.gain.linearRampToValueAtTime(0.4, Tone.context.currentTime + 0.2);
            }

            requestAnimationFrame(gameLoop);
        }

        // --- Game over function ---
        function gameOver() {
            gameRunning = false;
            gamePaused = true;
            finalScoreDisplay.textContent = score;
            gameOverScreen.style.display = 'flex';
            if (isMusicPlaying) {
                Tone.Transport.stop();
                masterGain.gain.linearRampToValueAtTime(0, Tone.context.currentTime + 0.5);
            }
            // Clear all game elements to prevent lingering issues
            enemyProjectiles.length = 0;
            playerProjectiles.length = 0;
            bulletTrails.length = 0;
            artifacts.length = 0;
            particles.length = 0;
            beams.length = 0;
            darkZones.length = 0;
            spectralSpikes.length = 0;
            phantomBlasters.length = 0;
            crushingDescents.length = 0; // Clear crushing descents
            enemies.length = 0;
            clearAllTimers(); // Clear any active intervals/timeouts
            if (Tone.Transport.state !== 'stopped') {
                Tone.Transport.stop();
            }
        }

        // --- Game Win function ---
        function gameWin() {
            gameRunning = false;
            gamePaused = true;
            finalWinScoreDisplay.textContent = score;
            gameWinScreen.style.display = 'flex';
            if (isMusicPlaying) {
                Tone.Transport.stop();
                masterGain.gain.linearRampToValueAtTime(0, Tone.context.currentTime + 0.5);
            }
            // Clear all game elements to prevent lingering issues
            enemyProjectiles.length = 0;
            playerProjectiles.length = 0;
            bulletTrails.length = 0;
            artifacts.length = 0;
            particles.length = 0;
            beams.length = 0;
            darkZones.length = 0;
            spectralSpikes.length = 0;
            phantomBlasters.length = 0;
            crushingDescents.length = 0; // Clear crushing descents
            enemies.length = 0;
            clearAllTimers(); // Clear any active intervals/timeouts
            if (Tone.Transport.state !== 'stopped') {
                Tone.Transport.stop();
            }
        }

        // --- Function to return to Start Screen ---
        function returnToStartScreen() {
            gameRunning = false;
            gamePaused = true; // Ensure game is paused when returning to start screen
            gameOverScreen.style.display = 'none';
            gameWinScreen.style.display = 'none';
            pausedOverlay.style.display = 'none';
            startScreen.style.display = 'flex'; // Show the start screen
            if (isMusicPlaying) {
                Tone.Transport.stop();
                masterGain.gain.linearRampToValueAtTime(0, Tone.context.currentTime + 0.5);
                isMusicPlaying = false; // Reset music state
            }
            // Clear all game elements to prevent lingering issues
            enemyProjectiles.length = 0;
            playerProjectiles.length = 0;
            bulletTrails.length = 0;
            artifacts.length = 0;
            particles.length = 0;
            beams.length = 0;
            darkZones.length = 0;
            spectralSpikes.length = 0;
            phantomBlasters.length = 0;
            crushingDescents.length = 0; // Clear crushing descents
            enemies.length = 0;
            clearAllTimers(); // Clear any active intervals/timeouts
            if (Tone.Transport.state !== 'stopped') {
                Tone.Transport.stop();
            }

            setLanguage(currentLanguage); // Ensure start screen text is in current language
            updateCharacterDescription(currentPlayerType); // Update description on start screen
        }

        // --- Event Listeners for buttons ---
        startButton.addEventListener('click', startGame); // New start button listener
        restartButton.addEventListener('click', startGame);
        winRestartButton.addEventListener('click', startGame); // Restart from win screen
        pauseButton.addEventListener('click', togglePause);
        musicToggleButton.addEventListener('click', toggleMusic);

        // Home button listeners
        homeButtonGameOver.addEventListener('click', returnToStartScreen);
        homeButtonGameWin.addEventListener('click', returnToStartScreen);
        homeButtonPaused.addEventListener('click', returnToStartScreen);


        // Initial setup on window load is handled by the 'load' event listener

        // --- Guide Popup Logic ---
        const guideButton = document.getElementById('guideButton');
        const guidePopup = document.getElementById('guidePopup');
        const guideTitle = document.getElementById('guideTitle');
        const guideContent = document.getElementById('guideContent');
        const closeGuideButton = document.getElementById('closeGuideButton');

        const guideTexts = {
            en: {
                title: "GUIDE",
                close: "Close",
                content: `
<b>How to Play:</b><br>
- <b>Move</b>: Arrow keys (or WASD) / Virtual joystick (mobile)<br>
- <b>Focus (slow move)</b>: Hold Shift or tap Focus button<br>
- <b>Skill 1</b>: Z key or Skill 1 button<br>
- <b>Skill 2</b>: X key or Skill 2 button<br>
- <b>Pause</b>: ESC or Pause button<br>
- <b>Revive</b>: You have limited revives. When hit, you lose one.<br>
- <b>Artifacts</b>: Collect for buffs (slow bullets, speed up, clear bullets).<br>
- <b>Boss</b>: Survive to face the boss! Each phase has unique attacks.<br>
<br>
<b>Tips:</b><br>
- Use Focus to dodge tight bullet patterns.<br>
- Each character has unique skills and passives.<br>
- Artifacts can save you in tough situations.<br>
- Some skills clear bullets or make you invincible.<br>
- Try all characters for different playstyles!<br>
                `
            },
            vi: {
                title: "HƯỚNG DẪN",
                close: "Đóng",
                content: `
<b>Cách chơi:</b><br>
- <b>Di chuyển</b>: Phím mũi tên (hoặc WASD) / Joystick ảo (mobile)<br>
- <b>Chế độ chính xác (chậm)</b>: Giữ Shift hoặc nhấn nút Focus<br>
- <b>Kỹ năng 1</b>: Phím Z hoặc nút Kỹ năng 1<br>
- <b>Kỹ năng 2</b>: Phím X hoặc nút Kỹ năng 2<br>
- <b>Tạm dừng</b>: ESC hoặc nút Tạm dừng<br>
- <b>Hồi sinh</b>: Bạn có số lần hồi sinh giới hạn. Mỗi lần trúng đạn sẽ mất 1 mạng.<br>
- <b>Vật phẩm</b>: Nhặt để nhận buff (làm chậm đạn, tăng tốc, xóa đạn).<br>
- <b>Boss</b>: Sống sót đủ lâu để gặp boss! Mỗi giai đoạn boss có chiêu riêng.<br>
<br>
<b>Mẹo:</b><br>
- Dùng Focus để né các pha mưa đạn dày đặc.<br>
- Mỗi nhân vật có kỹ năng và bị động riêng.<br>
- Vật phẩm có thể cứu bạn lúc nguy hiểm.<br>
- Một số kỹ năng giúp xóa đạn hoặc bất tử tạm thời.<br>
- Hãy thử tất cả nhân vật để tìm phong cách phù hợp!<br>
                `
            }
        };

        function showGuide() {
            guideTitle.textContent = guideTexts[currentLanguage].title;
            guideContent.innerHTML = guideTexts[currentLanguage].content;
            closeGuideButton.textContent = guideTexts[currentLanguage].close;
            guidePopup.style.display = 'flex';
        }
        function hideGuide() {
            guidePopup.style.display = 'none';
        }
        guideButton.addEventListener('click', showGuide);
        closeGuideButton.addEventListener('click', hideGuide);
        // Đóng guide khi nhấn ESC
        window.addEventListener('keydown', (e) => {
            if (guidePopup.style.display === 'flex' && (e.key === 'Escape' || e.code === 'Escape')) {
                hideGuide();
            }
        });
        // Tự động cập nhật ngôn ngữ khi đổi language
        function updateGuideLanguage() {
            if (guidePopup.style.display === 'flex') showGuide();
        }
        languageButtons.forEach(btn => btn.addEventListener('click', updateGuideLanguage));

        // Tooltip logic (PC: hover, Mobile: long press)
        const skillButtons = [
            { btn: skill1Button, name: 'Infinity', key: 'Q', desc: 'Chặn đạn, bất tử tạm thời.' },
            { btn: skill2Button, name: 'Six Eyes', key: 'E', desc: 'Tăng tốc, né tránh, làm chậm địch.' },
            { btn: skill3Button, name: 'Hollow Purple', key: 'R', desc: 'Ultimate: Tia năng lượng cực mạnh. Mở khi đủ năng lượng.' },
            { btn: skill4Button, name: 'Domain Expansion', key: 'F', desc: 'Ultimate: Đóng băng toàn bộ, mở khi tiêu diệt đủ quái.' }
        ];
        skillButtons.forEach(({btn, name, key, desc}) => {
            btn.title = `${name} (${key}): ${desc}`;
            // Mobile long press (giữ 600ms)
            let pressTimer;
            btn.addEventListener('touchstart', e => {
                pressTimer = setTimeout(() => {
                    alert(`${name}: ${desc}`);
                }, 600);
            });
            btn.addEventListener('touchend', e => clearTimeout(pressTimer));
        });

        // --- Gojo unlock logic ---
        let gojoEnergy = 0;
        let gojoKills = 0;
        let gojoSkill3Unlocked = false;
        let gojoSkill4Unlocked = false;
        const GOJO_ENERGY_MAX = 100;
        const GOJO_KILLS_REQUIRED = 20;

        function updateGojoSkillUnlocks() {
            // Skill 3: Hollow Purple
            if (currentPlayerType === 'gojo') {
                if (gojoEnergy >= GOJO_ENERGY_MAX) {
                    gojoSkill3Unlocked = true;
                    skill3Button.disabled = false;
                    skill3Button.style.opacity = 1;
                    skill3Button.innerHTML = 'R<br><span>Hollow Purple</span>';
                } else {
                    gojoSkill3Unlocked = false;
                    skill3Button.disabled = true;
                    skill3Button.style.opacity = 0.5;
                    skill3Button.innerHTML = `R<br><span>Hollow Purple<br>(${gojoEnergy}/${GOJO_ENERGY_MAX})</span>`;
                }
                // Skill 4: Domain Expansion
                if (gojoKills >= GOJO_KILLS_REQUIRED) {
                    gojoSkill4Unlocked = true;
                    skill4Button.disabled = false;
                    skill4Button.style.opacity = 1;
                    skill4Button.innerHTML = 'F<br><span>Domain Expansion</span>';
                } else {
                    gojoSkill4Unlocked = false;
                    skill4Button.disabled = true;
                    skill4Button.style.opacity = 0.5;
                    skill4Button.innerHTML = `F<br><span>Domain Expansion<br>(${gojoKills}/${GOJO_KILLS_REQUIRED})</span>`;
                }
            }
        }
        // Gọi updateGojoSkillUnlocks() mỗi khi năng lượng hoặc kill thay đổi
        // --- Tăng năng lượng khi né đạn hoặc bắn trúng ---
        function onGojoDodgeOrHit() {
            if (currentPlayerType === 'gojo' && gojoEnergy < GOJO_ENERGY_MAX) {
                gojoEnergy += 10;
                if (gojoEnergy > GOJO_ENERGY_MAX) gojoEnergy = GOJO_ENERGY_MAX;
                updateGojoSkillUnlocks();
            }
        }
        // --- Tăng kill khi tiêu diệt quái ---
        function onGojoKillEnemy() {
            if (currentPlayerType === 'gojo' && gojoKills < GOJO_KILLS_REQUIRED) {
                gojoKills++;
                updateGojoSkillUnlocks();
            }
        }
        // --- Reset khi dùng skill ---
        function onGojoUseSkill3() {
            gojoEnergy = 0;
            updateGojoSkillUnlocks();
        }
        function onGojoUseSkill4() {
            gojoKills = 0;
            updateGojoSkillUnlocks();
        }
        // --- Gọi các hàm này ở các vị trí phù hợp trong game loop ---

        // --- Hiệu ứng Infinity ---
        function drawInfinityEffect() {
            if (currentPlayerType === 'gojo' && player.activeSkill === 'infinity') {
                ctx.save();
                ctx.globalAlpha = 0.5;
                ctx.beginPath();
                ctx.arc(player.x, player.y, player.width * 2.5, 0, Math.PI * 2);
                ctx.strokeStyle = '#5ecfff';
                ctx.lineWidth = 6;
                ctx.shadowColor = '#5ecfff';
                ctx.shadowBlur = 18;
                ctx.stroke();
                ctx.restore();
            }
        }
        // --- Hiệu ứng Six Eyes ---
        function drawSixEyesEffect() {
            if (currentPlayerType === 'gojo' && player.activeSkill === 'sixEyes') {
                ctx.save();
                ctx.globalAlpha = 0.25;
                ctx.fillStyle = '#5ecfff';
                ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                ctx.restore();
                // Particle quanh Gojo
                for (let i = 0; i < 8; i++) {
                    const angle = (Math.PI * 2 / 8) * i + performance.now() * 0.002;
                    createParticle(player.x + Math.cos(angle) * 30, player.y + Math.sin(angle) * 30, '#5ecfff', 6, Math.cos(angle) * 1.5, Math.sin(angle) * 1.5, 0.7, 0.01, 0.95);
                }
            }
        }
        // --- Hiệu ứng Hollow Purple ---
        function drawHollowPurpleEffect() {
            if (currentPlayerType === 'gojo' && player.activeSkill === 'hollowPurple') {
                ctx.save();
                ctx.globalAlpha = 0.7;
                ctx.beginPath();
                ctx.arc(player.x, player.y, 40, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(120,0,255,0.7)';
                ctx.shadowColor = '#a0f';
                ctx.shadowBlur = 30;
                ctx.fill();
                ctx.restore();
                // Laser
                ctx.save();
                ctx.globalAlpha = 0.5;
                ctx.beginPath();
                ctx.moveTo(player.x, player.y);
                ctx.lineTo(player.x, 0);
                ctx.strokeStyle = 'rgba(180,0,255,0.7)';
                ctx.lineWidth = 22;
                ctx.shadowColor = '#fff';
                ctx.shadowBlur = 40;
                ctx.stroke();
                ctx.restore();
            }
        }
        // --- Hiệu ứng Domain Expansion ---
        function drawDomainExpansionEffect() {
            if (currentPlayerType === 'gojo' && player.activeSkill === 'domainExpansion') {
                ctx.save();
                ctx.globalAlpha = 0.35;
                ctx.fillStyle = 'rgba(80,0,120,0.7)';
                ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                ctx.restore();
                // Vòng tròn không gian
                ctx.save();
                ctx.globalAlpha = 0.7;
                ctx.beginPath();
                ctx.arc(player.x, player.y, 180, 0, Math.PI * 2);
                ctx.strokeStyle = '#a0f';
                ctx.lineWidth = 10;
                ctx.shadowColor = '#fff';
                ctx.shadowBlur = 30;
                ctx.stroke();
                ctx.restore();
            }
        }
        // --- Gọi các hàm hiệu ứng này trong game loop ---

        function showGojoGuide() {
            const isMobile = window.innerWidth < 800;
            let text = '';
            if (isMobile) {
                text = 'Chạm nút 1: Infinity<br>2: Six Eyes<br>3: Hollow Purple (mở khi đủ năng lượng)<br>4: Domain Expansion (mở khi đủ kill)';
            } else {
                text = 'Q: Infinity | E: Six Eyes | R: Hollow Purple (mở khi đủ năng lượng) | F: Domain Expansion (mở khi đủ kill)';
            }
            document.getElementById('gojoSkillGuideText').innerHTML = text;
            document.getElementById('gojoSkillGuide').style.display = 'block';
        }
        document.getElementById('gojoGuideBtn').onclick = showGojoGuide;
        // Tự động hiện hướng dẫn khi chọn Gojo
        function autoShowGojoGuideOnSelect() {
            if (currentPlayerType === 'gojo') setTimeout(showGojoGuide, 500);
        }
        // Gọi autoShowGojoGuideOnSelect() khi người chơi chọn nhân vật Gojo

        // --- Đảm bảo random enemyType đúng ---
        function spawnRandomEnemy() {
            const enemyTypesArray = Object.keys(enemyTypes);
            const randomEnemyType = enemyTypesArray[Math.floor(Math.random() * enemyTypesArray.length)];
            createEnemy(randomEnemyType);
        }
        // --- Sửa trong game loop ---
        if (!bossActive) {
            difficultyTimer += deltaTime;
            const difficultyIncreaseInterval = 4;
            if (difficultyTimer >= difficultyIncreaseInterval) {
                difficultyLevel++;
                difficultyTimer = 0;
                difficultyDisplay.textContent = `${texts[currentLanguage].difficulty}: ${difficultyLevel}`;
                playDifficultyUpSFX();
            }
            if (enemies.length < MAX_ENEMIES_ON_SCREEN) {
                spawnRandomEnemy();
            }
        } else {
            updateBoss(deltaTime);
            updateBossHealthBar();
        }
        // --- Sửa khi khởi tạo game ---
        // Spawn initial enemy
        spawnRandomEnemy();
        // --- Đảm bảo player luôn được khởi tạo đúng ---
        function resetPlayer() {
            const char = playerCharacters[currentPlayerType];
            player.x = CANVAS_WIDTH / 2;
            player.y = CANVAS_HEIGHT - 50;
            player.width = 20;
            player.height = 20;
            player.speed = char.baseSpeed;
            player.focusSpeedMultiplier = char.focusSpeedMultiplier;
            player.color = char.color;
            player.hitboxRadius = char.hitboxRadius;
            player.isFocusing = false;
            player.isDashing = false;
            player.activeSkills = char.activeSkills.map(skill => ({...skill, lastUseTime: 0}));
            player.passive = char.passive;
            player.damageBoostActive = false;
        }
        // Gọi resetPlayer() khi bắt đầu game hoặc chọn lại nhân vật
        resetPlayer();
        // --- Đảm bảo luôn vẽ player và enemy trong game loop ---
        ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        updatePlayer(deltaTime);
        drawPlayer();
        updateEnemies(deltaTime);
        enemies.forEach(drawEnemy);
    </script>
</body>
</html>
