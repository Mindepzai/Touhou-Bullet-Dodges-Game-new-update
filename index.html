<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Touhou Bullet Dodge Game</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh; /* Ensure minimum height for centering */
            background-color: #1a1a2e; /* Dark background */
            color: #e0e0e0; /* Light text */
            margin: 0;
            overflow-y: auto; /* Allow vertical scrolling if content overflows */
            padding: 20px;
            box-sizing: border-box;
        }

        .game-container {
            background-color: #2a2a4a; /* Game container background */
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            padding: 20px;
            display: flex;
            flex-direction: column; /* Default vertical layout for desktop/portrait */
            align-items: center;
            gap: 20px;
            width: 500px; /* Fixed width for desktop */
            max-width: 90%; /* Max width for smaller screens */
            position: relative; /* For overlays and absolute positioning of controls */
            overflow: hidden; /* Prevent star background from spilling */
            flex-grow: 1; /* Allow container to grow */
            justify-content: center; /* Center content vertically */
            height: auto; /* Allow height to adjust based on content */
        }

        canvas {
            background-color: #0d0d1a; /* Canvas background */
            border: 3px solid #6a0572; /* Purple border */
            border-radius: 10px;
            display: block;
            touch-action: none; /* Prevent scrolling/zooming on touch devices */
            width: 480px; /* Fixed width for desktop */
            height: 640px; /* Fixed height for desktop */
            position: relative;
            z-index: 1; /* Ensure canvas is above star background */
        }

        .star-background {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: transparent;
            overflow: hidden;
            border-radius: 15px; /* Same as game-container border-radius */
            z-index: 0; /* Ensure star background is below canvas */
        }

        .star {
            position: absolute;
            background-color: #fff;
            border-radius: 50%;
            opacity: 0;
            animation: twinkle 5s infinite ease-in-out;
        }

        @keyframes twinkle {
            0%, 100% { opacity: 0; }
            50% { opacity: 0.8; }
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            width: 100%; /* Changed from max-width to 100% */
            max-width: 480px; /* Still apply max-width for desktop */
            font-size: 1.2em;
            font-weight: bold;
            color: #a0a0ff; /* Light blue color */
            padding: 5px 0;
            border-bottom: 1px solid #4a4a6a;
            z-index: 2; /* Ensure game info is on top */
        }

        .boss-health-bar-container {
            width: 100%;
            max-width: 480px;
            height: 20px;
            background-color: #333;
            border: 2px solid #ff0000;
            border-radius: 5px;
            margin-bottom: 10px;
            overflow: hidden;
            position: relative;
            z-index: 2;
        }

        .boss-health-bar {
            height: 100%;
            background-color: #ff0000;
            width: 100%; /* Initial width */
            transition: width 0.2s ease-out;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.9em;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
        }

        .button {
            background: linear-gradient(145deg, #8a2be2, #6a0572); /* Purple gradient */
            color: white;
            border: 2px solid #a052ee; /* Lighter border */
            padding: 12px 25px;
            border-radius: 8px;
            font-size: 1.1em;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.2);
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: bold;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
            flex: 1; /* Allow buttons to stretch */
            min-width: 120px; /* Minimum width limit */
        }

        .button:hover {
            background: linear-gradient(145deg, #6a0572, #8a2be2);
            transform: translateY(-2px) scale(1.02);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.3);
        }

        .button:active {
            transform: translateY(0);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2), inset 0 1px 0 rgba(0, 0, 0, 0.1);
        }

        .control-button {
            background-color: #4a4a6a;
            color: white;
            border: none;
            padding: 15px 25px;
            border-radius: 50%;
            font-size: 1.5em;
            cursor: pointer;
            touch-action: manipulation; /* Prevent default browser behavior */
            transition: background-color 0.2s ease;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.3);
            display: flex;
            justify-content: center;
            align-items: center;
            width: 60px; /* Default larger size for better touch */
            height: 60px; /* Default larger size for better touch */
            flex-shrink: 0; /* Prevent shrinking */
        }

        .control-button.focus-button {
            border-radius: 8px; /* Rectangular focus button */
            width: auto;
            height: auto;
            padding: 12px 20px;
            font-size: 1em;
            background: linear-gradient(145deg, #28a745, #218838); /* Green color */
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .control-button.skill-button {
            background: linear-gradient(145deg, #007bff, #0056b3); /* Blue color for skill */
            border-radius: 8px;
            width: auto;
            height: auto;
            padding: 12px 20px;
            font-size: 1em;
        }
        .control-button.skill-button:disabled {
            background-color: #555;
            cursor: not-allowed;
            opacity: 0.7;
        }


        .control-button:active {
            background-color: #6a6a8a;
        }

        .game-over-screen, .paused-overlay, .start-screen, .game-win-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85); /* Darker overlay background */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #fff;
            font-size: 2em;
            text-align: center;
            z-index: 100;
            border-radius: 15px;
            gap: 20px;
            backdrop-filter: blur(5px); /* Blur effect */
            overflow-y: auto; /* Allow internal scrolling if content overflows */
            padding-top: 60px; /* Add padding to account for main controls at top */
            padding-bottom: 20px; /* Add some bottom padding */
            box-sizing: border-box; /* Include padding in height calculation */
        }

        .game-over-screen h2, .paused-overlay h2, .start-screen h2, .game-win-screen h2 {
            margin-bottom: 10px;
            color: #ff6b6b; /* Red color */
            text-shadow: 0 0 10px rgba(255, 107, 107, 0.7);
        }

        .start-screen h2 {
            color: #a0a0ff; /* Light blue for start title */
            text-shadow: 0 0 10px rgba(160, 160, 255, 0.7);
        }
        .game-win-screen h2 {
            color: #28a745; /* Green for win title */
            text-shadow: 0 0 10px rgba(40, 167, 69, 0.7);
        }

        .game-over-screen p, .start-screen p, .game-win-screen p {
            font-size: 0.8em;
            margin-bottom: 20px;
            max-width: 80%; /* Limit text width */
        }

        /* Main controls container (Pause, Music) */
        .main-controls-container {
            position: absolute; /* Position absolutely within game-container */
            top: 20px; /* Distance from top */
            left: 20px; /* Distance from left */
            right: 20px; /* Distance from right */
            display: flex;
            justify-content: space-between; /* Push buttons to edges */
            gap: 10px;
            z-index: 200;
            width: auto; /* Auto width based on left/right */
            padding: 0; /* No internal padding */
            box-sizing: border-box;
        }

        /* Adjust restart button on game over screen */
        #gameOverScreen .button, #startScreen .button, #gameWinScreen .button {
            min-width: 180px;
        }

        /* Styles for the virtual joystick */
        .joystick-container {
            display: none; /* Hidden by default on desktop */
            position: fixed; /* Fixed position relative to viewport */
            bottom: 20px; /* Increased bottom for better thumb reach */
            left: 20px; /* Increased left for better thumb reach */
            width: 90px; /* Slightly smaller default size */
            height: 90px;
            background-color: rgba(74, 74, 106, 0.7);
            border-radius: 50%;
            justify-content: center;
            align-items: center;
            touch-action: none; /* Prevent default browser touch actions */
            z-index: 150;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.5);
        }

        .joystick-handle {
            width: 35px; /* Adjusted handle size */
            height: 35px;
            background-color: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            position: absolute;
            touch-action: none;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }

        /* Focus button and Skill buttons for mobile and desktop */
        #focusButton, #skill1Button, #skill2Button {
            display: flex; /* Always display */
            position: fixed; /* Fixed position relative to viewport */
            z-index: 150;
            width: 60px; /* Consistent size for better touch */
            height: 60px;
            font-size: 1.1em;
            padding: 10px;
            position: relative;
            overflow: hidden;
        }
        
        .skill-cooldown {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 0%;
            background-color: rgba(0, 0, 0, 0.5);
            transition: height 0.1s linear;
            pointer-events: none;
        }
        
        #skill1Button:disabled, #skill2Button:disabled {
            opacity: 0.7;
            cursor: not-allowed;
        }

        /* Positioning for left side buttons */
        #joystickContainer {
            bottom: 20px;
            left: 20px;
        }

        #skill1Button {
            bottom: 120px; /* Above joystick (20 + 90 + 10 margin) */
            left: 20px; /* Aligned with joystick */
        }

        /* Positioning for right side buttons */
        #focusButton {
            bottom: 20px;
            right: 20px;
        }

        #skill2Button {
            bottom: 120px; /* Above focus button (20 + 90 + 10 margin) */
            right: 20px; /* Aligned with focus button */
        }

        /* Responsive adjustments for mobile (max-width 768px) */
        @media (max-width: 768px) {
            .game-container {
                width: 95%; /* Responsive width for mobile */
                max-width: unset; /* Remove fixed max-width */
                padding: 15px;
            }
            canvas {
                width: 100%; /* Canvas takes full width of its container */
                height: auto; /* Height auto-adjusts to maintain aspect ratio */
            }
            .game-info {
                font-size: 1em;
            }
            .game-over-screen, .paused-overlay, .start-screen, .game-win-screen {
                font-size: 1.5em;
            }
            .game-over-screen p, .start-screen p, .game-win-screen p {
                font-size: 0.7em;
            }
            .button {
                padding: 10px 15px;
                font-size: 0.9em;
                min-width: unset; /* Remove min-width limit */
            }
            /* Main controls container should remain absolute within game-container */
            .main-controls-container {
                position: absolute;
                top: 15px; /* Adjust top for smaller padding */
                left: 15px;
                right: 15px;
            }
            .joystick-container {
                display: flex; /* Show joystick on mobile */
            }
        }

        /* Further adjustments for very small mobile screens (max-width 480px) */
        @media (max-width: 480px) {
            .game-container {
                padding: 10px;
            }
            .joystick-container {
                width: 80px; /* Even smaller */
                height: 80px;
                bottom: 15px; /* Even closer to edge */
                left: 15px;
            }
            .joystick-handle {
                width: 30px;
                height: 30px;
            }
            #focusButton, #skill1Button, #skill2Button {
                width: 50px; /* Even smaller */
                height: 50px;
                font-size: 0.9em;
                padding: 8px;
            }
            #focusButton.focus-button, #skill1Button.skill-button, #skill2Button.skill-button {
                padding: 8px 12px;
                font-size: 0.8em;
            }
            #skill1Button {
                bottom: 105px; /* Adjusted position (15 + 80 + 10 margin) */
                left: 15px;
            }
            #skill2Button {
                bottom: 105px; /* Adjusted position (15 + 80 + 10 margin) */
                right: 15px;
            }
            .main-controls-container {
                top: 10px; /* Adjust top for smaller padding */
                left: 10px;
                right: 10px;
            }
        }

        /* Landscape mode adjustments for mobile (orientation: landscape and max-height 768px) */
        @media (orientation: landscape) and (max-height: 768px) {
            body {
                padding: 10px; /* Reduce overall padding */
            }
            .game-container {
                flex-direction: row; /* Arrange horizontally in landscape */
                flex-wrap: nowrap; /* Prevent wrapping */
                justify-content: center;
                align-items: stretch; /* Stretch items to fill height */
                padding: 10px; /* Reduce padding */
                gap: 10px; /* Reduce gap */
                width: 100%; /* Take full width */
                height: 98vh; /* Take most of viewport height */
                max-width: unset; /* Remove fixed max-width in landscape */
            }
            canvas {
                width: auto; /* Let width adjust based on height and aspect ratio */
                height: 100%; /* Canvas takes full height of its container */
                max-width: 70%; /* Limit canvas width to leave space for controls */
            }
            .game-info {
                flex-basis: auto; /* Allow content to dictate width */
                order: unset; /* Revert order */
                font-size: 0.8em; /* Smaller font for game info */
                padding-bottom: 5px;
                border-bottom: 1px solid #4a4a6a;
                margin-bottom: 5px;
            }
            .main-controls-container {
                position: absolute; /* Keep absolute positioning in landscape */
                top: 10px; /* Adjust top for landscape */
                left: 10px;
                right: 10px;
                flex-direction: row; /* Keep buttons in a row at the top */
                justify-content: space-between;
                width: auto;
                max-width: unset;
                padding: 0;
                gap: 5px;
                align-items: center;
                margin-top: 0;
                height: auto;
                flex-grow: 0; /* Do not grow, maintain fixed height */
                min-width: unset;
            }
            .main-controls-container .button {
                padding: 6px 10px; /* Smaller padding */
                font-size: 0.7em; /* Smaller font */
                min-width: unset;
                flex: none;
            }
            /* Fixed controls for landscape - adjusted for thumb comfort */
            .joystick-container {
                bottom: 10px; /* Even closer to edge */
                left: 10px;
                width: 70px; /* Smaller size in landscape */
                height: 70px;
            }
            .joystick-handle {
                width: 25px;
                height: 25px;
            }
            #focusButton, #skill1Button, #skill2Button {
                width: 50px; /* Smaller size in landscape */
                height: 50px;
                font-size: 0.9em;
                padding: 8px;
            }
            #focusButton.focus-button, #skill1Button.skill-button, #skill2Button.skill-button {
                padding: 8px 12px;
                font-size: 0.8em;
            }
            #skill1Button {
                bottom: 90px; /* Adjusted position (10 + 70 + 10 margin) */
                left: 10px;
            }
            #skill2Button {
                bottom: 90px; /* Adjusted position (10 + 70 + 10 margin) */
                right: 10px;
            }
            .game-over-screen, .paused-overlay, .start-screen, .game-win-screen {
                font-size: 1em; /* Smaller font size */
                gap: 5px;
            }
        }

        /* Language selection buttons */
        .language-selection {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        .language-button {
            background: #4a4a6a;
            color: white;
            border: 1px solid #6a6a8a;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9em;
            transition: background-color 0.2s;
        }
        .language-button:hover {
            background: #6a6a8a;
        }
        .language-button.selected {
            background: #8a2be2;
            border-color: #a052ee;
        }

        .character-selection {
            margin: 20px 0;
            text-align: center;
        }

        .character-selection h3 {
            color: #fff;
            margin-bottom: 10px;
            font-size: 1.2em;
        }

        .character-buttons {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            margin-bottom: 15px;
        }

        .character-button {
            background: #4a4a6a;
            border: 2px solid #6a6a8a;
            color: white;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .character-button:hover {
            background: #6a6a8a;
            transform: translateY(-2px);
        }

        .character-button.selected {
            background: #8a2be2;
            border-color: #a052ee;
            box-shadow: 0 0 10px rgba(138, 43, 226, 0.5);
        }

        .character-name {
            font-weight: bold;
            margin-top: 5px;
        }

        .character-description {
            font-size: 0.9em;
            color: #ccc;
            margin: 15px 0;
            max-width: 80%;
            text-align: center;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="star-background" id="starBackground"></div>
        
        <!-- Main controls container moved to top absolute position -->
        <div class="main-controls-container">
            <button id="pauseButton" class="button">Pause</button>
            <button id="musicToggleButton" class="button">Toggle Music</button>
        </div>

        <h1 id="gameTitle">Touhou Bullet Dodge Game</h1>
        <div class="game-info">
            <span id="scoreDisplay">Score: 0</span>
            <span id="difficultyDisplay">Difficulty: 1</span>
            <span id="revivesDisplay">Revives: 3</span>
            <!-- Skill displays removed from here, integrated into buttons -->
        </div>
        <div class="boss-health-bar-container" id="bossHealthBarContainer" style="display: none;">
            <div class="boss-health-bar" id="bossHealthBar">BOSS HEALTH</div>
        </div>
        <canvas id="gameCanvas"></canvas>

        <!-- Joystick and Skill 1 on the left -->
        <div class="joystick-container" id="joystickContainer">
            <div class="joystick-handle" id="joystickHandle"></div>
        </div>
        <button class="control-button skill-button" id="skill1Button" aria-label="Skill 1">Skill 1: ∞</button>

        <!-- Focus and Skill 2 on the right -->
        <button class="control-button focus-button" id="focusButton" aria-label="Focus">Focus</button>
        <button class="control-button skill-button" id="skill2Button" aria-label="Skill 2">Skill 2: ∞</button>


        <div id="startScreen" class="start-screen">
            <h2 id="startScreenTitle">TOUHOU BULLET DODGE GAME</h2>
            <p id="startScreenStory">You are a fragment of forgotten magic, awakened in a chaotic realm. Dodge the relentless magical distortions and face the source of the chaos to bring temporary peace. Survive as long as you can! As you delve deeper, you sense a formidable presence, the source of these distortions, awaiting your challenge. After defeating the initial manifestations, a deeper, more ancient evil stirs, threatening to engulf all. Your journey is far from over...</p>
            <h3 id="characterSelectionTitle">Select Your Character:</h3>
            <div id="characterSelection" style="display: flex; gap: 20px; margin-bottom: 20px; flex-wrap: wrap; justify-content: center;">
                <button class="button character-button" data-character="reimu" id="reimuButton">Reimu (Balanced)</button>
                <button class="button character-button" data-character="marisa" id="marisaButton">Marisa (Fast)</button>
                <button class="button character-button" data-character="sakuya" id="sakuyaButton">Sakuya (Precise)</button>
                <button class="button character-button" data-character="youmu" id="youmuButton">Youmu (Swift)</button>
                <button class="button character-button" data-character="cirno" id="cirnoButton">Cirno (Resilient)</button>
            </div>
            <div id="characterDescription" class="character-description"></div>
            <div class="character-selection">
                <h3>Select Character:</h3>
                <div class="character-buttons">
                    <button class="character-button selected" data-character="reimu">
                        <span class="character-name">Reimu</span>
                    </button>
                    <button class="character-button" data-character="marisa">
                        <span class="character-name">Marisa</span>
                    </button>
                    <button class="character-button" data-character="sakuya">
                        <span class="character-name">Sakuya</span>
                    </button>
                    <button class="character-button" data-character="youmu">
                        <span class="character-name">Youmu</span>
                    </button>
                    <button class="character-button" data-character="cirno">
                        <span class="character-name">Cirno</span>
                    </button>
                </div>
            </div>
            <div class="language-selection">
                <button class="language-button selected" data-lang="en">English</button>
                <button class="language-button" data-lang="vi">Tiếng Việt</button>
            </div>
            <button id="startButton" class="button">Start Game</button>
        </div>

        <div id="bossCutscene" class="cutscene-overlay" style="display: none;">
            <div class="cutscene-content">
                <h2 id="cutsceneTitle">!!! WARNING !!!</h2>
                <p id="cutsceneText">A powerful enemy approaches! Prepare for battle!</p>
                <button id="skipCutscene" class="button">Skip</button>
            </div>
        </div>

        <div id="gameOverScreen" class="game-over-screen" style="display: none;">
            <h2 id="gameOverTitle">GAME OVER!</h2>
            <p id="gameOverScoreText">You survived for <span id="finalScore">0</span> seconds</p>
            <button id="restartButton" class="button">Play Again</button>
            <button id="homeButtonGameOver" class="button">Home</button>
        </div>

        <div id="gameWinScreen" class="game-win-screen" style="display: none;">
            <h2 id="gameWinTitle">VICTORY!</h2>
            <p id="gameWinText">You have defeated the Boss and brought temporary peace to the realm! However, the true source of chaos remains elusive, hinting at future challenges...</p>
            <p id="finalWinScoreText">Final Score: <span id="finalWinScore">0</span></p>
            <button id="winRestartButton" class="button">Play Again</button>
            <button id="homeButtonGameWin" class="button">Home</button>
        </div>

        <div id="pausedOverlay" class="paused-overlay" style="display: none;">
            <h2 id="pausedTitle">PAUSED</h2>
            <p id="pausedHint">Press ESC or "Resume" button to continue</p>
            <button id="homeButtonPaused" class="button">Home</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const difficultyDisplay = document.getElementById('difficultyDisplay');
        const revivesDisplay = document.getElementById('revivesDisplay');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const finalScoreDisplay = document.getElementById('finalScore');
        const restartButton = document.getElementById('restartButton');
        const pauseButton = document.getElementById('pauseButton');
        const musicToggleButton = document.getElementById('musicToggleButton');
        const pausedOverlay = document.getElementById('pausedOverlay');
        const starBackground = document.getElementById('starBackground');
        const startScreen = document.getElementById('startScreen');
        const startButton = document.getElementById('startButton');
        const gameWinScreen = document.getElementById('gameWinScreen');
        const finalWinScoreDisplay = document.getElementById('finalWinScore');
        const winRestartButton = document.getElementById('winRestartButton');

        // Home buttons
        const homeButtonGameOver = document.getElementById('homeButtonGameOver');
        const homeButtonGameWin = document.getElementById('homeButtonGameWin');
        const homeButtonPaused = document.getElementById('homeButtonPaused');


        // Boss Health Bar elements
        const bossHealthBarContainer = document.getElementById('bossHealthBarContainer');
        const bossHealthBar = document.getElementById('bossHealthBar');

        // Joystick elements
        const joystickContainer = document.getElementById('joystickContainer');
        const joystickHandle = document.getElementById('joystickHandle');
        const focusButton = document.getElementById('focusButton');
        const skill1Button = document.getElementById('skill1Button');
        const skill2Button = document.getElementById('skill2Button');

        // Character selection elements
        const characterSelectionDiv = document.getElementById('characterSelection');
        const characterButtons = document.querySelectorAll('.character-button');
        const characterDescription = document.getElementById('characterDescription');

        // Language selection elements
        const languageButtons = document.querySelectorAll('.language-button');

        // Text elements for translation
        const gameTitle = document.getElementById('gameTitle');
        const startScreenTitle = document.getElementById('startScreenTitle');
        const startScreenStory = document.getElementById('startScreenStory');
        const characterSelectionTitle = document.getElementById('characterSelectionTitle');
        const gameOverTitle = document.getElementById('gameOverTitle');
        const gameOverScoreText = document.getElementById('gameOverScoreText');
        const gameWinTitle = document.getElementById('gameWinTitle');
        const gameWinText = document.getElementById('gameWinText');
        const finalWinScoreText = document.getElementById('finalWinScoreText');
        const pausedTitle = document.getElementById('pausedTitle');
        const pausedHint = document.getElementById('pausedHint');
        const reimuButton = document.getElementById('reimuButton');
        const marisaButton = document.getElementById('marisaButton');
        const sakuyaButton = document.getElementById('sakuyaButton');
        const youmuButton = document.getElementById('youmuButton');
        const cirnoButton = document.getElementById('cirnoButton');

        const cutsceneTitle = document.getElementById('cutsceneTitle');
        const cutsceneText = document.getElementById('cutsceneText');
        const skipCutsceneButton = document.getElementById('skipCutscene');

        // Canvas dimensions (will be updated dynamically)
        let CANVAS_WIDTH = 480;
        let CANVAS_HEIGHT = 640;
        const CANVAS_ASPECT_RATIO = 3 / 4; // Desired aspect ratio (width / height)

        // Global array to store active timer IDs (both setTimeout and setInterval) for cleanup
        let activeTimers = [];

        // Helper function to add timers to the tracking array
        function addTimer(type, callback, delay) {
            let id;
            if (type === 'interval') {
                id = setInterval(callback, delay);
            } else if (type === 'timeout') {
                id = setTimeout(callback, delay);
            }
            activeTimers.push({ id: id, type: type });
            return id; // Return ID in case it needs to be cleared individually
        }

        // Helper function to clear a specific timer
        function clearSpecificTimer(id) {
            const index = activeTimers.findIndex(timer => timer.id === id);
            if (index > -1) {
                const timer = activeTimers[index];
                if (timer.type === 'interval') {
                    clearInterval(timer.id);
                } else if (timer.type === 'timeout') {
                    clearTimeout(timer.id);
                }
                activeTimers.splice(index, 1);
            }
        }

        // Helper function to clear all active timers
        function clearAllTimers() {
            activeTimers.forEach(timer => {
                if (timer.type === 'interval') {
                    clearInterval(timer.id);
                } else if (timer.type === 'timeout') {
                    clearTimeout(timer.id);
                }
            });
            activeTimers = []; // Clear the array
        }

        // Function to update canvas size based on available space and aspect ratio
        function updateCanvasSize() {
            const gameContainer = document.querySelector('.game-container');
            const isMobile = window.innerWidth <= 768; // Define mobile breakpoint
            const isLandscape = window.innerWidth > window.innerHeight;

            let newCanvasWidth;
            let newCanvasHeight;

            if (isMobile) {
                // For mobile, canvas should be responsive
                let availableWidth = window.innerWidth - 40; // Account for body padding
                let availableHeight = window.innerHeight - 40; // Account for body padding

                if (isLandscape) {
                    // In landscape, canvas should prioritize height and adjust width
                    newCanvasHeight = availableHeight;
                    newCanvasWidth = newCanvasHeight * CANVAS_ASPECT_RATIO;

                    // If calculated width is too wide, adjust based on width
                    if (newCanvasWidth > availableWidth * 0.7) { // Canvas takes max 70% of available width
                        newCanvasWidth = availableWidth * 0.7;
                        newCanvasHeight = newCanvasWidth / CANVAS_ASPECT_RATIO;
                    }
                } else { // Mobile portrait
                    newCanvasWidth = availableWidth; // Take full available width
                    newCanvasHeight = newCanvasWidth / CANVAS_ASPECT_RATIO;

                    // If calculated height is too tall, adjust based on height
                    if (newCanvasHeight > availableHeight) {
                        newCanvasHeight = availableHeight;
                        newCanvasWidth = newCanvasHeight * CANVAS_ASPECT_RATIO;
                    }
                }
            } else { // Desktop
                // For desktop, canvas has fixed dimensions
                newCanvasWidth = 480;
                newCanvasHeight = 640;
            }

            CANVAS_WIDTH = newCanvasWidth;
            CANVAS_HEIGHT = newCanvasHeight;

            canvas.width = CANVAS_WIDTH;
            canvas.height = CANVAS_HEIGHT;

            // Adjust game-container width/flex for landscape vs portrait
            if (isMobile && isLandscape) {
                gameContainer.style.flexDirection = 'row';
                gameContainer.style.justifyContent = 'center';
                gameContainer.style.alignItems = 'stretch'; /* Stretch to fill height */
                gameContainer.style.maxWidth = 'unset'; /* Remove fixed max-width */
                gameContainer.style.width = '100%'; /* Take full width */
                gameContainer.style.height = '98vh'; /* Take most of viewport height */
            } else if (isMobile) { // Mobile portrait
                gameContainer.style.flexDirection = 'column';
                gameContainer.style.justifyContent = 'center';
                gameContainer.style.alignItems = 'center';
                gameContainer.style.maxWidth = `${CANVAS_WIDTH + 40}px`; /* Match canvas width + padding */
                gameContainer.style.width = '95%';
                gameContainer.style.height = 'auto'; /* Let content dictate height */
            } else { // Desktop
                gameContainer.style.flexDirection = 'column';
                gameContainer.style.justifyContent = 'center';
                gameContainer.style.alignItems = 'center';
                gameContainer.style.maxWidth = `500px`; /* Fixed width for desktop */
                gameContainer.style.width = `500px`;
                gameContainer.style.height = 'auto';
            }


            // Reposition player if canvas size changes significantly
            // Ensure player stays within new canvas bounds
            player.x = Math.min(player.x, CANVAS_WIDTH - player.width / 2);
            player.y = Math.min(player.y, CANVAS_HEIGHT - player.height / 2);
            player.x = Math.max(player.x, player.width / 2);
            player.y = Math.max(player.y, player.height / 2);
        }

        // Function to create dynamic star background
        function createStars() {
            starBackground.innerHTML = ''; // Clear old stars
            const numStars = 100;
            for (let i = 0; i < numStars; i++) {
                const star = document.createElement('div');
                star.className = 'star';
                star.style.width = `${Math.random() * 3 + 1}px`;
                star.style.height = star.style.width;
                star.style.left = `${Math.random() * 100}%`;
                star.style.top = `${Math.random() * 100}%`;
                star.style.animationDelay = `${Math.random() * 5}s`;
                starBackground.appendChild(star);
            }
        }

        // Call on page load and window resize
        window.addEventListener('load', () => {
            updateCanvasSize();
            createStars();
            // Show start screen on load instead of starting game
            startScreen.style.display = 'flex';
            setLanguage(currentLanguage); // Set initial language
            updateCharacterDescription(currentPlayerType); // Display initial character description
        });
        window.addEventListener('resize', () => {
            updateCanvasSize();
            // Redraw game elements if game is running to adapt to new canvas size
            if (gameRunning && !gamePaused) {
                // No need to restart, just ensure elements are within bounds
                enemyProjectiles.forEach(b => {
                    b.x = Math.min(b.x, CANVAS_WIDTH + b.radius);
                    b.y = Math.min(b.y, CANVAS_HEIGHT + b.radius);
                });
                playerProjectiles.forEach(b => {
                    b.x = Math.min(b.x, CANVAS_WIDTH + b.radius);
                    b.y = Math.min(b.y, CANVAS_HEIGHT + b.radius);
                });
                enemies.forEach(e => {
                    e.x = Math.min(e.x, CANVAS_WIDTH - e.width / 2);
                    e.y = Math.min(e.y, CANVAS_HEIGHT - e.height / 2);
                });
                artifacts.forEach(a => {
                    a.x = Math.min(a.x, CANVAS_WIDTH - a.radius);
                    a.y = Math.min(a.y, CANVAS_HEIGHT - a.radius);
                });
                // Reposition boss if active
                if (bossActive && boss) {
                    boss.x = Math.min(boss.x, CANVAS_WIDTH - boss.width / 2);
                    boss.y = Math.min(boss.y, CANVAS_HEIGHT - boss.height / 2);
                }
            }
        });

        // --- Game variables ---
        let gameRunning = false;
        let gamePaused = false;
        let score = 0;
        let startTime = 0;
        let lastFrameTime = 0;
        let difficultyLevel = 1;
        let difficultyTimer = 0;
        let revivesLeft = 3; // Number of revives left (Increased to 3)
        let isInvincible = false; // Invincibility status
        let invincibleTimer = 0;
        const INVINCIBLE_DURATION = 2; // Invincibility duration after revive (seconds)

        let deathCount = 0; // Consecutive deaths
        let scoreAtLastDeath = 0; // Score at last death

        const ASSIST_DEATH_THRESHOLD = 3; // Consecutive deaths to trigger assist
        const ASSIST_SCORE_THRESHOLD = 10; // If score increases less than this threshold after deaths

        const ARTIFACT_SPAWN_INTERVAL = 50; // Artifact appears every 50 points
        let nextArtifactScore = ARTIFACT_SPAWN_INTERVAL;
        const artifacts = []; // Array to hold artifacts

        // --- Skill variables ---
        let bulletSlowEffectActive = false; // For Youmu's skill
        let bulletSlowTimer = 0;
        let bossTimeStopActive = false; // For Time Manipulator's Temporal Stasis
        let bossTimeStopTimer = 0;

        // --- Boss variables ---
        let boss = null;
        let bossActive = false;
        let inCutscene = false; // Track if we're in a cutscene
        const BOSS_SPAWN_SCORE = 100; // Score to trigger boss fight
        const BOSS_PHASES = [ // Define boss phases with health and initial shoot interval
            { maxHealth: 500, shootInterval: 0.4, name: "Shadow Weaver" }, // Phase 1: Shadow Weaver (Cid)
            { maxHealth: 750, shootInterval: 0.3, name: "Lich Overlord" }, // Phase 2: Lich Overlord (Overlord)
            { maxHealth: 1000, shootInterval: 0.2, name: "Spirit of Retribution" }, // Phase 3: Spirit of Retribution (Sans)
            { maxHealth: 1500, shootInterval: 0.1, name: "Time Manipulator" } // Phase 4: Time Manipulator (Dio)
        ];
        let currentBossPhaseIndex = 0;
        let lastBossDamageTime = 0;
        const BOSS_DAMAGE_INTERVAL = 5; // Boss takes damage every 5 seconds of survival

        // --- New Attack Arrays for Boss ---
        const enemyProjectiles = []; // Traditional bullets from regular enemies
        const playerProjectiles = []; // Player's skill-based projectiles (e.g., Marisa's Spiral Orb)
        const beams = []; // For Shadow Weaver's energy beams
        const darkZones = []; // For Lich Overlord's dark zones
        const spectralSpikes = []; // For Spirit of Retribution's bone attacks
        const phantomBlasters = []; // For Spirit of Retribution's Phantom Blasters
        const crushingDescents = []; // For Time Manipulator's Crushing Descent
        const particles = []; // For skill effects
        const enemies = [];
        const MAX_ENEMIES_ON_SCREEN = 3; // Reduced number of regular enemies

        const enemyTypes = {
            basic: {
                width: 30,
                height: 30,
                color: '#ff0000', // Red
                shootInterval: 2.5, // Cooldown for the entire burst
                movePattern: 'horizontal',
                moveSpeed: 1,
                health: 100,
                skillType: 'rapidFire', // Changed to rapidFire
                rapidFireCount: 3, // Number of bullets in burst
                rapidFireDelay: 0.15, // Delay between bullets in burst
                lastRapidFireBulletTime: 0, // To track delay between bullets in a burst
                bulletsShotInBurst: 0, // Counter for bullets in current burst
                inspiration: {
                    en: "Rapid-fire energy blasts, like a basic Ki Blast from Dragon Ball or a magic missile from various fantasy anime.",
                    vi: "Những luồng năng lượng bắn nhanh, giống như Ki Blast cơ bản trong Dragon Ball hoặc tên lửa ma thuật trong nhiều anime giả tưởng."
                }
            },
            charger: { // New enemy type with charge skill
                width: 35,
                height: 35,
                color: '#ffa500', // Orange
                shootInterval: 2.0, // Less frequent regular shots
                movePattern: 'chase', // Will chase when not charging
                moveSpeed: 0.8,
                health: 120,
                skillType: 'charge',
                skillInterval: 4, // Charge every 4 seconds
                chargeSpeed: 8, // Fast charge speed
                chargeDuration: 0.5, // How long the charge lasts
                chargeCooldown: 2, // Cooldown after charge
                inspiration: {
                    en: "A powerful, direct charge attack, similar to Luffy's Jet Pistol/Gatling from One Piece or charging attacks from mecha anime.",
                    vi: "Một đòn tấn công lao tới trực diện mạnh mẽ, tương tự Jet Pistol/Gatling của Luffy trong One Piece hoặc các đòn tấn công lao tới trong anime Mecha."
                }
            },
            scatter: { // New enemy type with scatter shot skill
                width: 40,
                height: 40,
                color: '#8a2be2', // BlueViolet
                shootInterval: 1.5,
                movePattern: 'zigzag',
                moveSpeed: 0.7,
                health: 110,
                skillType: 'scatterShot',
                skillInterval: 3, // Scatter shot every 3 seconds
                scatterCount: 12, // Number of bullets in scatter shot
                scatterSpeed: 4, // Speed of scatter bullets
                inspiration: {
                    en: "Danmaku (bullet hell) patterns from Touhou Project, or wide-area magic attacks like a 'Meteor Shower' spell from fantasy anime.",
                    vi: "Các kiểu bắn Danmaku (mưa đạn) từ Touhou Project, hoặc các đòn tấn công ma thuật diện rộng như phép 'Mưa Sao Băng' trong anime giả tưởng."
                }
            },
            wave: { // New enemy type: Wave Shooter
                width: 35,
                height: 35,
                color: '#00ccff', // Light Blue
                shootInterval: 2.5, // Slower regular shots
                movePattern: 'horizontal',
                moveSpeed: 0.9,
                health: 115,
                skillType: 'waveShot',
                skillInterval: 5, // Wave shot every 5 seconds
                waveCount: 8, // Base number of bullets in wave
                waveSpeed: 3, // Base speed of wave bullets
                waveDirection: 'horizontal', // Can be 'horizontal' or 'vertical'
                inspiration: {
                    en: "Energy wave attacks like Kamehameha from Dragon Ball or Hadoken from Street Fighter (anime adaptations), but as a series of projectiles.",
                    vi: "Các đòn tấn công sóng năng lượng như Kamehameha trong Dragon Ball hoặc Hadoken trong Street Fighter (chuyển thể anime), nhưng dưới dạng một loạt đạn."
                }
            },
            homing: { // New enemy type: Homing Shooter
                width: 30,
                height: 30,
                color: '#ff66b2', // Pink
                shootInterval: 1.8,
                movePattern: 'chase',
                moveSpeed: 0.6,
                health: 105,
                skillType: 'homingShot',
                skillInterval: 6, // Homing shot every 6 seconds
                homingSpeed: 2, // Base speed of homing bullet
                homingStrength: 0.05, // Base homing strength
                inspiration: {
                    en: "Relentless, tracking projectiles like Frieza's Death Beams from Dragon Ball Z or Itachi's Amaterasu from Naruto.",
                    vi: "Các loại đạn truy đuổi không ngừng như Death Beam của Frieza trong Dragon Ball Z hoặc Amaterasu của Itachi trong Naruto."
                }
            },
            hybrid: { // New enemy type: Hybrid Shooter
                width: 45,
                height: 45,
                color: '#800080', // Purple
                shootInterval: 0.5, // Faster overall interval, but cycles through attacks
                movePattern: 'chase', // Can chase player
                moveSpeed: 0.5,
                health: 250, // Higher health
                skillType: 'hybrid', // Special skill type
                attackPatterns: ['rapidFire', 'scatterShot', 'homingShot', 'waveShot'], // List of attacks it can use
                currentAttackIndex: 0,
                attackSwitchInterval: 3, // Switch attack every 3 seconds
                lastAttackSwitchTime: 0,
                inspiration: {
                    en: "A versatile foe, combining various attack styles like a skilled combatant from a shonen anime, adapting its strategy.",
                    vi: "Một kẻ thù đa năng, kết hợp nhiều phong cách tấn công khác nhau như một chiến binh tài ba trong anime shonen, liên tục thay đổi chiến thuật."
                }
            }
        };

        // --- Player Character Definitions ---
        const playerCharacters = {
            reimu: {
                name: "Reimu",
                color: '#00ffff', // Cyan
                baseSpeed: 4.5,
                focusSpeedMultiplier: 0.4,
                hitboxRadius: 2,
                initialRevives: 4, 
                activeSkills: [
                    { id: 'spiritualSealBurst', cooldown: 3.5, clearRadius: 200, damage: 50, description: { en: "Clears all bullets on screen and deals minor damage to nearby enemies.", vi: "Xóa tất cả đạn trên màn hình và gây sát thương nhỏ cho kẻ địch gần đó." } },
                    { id: 'illusoryDuplicate', cooldown: 10, duration: 5, numClones: 2, description: { en: "Creates temporary illusory duplicates that act as decoys and fire basic projectiles.", vi: "Tạo ra các bản sao ảo ảnh tạm thời hoạt động như mồi nhử và bắn đạn cơ bản." } }
                ],
                passive: { type: 'auraOfSerenity', value: 0.1, description: { en: "Slightly slows enemy bullets.", vi: "Làm chậm nhẹ đạn của kẻ thù." } },
                description: {
                    en: "Balanced stats. Active 1: Spiritual Seal Burst. Active 2: Illusory Duplicate. Passive: Aura of Serenity.",
                    vi: "Chỉ số cân bằng. Kỹ năng chủ động 1: Bùa Nổ Linh Hồn. Kỹ năng chủ động 2: Ảnh Phân Thân Ảo. Kỹ năng bị động: Hào Quang Thanh Tịnh."
                }
            },
            marisa: {
                name: "Marisa",
                color: '#ffcc00', // Gold
                baseSpeed: 6,
                focusSpeedMultiplier: 0.3,
                hitboxRadius: 2.5,
                initialRevives: 3, 
                activeSkills: [
                    { id: 'spiralOrbBarrage', cooldown: 7, speed: 10, radius: 25, damage: 200, piercing: true, description: { en: "Fires a large, slow, piercing energy orb dealing high damage.", vi: "Bắn ra một quả cầu năng lượng lớn, chậm, xuyên thấu gây sát thương cao." } },
                    { id: 'lightningDash', cooldown: 8, dashSpeed: 15, dashDuration: 0.5, invincibilityDuringDash: 0.6, damage: 150, description: { en: "Dashes forward with lightning speed, becoming invincible and damaging enemies in path.", vi: "Lao về phía trước với tốc độ chớp nhoáng, trở nên bất tử và gây sát thương cho kẻ địch trên đường đi." } }
                ],
                passive: { type: 'arcaneFlow', value: 0.2, description: { en: "Reduces skill cooldowns.", vi: "Giảm thời gian hồi chiêu của các kỹ năng." } },
                description: {
                    en: "High raw speed, offensive skill. Active 1: Spiral Orb Barrage. Active 2: Lightning Dash. Passive: Arcane Flow.",
                    vi: "Tốc độ di chuyển cao, kỹ năng tấn công. Kỹ năng chủ động 1: Cầu Xoắn Năng Lượng. Kỹ năng chủ động 2: Lao Tới Sét. Kỹ năng bị động: Dòng Chảy Bí Ẩn."
                }
            },
            sakuya: {
                name: "Sakuya",
                color: '#cccccc', // Silver
                baseSpeed: 3.5,
                focusSpeedMultiplier: 0.6,
                hitboxRadius: 1.5,
                initialRevives: 5, 
                activeSkills: [
                    { id: 'temporalBlink', cooldown: 4, dashDistance: 150, invincibilityDuration: 0.5, description: { en: "Performs a quick, short-distance teleport, granting brief invincibility.", vi: "Thực hiện một pha dịch chuyển tức thời nhanh, tầm ngắn, ban cho khả năng bất tử trong chốc lát." } },
                    { id: 'windBladeVolley', cooldown: 3, numProjectiles: 7, speed: 10, radius: 8, description: { en: "Fires multiple crescent-shaped air blades in a cone.", vi: "Bắn ra nhiều lưỡi gió hình lưỡi liềm theo hình nón." } }
                ],
                passive: { type: 'evasiveInsight', chance: 0.15, duration: 1.5, radius: 100, description: { en: "Chance to slow nearby bullets on successful dodge.", vi: "Có cơ hội làm chậm đạn gần đó khi né thành công." } },
                description: {
                    en: "Low speed, small hitbox for precision. Active 1: Temporal Blink. Active 2: Wind Blade Volley. Passive: Evasive Insight.",
                    vi: "Tốc độ thấp, hitbox nhỏ để né chính xác. Kỹ năng chủ động 1: Dịch Chuyển Thời Gian. Kỹ năng chủ động 2: Loạt Lưỡi Gió. Kỹ năng bị động: Trực Giác Né Tránh."
                }
            },
            youmu: { // New character
                name: "Youmu",
                color: '#90ee90', // Light Green
                baseSpeed: 4.5,
                focusSpeedMultiplier: 0.35,
                hitboxRadius: 2.2,
                initialRevives: 4, 
                activeSkills: [
                    { id: 'overdrivePulse', cooldown: 10, speedMultiplier: 1.8, bulletSlowMultiplier: 0.5, duration: 4, description: { en: "Greatly increases movement speed and slows enemy bullets for a short duration.", vi: "Tăng đáng kể tốc độ di chuyển và làm chậm đạn của kẻ thù trong thời gian ngắn." } },
                    { id: 'rapidStrikeFlurry', cooldown: 6, numProjectiles: 30, speed: 15, radius: 5, description: { en: "Unleashes a rapid-fire barrage of strikes in a wide arc.", vi: "Tung ra một loạt đòn tấn công liên hoàn tầm ngắn theo hình vòng cung rộng." } }
                ],
                passive: { type: 'resilientSpirit', chance: 0.1, duration: 1.0, description: { en: "Chance to gain brief invincibility when hit.", vi: "Có cơ hội nhận bất tử ngắn khi bị trúng đạn." } },
                description: {
                    en: "Balanced speed, excels in evasive maneuvers. Active 1: Overdrive Pulse. Active 2: Rapid Strike Flurry. Passive: Resilient Spirit.",
                    vi: "Tốc độ cân bằng, xuất sắc trong các pha né tránh. Kỹ năng chủ động 1: Xung Lực Quá Tải. Kỹ năng chủ động 2: Bão Đòn Đánh Nhanh. Kỹ năng bị động: Tinh Thần Kiên Cường."
                }
            },
            cirno: { // New character
                name: "Cirno",
                color: '#00bfff', // Deep Sky Blue
                baseSpeed: 3,
                focusSpeedMultiplier: 0.5,
                hitboxRadius: 3, // Larger hitbox
                initialRevives: 6, 
                activeSkills: [
                    { id: 'absoluteZeroForm', cooldown: 15, duration: 3, damageBoost: 0.5, invincibilityDuration: 3, description: { en: "Unleashes Absolute Zero Form, granting temporary invincibility, increased damage, and clearing bullets.", vi: "Giải phóng Dạng Tuyệt Đối Không, ban cho khả năng bất tử tạm thời, tăng sát thương và xóa đạn." } },
                    { id: 'glacialBeam', cooldown: 7, speed: 8, width: 30, length: 300, damage: 100, piercing: true, description: { en: "Fires a large, slow, piercing energy beam.", vi: "Bắn ra một tia năng lượng lớn, chậm, xuyên thấu." } }
                ],
                passive: { type: 'icyResilience', shieldDuration: 1.0, description: { en: "Gain a temporary shield after reviving.", vi: "Nhận một lá chắn tạm thời sau khi hồi sinh." } },
                description: {
                    en: "High revives, large hitbox. Active 1: Absolute Zero Form. Active 2: Glacial Beam. Passive: Icy Resilience.",
                    vi: "Nhiều mạng hồi sinh, hitbox lớn. Kỹ năng chủ động 1: Dạng Tuyệt Đối Không. Kỹ năng chủ động 2: Tia Băng Giá. Kỹ năng bị động: Băng Giá Kiên Cường."
                }
            }
        };
        let currentPlayerType = 'reimu'; // Default selected character

        // --- Player object (will be initialized based on selected character) ---
        const player = {
            x: CANVAS_WIDTH / 2,
            y: CANVAS_HEIGHT - 50,
            width: 20,
            height: 20,
            speed: 0, // Will be set by character
            focusSpeedMultiplier: 0, // Will be set by character
            color: '', // Will be set by character
            hitboxRadius: 0, // Will be set by character
            isFocusing: false,
            isDashing: false, // New flag for Marisa's Lightning Dash
            activeSkills: [], // Will store skill objects with lastUseTime
            passive: null, // Will be set by character
            damageBoostActive: false // For Cirno's Absolute Zero Form
        };

        // --- Keyboard input ---
        const keys = {
            ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false,
            KeyW: false, KeyA: false, KeyS: false, KeyD: false,
            ShiftLeft: false, ShiftRight: false,
            KeyZ: false, // For skill 1
            KeyX: false // For skill 2
        };

        // --- Keyboard event handling ---
        window.addEventListener('keydown', (e) => {
            if (keys.hasOwnProperty(e.code)) { keys[e.code] = true; }
            else if (keys.hasOwnProperty(e.key)) { keys[e.key] = true; }
            if (e.key === 'Escape' || e.code === 'Escape') { togglePause(); }

            // Handle Shift for focus
            if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') {
                player.isFocusing = true;
            }
            // Handle Z for skill 1
            if (e.code === 'KeyZ' && !e.repeat) { // !e.repeat prevents multiple triggers on hold
                useSkill(0); // Use first skill
            }
            // Handle X for skill 2
            if (e.code === 'KeyX' && !e.repeat) { // !e.repeat prevents multiple triggers on hold
                useSkill(1); // Use second skill
            }
        });

        window.addEventListener('keyup', (e) => {
            if (keys.hasOwnProperty(e.code)) { keys[e.code] = false; }
            else if (keys.hasOwnProperty(e.key)) { keys[e.key] = false; }

            // Handle Shift for focus
            if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') {
                player.isFocusing = false;
            }
        });

        // --- Joystick and mobile control handling ---
        let joystickActive = false;
        let joystickStartX = 0;
        let joystickStartY = 0;
        const joystickMaxDistance = 40; // Max distance handle can move from center

        joystickContainer.addEventListener('touchstart', (e) => {
            e.preventDefault(); // Prevent scrolling/zooming
            joystickActive = true;
            const touch = e.touches[0];
            const containerRect = joystickContainer.getBoundingClientRect();
            joystickStartX = containerRect.left + containerRect.width / 2;
            joystickStartY = containerRect.top + containerRect.height / 2;
            moveJoystick(touch.clientX, touch.clientY);
        });

        joystickContainer.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (joystickActive) {
                const touch = e.touches[0];
                moveJoystick(touch.clientX, touch.clientY);
            }
        });

        joystickContainer.addEventListener('touchend', (e) => {
            e.preventDefault();
            joystickActive = false;
            resetJoystick();
            // Reset player movement keys
            keys.ArrowUp = keys.ArrowDown = keys.ArrowLeft = keys.ArrowRight = false;
        });

        joystickContainer.addEventListener('touchcancel', (e) => {
            e.preventDefault();
            joystickActive = false;
            resetJoystick();
            // Reset player movement keys
            keys.ArrowUp = keys.ArrowDown = keys.ArrowLeft = keys.ArrowRight = false;
        });

        function moveJoystick(clientX, clientY) {
            const dx = clientX - joystickStartX;
            const dy = clientY - joystickStartY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const angle = Math.atan2(dy, dx);

            let limitedDx = dx;
            let limitedDy = dy;

            if (distance > joystickMaxDistance) {
                limitedDx = Math.cos(angle) * joystickMaxDistance;
                limitedDy = Math.sin(angle) * joystickMaxDistance;
            }

            joystickHandle.style.transform = `translate(${limitedDx}px, ${limitedDy}px)`;

            // Map joystick movement to player keys
            // Reset all movement keys first
            keys.ArrowUp = keys.ArrowDown = keys.ArrowLeft = keys.ArrowRight = false;

            // Determine direction based on joystick handle position
            if (limitedDy < -10) keys.ArrowUp = true;
            if (limitedDy > 10) keys.ArrowDown = true;
            if (limitedDx < -10) keys.ArrowLeft = true;
            if (limitedDx > 10) keys.ArrowRight = true;
        }

        function resetJoystick() {
            joystickHandle.style.transform = `translate(0, 0)`;
        }

        // Focus button for mobile
        focusButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            player.isFocusing = true;
        });
        focusButton.addEventListener('touchend', (e) => {
            e.preventDefault();
            player.isFocusing = false;
        });
        focusButton.addEventListener('touchcancel', (e) => {
            e.preventDefault();
            player.isFocusing = false;
        });

        // Skill buttons for mobile
        skill1Button.addEventListener('click', () => useSkill(0));
        skill2Button.addEventListener('click', () => useSkill(1));


        // --- Drawing functions ---
        function drawPlayer() {
            // Draw player as a square block
            ctx.fillStyle = player.color;
            ctx.fillRect(player.x - player.width / 2, player.y - player.height / 2, player.width, player.height);
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 1;
            ctx.strokeRect(player.x - player.width / 2, player.y - player.height / 2, player.width, player.height);

            // Draw small hitbox and make it blink when focusing or invincible
            if (player.isFocusing || isInvincible || (difficultyLevel >= 5 && score % 2 === 0)) {
                ctx.beginPath();
                ctx.arc(player.x, player.y, player.hitboxRadius, 0, Math.PI * 2);
                ctx.fillStyle = isInvincible ? 'rgba(0, 255, 255, 0.5)' : 'rgba(255, 0, 0, 0.7)'; // Cyan when invincible
                ctx.fill();
                ctx.strokeStyle = isInvincible ? 'rgba(255, 255, 255, 0.9)' : 'rgba(255, 255, 255, 0.9)';
                ctx.lineWidth = 1.5;
                ctx.stroke();
            }
        }

        // Bullet trail effect
        const bulletTrails = [];
        // Removed the old drawBullet function as it's replaced by the new one below
        // that handles different bullet types.

        function drawEnemy(enemy) {
            ctx.fillStyle = enemy.color;
            ctx.fillRect(enemy.x - enemy.width / 2, enemy.y - enemy.height / 2, enemy.width, enemy.height);
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.strokeRect(enemy.x - enemy.width / 2, enemy.y - enemy.height / 2, enemy.width, enemy.height);
        }

        function drawBoss(boss) {
            ctx.fillStyle = boss.color;
            ctx.fillRect(boss.x - boss.width / 2, boss.y - boss.height / 2, boss.width, boss.height);
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 3;
            ctx.strokeRect(boss.x - boss.width / 2, boss.y - boss.height / 2, boss.width, boss.height);
        }

        function updateBossHealthBar() {
            if (bossActive && boss) {
                const healthPercentage = (boss.health / boss.maxHealth) * 100;
                bossHealthBar.style.width = `${healthPercentage}%`;
                bossHealthBar.textContent = `${currentLanguage === 'en' ? 'BOSS HEALTH' : 'MÁU BOSS'} (${Math.round(healthPercentage)}%)`;
                bossHealthBarContainer.style.display = 'block';
            } else {
                bossHealthBarContainer.style.display = 'none';
            }
        }

        // --- Artifacts ---
        function createArtifact() {
            const type = Math.floor(Math.random() * 3); // 0: Slow, 1: Speed, 2: Clear
            const x = Math.random() * (CANVAS_WIDTH - 40) + 20;
            const y = Math.random() * (CANVAS_HEIGHT / 2 - 40) + 20; // Only appear in upper half of screen
            artifacts.push({
                x: x,
                y: y,
                radius: 15,
                color: type === 0 ? 'yellow' : (type === 1 ? 'lime' : 'orange'),
                type: type,
                life: 5 // Lasts 5 seconds
            });
        }

        function drawArtifact(artifact) {
            ctx.beginPath();
            ctx.arc(artifact.x, artifact.y, artifact.radius, 0, Math.PI * 2);
            ctx.fillStyle = artifact.color;
            ctx.fill();
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.fillStyle = 'black';
            ctx.font = '12px Inter';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            let text = '';
            if (artifact.type === 0) text = 'S'; // Slow
            else if (artifact.type === 1) text = 'F'; // Fast
            else text = 'C'; // Clear
            ctx.fillText(text, artifact.x, artifact.y);
        }

        function updateArtifacts(deltaTime) {
            for (let i = artifacts.length - 1; i >= 0; i--) {
                const artifact = artifacts[i];
                artifact.life -= deltaTime;
                if (artifact.life <= 0) {
                    artifacts.splice(i, 1);
                }
            }
        }

        // --- Particle System for Skill Effect ---
        function createParticle(x, y, color, size = Math.random() * 5 + 2, vx = (Math.random() - 0.5) * 10, vy = (Math.random() - 0.5) * 10, alpha = 1, decay = 0.05, shrink = 0.95) {
            particles.push({
                x: x,
                y: y,
                vx: vx,
                vy: vy,
                radius: size,
                color: color,
                alpha: alpha,
                decay: decay,
                shrink: shrink
            });
        }

        function updateParticles(deltaTime) {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx * deltaTime * 60; // Scale with deltaTime
                p.y += p.vy * deltaTime * 60;
                p.radius *= p.shrink;
                p.alpha -= p.decay;
                if (p.alpha <= 0.1 || p.radius <= 0.5) {
                    particles.splice(i, 1);
                }
            }
        }

        function drawParticles() {
            particles.forEach(p => {
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(${parseInt(p.color.slice(1, 3), 16)}, ${parseInt(p.color.slice(3, 5), 16)}, ${parseInt(p.color.slice(5, 7), 16)}, ${p.alpha})`;
                ctx.fill();
            });
        }

        // --- Update functions ---
        function updatePlayer(deltaTime) {
            // player.isFocusing is now controlled directly by event listeners (keyboard Shift or mobile focus button)
            const currentSpeed = player.isFocusing ? player.speed * player.focusSpeedMultiplier : player.speed;

            if (keys.ArrowUp || keys.KeyW) player.y -= currentSpeed;
            if (keys.ArrowDown || keys.KeyS) player.y += currentSpeed;
            if (keys.ArrowLeft || keys.KeyA) player.x -= currentSpeed;
            if (keys.ArrowRight || keys.KeyD) player.x += currentSpeed;

            player.x = Math.max(player.width / 2, Math.min(CANVAS_WIDTH - player.width / 2, player.x));
            player.y = Math.max(player.height / 2, Math.min(CANVAS_HEIGHT - player.height / 2, player.y));

            // Update invincibility status
            if (isInvincible) {
                invincibleTimer -= deltaTime;
                if (invincibleTimer <= 0) {
                    isInvincible = false;
                    player.color = playerCharacters[currentPlayerType].color; // Revert to original character color
                } else {
                    // Blinking effect when invincible
                    player.color = (Math.floor(invincibleTimer * 10) % 2 === 0) ? playerCharacters[currentPlayerType].color : '#ff00ff'; // Blink between character color and magenta
                }
            }

            // Apply pull effect from Abyssal Vortex if active
            darkZones.forEach(zone => {
                if (zone.state === 'active' && zone.type === 'vortex') {
                    const dx = zone.x - player.x;
                    const dy = zone.y - player.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance < zone.radius) {
                        const pullStrength = 0.5; // How strongly the player is pulled
                        player.x += dx / distance * pullStrength;
                        player.y += dy / distance * pullStrength;
                    }
                }
            });
        }

        function updateEnemyProjectiles(deltaTime) {
            let bulletSpeedMultiplier = 1.0;
            // Apply Youmu's Overdrive Pulse
            if (bulletSlowEffectActive) {
                bulletSpeedMultiplier *= playerCharacters.youmu.activeSkills[0].bulletSlowMultiplier;
            }
            // Apply Reimu's Aura of Serenity passive
            if (player.passive && player.passive.type === 'auraOfSerenity') {
                bulletSpeedMultiplier *= (1 - player.passive.value);
            }
            // Apply boss time stop
            if (bossTimeStopActive) {
                bulletSpeedMultiplier = 0; // Completely stop bullets
            }


            for (let i = enemyProjectiles.length - 1; i >= 0; i--) {
                const bullet = enemyProjectiles[i];
                
                // Handle homing bullets
                if (bullet.isHoming) {
                    const angleToPlayer = Math.atan2(player.y - bullet.y, player.x - bullet.x);
                    // Gradually adjust bullet's angle towards player
                    bullet.angle = bullet.angle + (angleToPlayer - bullet.angle) * bullet.homingStrength;
                    bullet.vx = Math.cos(bullet.angle) * bullet.speed;
                    bullet.vy = Math.sin(bullet.angle) * bullet.speed;
                }

                bullet.x += bullet.vx * bulletSpeedMultiplier;
                bullet.y += bullet.vy * bulletSpeedMultiplier;

                // Handle grenade explosion
                if (bullet.type === 'grenade' && bullet.y > bullet.explosionY) {
                    explodeGrenade(bullet);
                    enemyProjectiles.splice(i, 1);
                    continue; // Skip further processing for this bullet
                }

                // Remove bullets that go off-screen
                if (bullet.x < -bullet.radius || bullet.x > CANVAS_WIDTH + bullet.radius ||
                    bullet.y < -bullet.radius || bullet.y > CANVAS_HEIGHT + bullet.radius) {
                    enemyProjectiles.splice(i, 1);
                }
            }
        }

        function updatePlayerProjectiles() {
            for (let i = playerProjectiles.length - 1; i >= 0; i--) {
                const bullet = playerProjectiles[i];
                bullet.x += bullet.vx;
                bullet.y += bullet.vy;

                // Remove bullets that go off-screen
                if (bullet.x < -bullet.radius || bullet.x > CANVAS_WIDTH + bullet.radius ||
                    bullet.y < -bullet.radius || bullet.y > CANVAS_HEIGHT + bullet.radius) {
                    playerProjectiles.splice(i, 1);
                }
            }
        }

        // Added 'source' parameter to differentiate player bullets from enemy bullets
        function createBullet(x, y, angle, speed, radius, color, targetArray = enemyProjectiles, isHoming = false, homingStrength = 0, piercing = false, type = 'default', explosionY = null) {
            targetArray.push({
                x: x,
                y: y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                radius: radius,
                color: color,
                speed: speed, // Store original speed for passive effect
                angle: angle, // Store angle for homing
                isHoming: isHoming,
                homingStrength: homingStrength,
                piercing: piercing, // New property for piercing bullets
                type: type, // New property for bullet type
                explosionY: explosionY // For grenade type
            });
        }

        // --- Drawing for Anime-style Bullets ---
        function drawBullet(bullet) {
            ctx.save();
            ctx.translate(bullet.x, bullet.y);
            // Rotate to align with movement direction, assuming 0 is right, -PI/2 is up
            // Bullets are typically drawn "pointing" along their velocity vector.
            // If the default drawing assumes a vertical orientation (e.g., a knife pointing up),
            // then rotate by `bullet.angle + Math.PI / 2` to align it with the velocity vector.
            ctx.rotate(bullet.angle + Math.PI / 2); 
            
            switch (bullet.type) {
                case 'kiBlast': // Ki Blast (Basic Enemy) - Dragon Ball Z inspired
                    ctx.beginPath();
                    ctx.arc(0, 0, bullet.radius, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(${parseInt(bullet.color.slice(1, 3), 16)}, ${parseInt(bullet.color.slice(3, 5), 16)}, ${parseInt(bullet.color.slice(5, 7), 16)}, 0.8)`;
                    ctx.shadowColor = bullet.color;
                    ctx.shadowBlur = bullet.radius * 2;
                    ctx.fill();
                    ctx.shadowBlur = 0; // Reset shadow
                    // Add a small, brighter core
                    ctx.beginPath();
                    ctx.arc(0, 0, bullet.radius * 0.5, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(255, 255, 255, 0.7)`;
                    ctx.fill();
                    break;
                case 'magicMissile': // Magic Missile (Scatter Enemy) - Fantasy Anime inspired
                    ctx.fillStyle = bullet.color;
                    ctx.beginPath();
                    ctx.moveTo(0, -bullet.radius * 1.5); // Pointy top
                    ctx.lineTo(-bullet.radius * 0.8, bullet.radius * 0.5);
                    ctx.lineTo(bullet.radius * 0.8, bullet.radius * 0.5);
                    ctx.closePath();
                    ctx.fill();
                    ctx.shadowColor = bullet.color;
                    ctx.shadowBlur = bullet.radius;
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    // Add a small trail effect
                    ctx.fillStyle = `rgba(${parseInt(bullet.color.slice(1, 3), 16)}, ${parseInt(bullet.color.slice(3, 5), 16)}, ${parseInt(bullet.color.slice(5, 7), 16)}, 0.3)`;
                    ctx.fillRect(-bullet.radius * 0.5, bullet.radius * 0.5, bullet.radius, bullet.radius * 2); // Simple rectangular trail
                    break;
                case 'energyWave': // Energy Wave (Wave Enemy) - Kamehameha/Hadoken inspired
                    ctx.fillStyle = bullet.color;
                    ctx.beginPath();
                    ctx.ellipse(0, 0, bullet.radius * 1.5, bullet.radius * 0.8, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowColor = bullet.color;
                    ctx.shadowBlur = bullet.radius * 1.5;
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    // Add subtle inner lines to suggest energy flow
                    ctx.strokeStyle = `rgba(255,255,255,0.3)`;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(0, 0, bullet.radius * 0.7, 0, Math.PI * 2);
                    ctx.stroke();
                    break;
                case 'homingBeam': // Homing Beam (Homing Enemy) - Frieza/Itachi inspired
                    ctx.fillStyle = bullet.color;
                    ctx.fillRect(-bullet.radius * 0.2, -bullet.radius * 2, bullet.radius * 0.4, bullet.radius * 4);
                    ctx.shadowColor = bullet.color;
                    ctx.shadowBlur = bullet.radius * 2;
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    // Add a brighter core line
                    ctx.fillStyle = `rgba(255, 255, 255, 0.9)`;
                    ctx.fillRect(-bullet.radius * 0.1, -bullet.radius * 2, bullet.radius * 0.2, bullet.radius * 4);
                    break;
                case 'spiralOrb': // Marisa's Spiral Orb Barrage
                    ctx.beginPath();
                    ctx.arc(0, 0, bullet.radius, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(${parseInt(bullet.color.slice(1, 3), 16)}, ${parseInt(bullet.color.slice(3, 5), 16)}, ${parseInt(bullet.color.slice(5, 7), 16)}, 0.9)`;
                    ctx.shadowColor = bullet.color;
                    ctx.shadowBlur = bullet.radius * 2;
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    // Add swirling lines
                    ctx.strokeStyle = `rgba(255,255,255,0.7)`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, bullet.radius * 0.6, performance.now() * 0.02, performance.now() * 0.02 + Math.PI * 1.5);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.arc(0, 0, bullet.radius * 0.9, -performance.now() * 0.01, -performance.now() * 0.01 + Math.PI * 1.5);
                    ctx.stroke();
                    break;
                case 'windBlade': // Sakuya's Wind Blade Volley
                    ctx.fillStyle = bullet.color;
                    // Draw a crescent shape
                    ctx.beginPath();
                    ctx.arc(0, 0, bullet.radius * 1.5, Math.PI * 0.2, Math.PI * 0.8);
                    ctx.arc(0, 0, bullet.radius * 0.5, Math.PI * 0.8, Math.PI * 0.2, true);
                    ctx.closePath();
                    ctx.fill();
                    ctx.shadowColor = bullet.color;
                    ctx.shadowBlur = bullet.radius;
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    break;
                case 'strikeProjectile': // Youmu's Rapid Strike Flurry
                    ctx.fillStyle = bullet.color;
                    ctx.beginPath();
                    ctx.arc(0, 0, bullet.radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowColor = bullet.color;
                    ctx.shadowBlur = bullet.radius * 0.5;
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    // Draw a small fist icon (simplified)
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.fillRect(-bullet.radius * 0.4, -bullet.radius * 0.5, bullet.radius * 0.8, bullet.radius);
                    ctx.fillRect(bullet.radius * 0.2, -bullet.radius * 0.5, bullet.radius * 0.2, bullet.radius * 0.5);
                    break;
                case 'glacialBeam': // Cirno's Glacial Beam
                    ctx.fillStyle = bullet.color;
                    ctx.beginPath();
                    ctx.ellipse(0, 0, bullet.radius * 2, bullet.radius, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowColor = bullet.color;
                    ctx.shadowBlur = bullet.radius * 2;
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    // Add a bright core
                    ctx.beginPath();
                    ctx.ellipse(0, 0, bullet.radius * 1.2, bullet.radius * 0.6, 0, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(255, 255, 255, 0.7)`;
                    ctx.fill();
                    break;
                case 'illusoryCloneBullet': // Reimu's Illusory Duplicate bullets
                    ctx.beginPath();
                    ctx.arc(0, 0, bullet.radius, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(${parseInt(bullet.color.slice(1, 3), 16)}, ${parseInt(bullet.color.slice(3, 5), 16)}, ${parseInt(bullet.color.slice(5, 7), 16)}, 0.6)`;
                    ctx.fill();
                    ctx.strokeStyle = `rgba(255, 255, 255, 0.5)`;
                    ctx.lineWidth = 1;
                    ctx.stroke();
                    break;
                case 'fistOfFury': // Time Manipulator's Fist of Fury Barrage
                    ctx.fillStyle = bullet.color;
                    ctx.beginPath();
                    ctx.arc(0, 0, bullet.radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowColor = bullet.color;
                    ctx.shadowBlur = bullet.radius * 0.5;
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    // Small "fist" shape
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                    ctx.fillRect(-bullet.radius * 0.4, -bullet.radius * 0.5, bullet.radius * 0.8, bullet.radius);
                    break;
                case 'grenade': // Cid's Grenade
                    ctx.beginPath();
                    ctx.arc(0, 0, bullet.radius, 0, Math.PI * 2);
                    ctx.fillStyle = bullet.color; // Dark grey for grenade
                    ctx.fill();
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    // Add a small fuse
                    ctx.fillStyle = '#8B4513'; // Brown
                    ctx.fillRect(-bullet.radius * 0.1, -bullet.radius * 1.2, bullet.radius * 0.2, bullet.radius * 0.5);
                    break;
                case 'knife': // Dio's Knife
                    ctx.fillStyle = bullet.color; // Silver for knife
                    ctx.beginPath();
                    ctx.moveTo(0, -bullet.radius * 2); // Tip
                    ctx.lineTo(bullet.radius * 0.5, 0);
                    ctx.lineTo(0, bullet.radius * 2); // End of handle
                    ctx.lineTo(-bullet.radius * 0.5, 0);
                    ctx.closePath();
                    ctx.fill();
                    ctx.shadowColor = bullet.color;
                    ctx.shadowBlur = bullet.radius;
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    break;
                default: // Default bullet drawing (fallback)
                    ctx.beginPath();
                    ctx.arc(0, 0, bullet.radius, 0, Math.PI * 2);
                    ctx.fillStyle = bullet.color;
                    ctx.fill();
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                    break;
            }
            ctx.restore();
        }

        // --- New Boss Attack Types and Functions ---

        // Beams (Shadow Weaver) - Now with warning/active states
        function createBeamHazard(startX, startY, endX, endY, width, color, warningDuration, activeDuration) {
            beams.push({
                startX: startX,
                startY: startY,
                endX: endX,
                endY: endY,
                width: width,
                color: color,
                warningTimer: warningDuration,
                activeTimer: activeDuration,
                maxWarning: warningDuration, // Store max for opacity calculation
                maxActive: activeDuration, // Store max for opacity calculation
                state: 'warning' // 'warning' or 'active'
            });
        }

        function updateBeams(deltaTime) {
            for (let i = beams.length - 1; i >= 0; i--) {
                const beam = beams[i];
                // Apply boss time stop
                const effectiveDeltaTime = bossTimeStopActive ? 0 : deltaTime;

                if (beam.state === 'warning') {
                    beam.warningTimer -= effectiveDeltaTime;
                    if (beam.warningTimer <= 0) {
                        beam.state = 'active';
                        // Play a distinct sound when beam becomes active (optional)
                        // playBeamActiveSFX();
                    }
                } else if (beam.state === 'active') {
                    beam.activeTimer -= effectiveDeltaTime;
                    if (beam.activeTimer <= 0) {
                        beams.splice(i, 1);
                    }
                }
            }
        }

        function drawBeam(beam) {
            ctx.beginPath();
            ctx.lineWidth = beam.width;

            if (beam.state === 'warning') {
                // Blinking warning line
                const alpha = (Math.floor(performance.now() / 100) % 2 === 0) ? 0.2 : 0.8; // Blink effect
                ctx.strokeStyle = `rgba(255, 0, 0, ${alpha})`; // Red warning
                ctx.lineWidth = 2; // Thin warning line
            } else { // 'active' - Mana Beam
                ctx.strokeStyle = `rgba(${parseInt(beam.color.slice(1, 3), 16)}, ${parseInt(beam.color.slice(3, 5), 16)}, ${parseInt(beam.color.slice(5, 7), 16)}, ${0.7 * (beam.activeTimer / beam.maxActive)})`; // Reduced opacity
                ctx.lineWidth = beam.width;
                ctx.shadowColor = beam.color;
                ctx.shadowBlur = beam.width * 0.5;
                ctx.lineCap = 'round'; // Rounded ends for beams
            }

            ctx.moveTo(beam.startX, beam.startY);
            ctx.lineTo(beam.endX, beam.endY);
            ctx.stroke();
            ctx.shadowBlur = 0; // Reset shadow
            ctx.lineCap = 'butt'; // Reset line cap
        }

        // Dark Zones (Lich Overlord)
        function createDarkZone(x, y, radius, damage, warningDuration, activeDuration, color, type = 'static') {
            darkZones.push({
                x: x,
                y: y,
                radius: radius,
                damage: damage,
                warningTimer: warningDuration,
                activeTimer: activeDuration,
                maxWarning: warningDuration,
                maxActive: activeDuration,
                color: color,
                state: 'warning', // 'warning' or 'active'
                type: type, // 'static', 'expanding', 'shrinking', 'vortex'
                initialRadius: radius // Store for expanding/shrinking
            });
        }

        // New function for moving dark zones
        function createMovingDarkZone(x, y, radius, damage, warningDuration, activeDuration, color, targetX, targetY, moveSpeed) {
            darkZones.push({
                x: x,
                y: y,
                radius: radius,
                damage: damage,
                warningTimer: warningDuration,
                activeTimer: activeDuration,
                maxWarning: warningDuration,
                maxActive: activeDuration,
                color: color,
                state: 'warning',
                isMoving: true, // New flag
                targetX: targetX,
                targetY: targetY,
                moveSpeed: moveSpeed,
                vx: 0, // Will be calculated
                vy: 0,  // Will be calculated
                type: 'moving'
            });
        }

        function updateDarkZones(deltaTime) {
            for (let i = darkZones.length - 1; i >= 0; i--) {
                const zone = darkZones[i];
                // Apply boss time stop
                const effectiveDeltaTime = bossTimeStopActive ? 0 : deltaTime;

                if (zone.state === 'warning') {
                    zone.warningTimer -= effectiveDeltaTime;
                    if (zone.warningTimer <= 0) {
                        zone.state = 'active';
                    }
                } else if (zone.state === 'active') {
                    zone.activeTimer -= effectiveDeltaTime;
                    if (zone.isMoving) { // Handle movement for moving dark zones
                        const angleToTarget = Math.atan2(zone.targetY - zone.y, zone.targetX - zone.x);
                        zone.vx = Math.cos(angleToTarget) * (zone.moveSpeed * effectiveDeltaTime);
                        zone.vy = Math.sin(angleToTarget) * (zone.moveSpeed * effectiveDeltaTime);
                        zone.x += zone.vx;
                        zone.y += zone.vy;

                        // Stop if reached target or gone off screen
                        const distanceToTarget = Math.sqrt(Math.pow(zone.x - zone.targetX, 2) + Math.pow(zone.y - zone.targetY, 2));
                        if (distanceToTarget < zone.moveSpeed * effectiveDeltaTime * 2 || zone.x < -zone.radius || zone.x > CANVAS_WIDTH + zone.radius || zone.y < -zone.radius || zone.y > CANVAS_HEIGHT + zone.radius) {
                            zone.activeTimer = 0; // End active phase if target reached or off-screen
                        }
                    } else if (zone.type === 'expanding') {
                        // Expand over time
                        const progress = 1 - (zone.activeTimer / zone.maxActive);
                        zone.radius = zone.initialRadius + (zone.initialRadius * 0.5 * progress); // Expand to 1.5x initial size
                    } else if (zone.type === 'shrinking') {
                        // Shrink over time
                        const progress = 1 - (zone.activeTimer / zone.maxActive);
                        zone.radius = zone.initialRadius * (1 - 0.5 * progress); // Shrink to 0.5x initial size
                        zone.radius = Math.max(5, zone.radius); // Don't shrink to zero
                    }
                    zone.activeTimer -= effectiveDeltaTime;
                    if (zone.activeTimer <= 0) {
                        darkZones.splice(i, 1);
                    }
                }
            }
        }

        function drawDarkZone(zone) {
            ctx.beginPath();
            ctx.arc(zone.x, zone.y, zone.radius, 0, Math.PI * 2);
            if (zone.state === 'warning') {
                ctx.strokeStyle = `rgba(255, 255, 0, ${0.5 + Math.sin(performance.now() * 0.01) * 0.3})`; // Blinking yellow
                ctx.lineWidth = 3;
                ctx.stroke();
            } else { // 'active' - Abyssal Zone
                ctx.fillStyle = `rgba(${parseInt(zone.color.slice(1, 3), 16)}, ${parseInt(zone.color.slice(3, 5), 16)}, ${parseInt(zone.color.slice(5, 7), 16)}, ${0.7 * (zone.activeTimer / zone.maxActive)})`;
                ctx.shadowColor = zone.color;
                ctx.shadowBlur = zone.radius * 0.5;
                ctx.fill();
                ctx.shadowBlur = 0;
                // Add subtle swirling effect
                ctx.strokeStyle = `rgba(0,0,0,0.5)`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(zone.x, zone.y, zone.radius * 0.7, performance.now() * 0.005, performance.now() * 0.005 + Math.PI * 1.5);
                ctx.stroke();
            }
        }

        // Spectral Spikes (Spirit of Retribution)
        function createSpectralSpike(x, y, width, height, vx, vy, color, type = 'normal') {
            spectralSpikes.push({
                x: x,
                y: y,
                width: width,
                height: height,
                vx: vx,
                vy: vy,
                color: color,
                type: type // 'normal', 'spiral'
            });
        }

        function updateSpectralSpikes(deltaTime) {
            for (let i = spectralSpikes.length - 1; i >= 0; i--) {
                const spike = spectralSpikes[i];
                // Apply boss time stop
                const effectiveDeltaTime = bossTimeStopActive ? 0 : deltaTime;

                spike.x += spike.vx * effectiveDeltaTime * 60;
                spike.y += spike.vy * effectiveDeltaTime * 60;

                // Remove spikes when off-screen
                if (spike.x + spike.width < 0 || spike.x > CANVAS_WIDTH ||
                    spike.y + spike.height < 0 || spike.y > CANVAS_HEIGHT) {
                    spectralSpikes.splice(i, 1);
                }
            }
        }

        function drawSpectralSpike(spike) {
            ctx.fillStyle = spike.color;
            ctx.strokeStyle = 'rgba(0,0,0,0.8)';
            ctx.lineWidth = 2;

            // Draw a stylized bone shape (simplified)
            ctx.beginPath();
            ctx.moveTo(spike.x, spike.y + spike.height * 0.2);
            ctx.lineTo(spike.x + spike.width * 0.2, spike.y);
            ctx.lineTo(spike.x + spike.width * 0.8, spike.y);
            ctx.lineTo(spike.x + spike.width, spike.y + spike.height * 0.2);
            ctx.lineTo(spike.x + spike.width, spike.y + spike.height * 0.8);
            ctx.lineTo(spike.x + spike.width * 0.8, spike.y + spike.height);
            ctx.lineTo(spike.x + spike.width * 0.2, spike.y + spike.height);
            ctx.lineTo(spike.x, spike.y + spike.height * 0.8);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Add a subtle inner shadow/detail
            ctx.fillStyle = 'rgba(0,0,0,0.1)';
            ctx.beginPath();
            ctx.arc(spike.x + spike.width * 0.25, spike.y + spike.height * 0.25, spike.width * 0.1, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(spike.x + spike.width * 0.75, spike.y + spike.height * 0.25, spike.width * 0.1, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(spike.x + spike.width * 0.25, spike.y + spike.height * 0.75, spike.width * 0.1, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(spike.x + spike.width * 0.75, spike.y + spike.height * 0.75, spike.width * 0.1, 0, Math.PI * 2);
            ctx.fill();
        }

        // Phantom Blasters (Spirit of Retribution)
        function createPhantomBlaster(x, y, targetX, targetY, size, chargeDuration, fireDuration, color) {
            phantomBlasters.push({
                x: x,
                y: y,
                targetX: targetX,
                targetY: targetY,
                angle: Math.atan2(targetY - y, targetX - x),
                size: size, // Scale of the blaster
                chargeTimer: chargeDuration,
                fireTimer: fireDuration,
                maxCharge: chargeDuration,
                maxFire: fireDuration,
                color: color,
                state: 'charging' // 'charging', 'firing', 'cooldown'
            });
        }

        function updatePhantomBlasters(deltaTime) {
            for (let i = phantomBlasters.length - 1; i >= 0; i--) {
                const blaster = phantomBlasters[i];
                // Apply boss time stop
                const effectiveDeltaTime = bossTimeStopActive ? 0 : deltaTime;

                if (blaster.state === 'charging') {
                    blaster.chargeTimer -= effectiveDeltaTime;
                    if (blaster.chargeTimer <= 0) {
                        blaster.state = 'firing';
                        // Play blaster sound here
                    }
                } else if (blaster.state === 'firing') {
                    blaster.fireTimer -= effectiveDeltaTime;
                    if (blaster.fireTimer <= 0) {
                        phantomBlasters.splice(i, 1);
                    }
                }
            }
        }

        function drawPhantomBlaster(blaster) {
            ctx.save();
            ctx.translate(blaster.x, blaster.y);
            ctx.rotate(blaster.angle);

            const bodyWidth = blaster.size;
            const bodyHeight = blaster.size * 0.6;
            const headRadius = blaster.size * 0.4;
            const eyeSize = blaster.size * 0.1;

            // Blaster body (skull-like shape)
            ctx.fillStyle = blaster.color;
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;

            ctx.beginPath();
            ctx.ellipse(0, 0, bodyWidth * 0.5, bodyHeight * 0.5, 0, 0, Math.PI * 2); // Main body
            ctx.fill();
            ctx.stroke();

            // Head/Muzzle (front part)
            ctx.beginPath();
            ctx.arc(bodyWidth * 0.4, 0, headRadius, -Math.PI / 2, Math.PI / 2);
            ctx.lineTo(bodyWidth * 0.4, -headRadius);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Eye socket (simple circle)
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(bodyWidth * 0.2, -headRadius * 0.4, eyeSize, 0, Math.PI * 2);
            ctx.fill();

            if (blaster.state === 'charging') {
                // Draw charging effect in the eye
                const chargeProgress = 1 - (blaster.chargeTimer / blaster.maxCharge);
                ctx.fillStyle = `rgba(255, 255, 0, ${chargeProgress * 0.8})`;
                ctx.beginPath();
                ctx.arc(bodyWidth * 0.2, -headRadius * 0.4, eyeSize * 0.8 * chargeProgress, 0, Math.PI * 2);
                ctx.fill();
            } else if (blaster.state === 'firing') {
                // Draw laser beam from muzzle
                ctx.fillStyle = `rgba(0, 255, 255, ${blaster.fireTimer / blaster.maxFire})`; // Cyan laser
                ctx.shadowColor = `rgba(0, 255, 255, ${blaster.fireTimer / blaster.maxFire})`;
                ctx.shadowBlur = 15;
                ctx.fillRect(bodyWidth * 0.4 + headRadius, -blaster.size * 0.05, CANVAS_WIDTH, blaster.size * 0.1); // Long rectangle for laser
                ctx.shadowBlur = 0;
            }

            ctx.restore();
        }

        // Crushing Descent (Time Manipulator)
        function createCrushingDescent(x, y, width, height, vy, color) {
            crushingDescents.push({
                x: x,
                y: y,
                width: width,
                height: height,
                vy: vy,
                color: color
            });
        }

        function updateCrushingDescents(deltaTime) {
            for (let i = crushingDescents.length - 1; i >= 0; i--) {
                const roller = crushingDescents[i];
                // Apply boss time stop
                const effectiveDeltaTime = bossTimeStopActive ? 0 : deltaTime;

                roller.y += roller.vy * effectiveDeltaTime * 60; // Move downwards

                if (roller.y > CANVAS_HEIGHT + roller.height) {
                    crushingDescents.splice(i, 1); // Remove when off-screen
                }
            }
        }

        function drawCrushingDescent(roller) {
            ctx.fillStyle = roller.color;
            ctx.strokeStyle = '#333333';
            ctx.lineWidth = 3;

            // Main body of the road roller (simplified rectangle)
            ctx.fillRect(roller.x, roller.y, roller.width, roller.height);
            ctx.strokeRect(roller.x, roller.y, roller.width, roller.height);

            // Wheels (simplified circles)
            ctx.beginPath();
            ctx.arc(roller.x + roller.width * 0.2, roller.y + roller.height, roller.height * 0.3, 0, Math.PI * 2);
            ctx.fillStyle = '#555555';
            ctx.fill();
            ctx.stroke();

            ctx.beginPath();
            ctx.arc(roller.x + roller.width * 0.8, roller.y + roller.height, roller.height * 0.3, 0, Math.PI * 2);
            ctx.fillStyle = '#555555';
            ctx.fill();
            ctx.stroke();

            // Cabin (small rectangle on top)
            ctx.fillStyle = '#880000'; // Dark red
            ctx.fillRect(roller.x + roller.width * 0.6, roller.y - roller.height * 0.3, roller.width * 0.3, roller.height * 0.3);
            ctx.strokeRect(roller.x + roller.width * 0.6, roller.y - roller.height * 0.3, roller.width * 0.3, roller.height * 0.3);
        }


        // --- Enemy and Boss logic ---
        function createEnemy(enemyType) {
            const type = enemyTypes[enemyType];
            const x = Math.random() * (CANVAS_WIDTH - type.width) + type.width / 2;
            const y = Math.random() * (CANVAS_HEIGHT / 4) + type.height / 2; // Spawn in upper quarter
            enemies.push({
                x: x,
                y: y,
                width: type.width,
                height: type.height,
                color: type.color,
                shootInterval: type.shootInterval,
                lastShotTime: 0,
                movePattern: type.movePattern,
                moveSpeed: type.moveSpeed || 0,
                health: type.health,
                maxHealth: type.health,
                moveDirection: (Math.random() > 0.5) ? 1 : -1, // Initial direction for horizontal/zigzag
                skillType: type.skillType, // New: skill type
                skillInterval: type.skillInterval, // New: skill interval
                lastSkillTime: 0, // New: last skill time
                isCharging: false, // For charger enemy
                chargeTimer: 0,
                chargeTargetX: 0,
                chargeTargetY: 0,
                originalColor: type.color, // Store original color for frozen effect
                // For rapidFire
                rapidFireCount: type.rapidFireCount || 0,
                rapidFireDelay: type.rapidFireDelay || 0,
                lastRapidFireBulletTime: 0,
                bulletsShotInBurst: 0,
                // For wave shooter
                waveDirection: type.waveDirection || null,
                // For homing shooter
                homingBullet: null, // To store the single homing bullet
                // For hybrid enemy
                attackPatterns: type.attackPatterns || [],
                currentAttackIndex: 0,
                attackSwitchInterval: type.attackSwitchInterval || 0,
                lastAttackSwitchTime: 0
            });
        }

        // Helper functions for enemy specific attacks
        function shootRapidFire(entity, deltaTime) {
            if (entity.bulletsShotInBurst > 0) { // If a burst is active
                entity.lastRapidFireBulletTime += deltaTime;
                if (entity.lastRapidFireBulletTime >= entity.rapidFireDelay) {
                    entity.lastRapidFireBulletTime = 0;
                    const bulletSpeed = 4 + difficultyLevel * 0.2; // Faster bullets
                    const bulletRadius = 5 + difficultyLevel * 0.1;
                    const bulletColor = '#ff0000'; // Red for basic
                    const angleToPlayer = Math.atan2(player.y - entity.y, player.x - entity.x);
                    createBullet(entity.x, entity.y + entity.height / 2, angleToPlayer, bulletSpeed, bulletRadius, bulletColor, enemyProjectiles, false, 0, false, 'kiBlast'); // Added type
                    entity.bulletsShotInBurst--;
                }
            } else if (entity.lastShotTime >= entity.shootInterval) { // Start a new burst
                entity.lastShotTime = 0;
                entity.bulletsShotInBurst = entity.rapidFireCount;
                entity.lastRapidFireBulletTime = 0; // Reset for the new burst
            }
        }

        function shootScatterShot(entity, deltaTime) {
            if (entity.lastSkillTime >= entity.skillInterval) {
                entity.lastSkillTime = 0;
                const numBullets = enemyTypes.scatter.scatterCount + Math.floor(difficultyLevel / 3); // Scale with difficulty
                const bulletSpeed = enemyTypes.scatter.scatterSpeed + difficultyLevel * 0.2; // Scale with difficulty
                const bulletRadius = 7;
                const bulletColor = '#ff00ff'; // Magenta for scatter bullets
                
                for (let p = 0; p < 5; p++) {
                    createParticle(entity.x, entity.y, bulletColor);
                }

                const startAngle = Math.atan2(player.y - entity.y, player.x - entity.x) - (Math.PI / 4);
                const endAngle = startAngle + (Math.PI / 2);
                for (let i = 0; i < numBullets; i++) {
                    const angle = startAngle + (i / (numBullets - 1)) * (endAngle - startAngle);
                    createBullet(entity.x, entity.y + entity.height / 2, angle, bulletSpeed, bulletRadius, bulletColor, enemyProjectiles, false, 0, false, 'magicMissile'); // Added type
                }
            }
        }

        function shootWaveShot(entity, deltaTime) {
            if (entity.lastSkillTime >= entity.skillInterval) {
                entity.lastSkillTime = 0;
                const numBullets = enemyTypes.wave.waveCount + Math.floor(difficultyLevel / 2);
                const bulletSpeed = enemyTypes.wave.waveSpeed + difficultyLevel * 0.15;
                const bulletRadius = 8;
                const bulletColor = '#00ffff'; // Cyan for wave bullets

                const waveDirection = entity.waveDirection || (Math.random() > 0.5 ? 'horizontal' : 'vertical');

                if (waveDirection === 'horizontal') {
                    const startY = entity.y + entity.height / 2;
                    const spacing = CANVAS_WIDTH / (numBullets + 1);
                    for (let i = 0; i < numBullets; i++) {
                        const x = (i + 1) * spacing;
                        createBullet(x, startY, Math.PI / 2, bulletSpeed, bulletRadius, bulletColor, enemyProjectiles, false, 0, false, 'energyWave'); // Added type
                    }
                } else { // vertical
                    const startX = entity.x + entity.width / 2;
                    const spacing = CANVAS_HEIGHT / (numBullets + 1);
                    for (let i = 0; i < numBullets; i++) {
                        const y = (i + 1) * spacing;
                        createBullet(startX, y, 0, bulletSpeed, bulletRadius, bulletColor, enemyProjectiles, false, 0, false, 'energyWave'); // Added type
                    }
                    if (difficultyLevel >= 15) {
                        const secondStartX = CANVAS_WIDTH - startX;
                        for (let i = 0; i < numBullets; i++) {
                            const y = (i + 1) * spacing;
                            createBullet(secondStartX, y, Math.PI, bulletSpeed, bulletRadius, bulletColor, enemyProjectiles, false, 0, false, 'energyWave'); // Added type
                        }
                    }
                }
            }
        }

        function shootHomingShot(entity, deltaTime) {
            if (entity.lastSkillTime >= entity.skillInterval) {
                entity.lastSkillTime = 0;
                const bulletSpeed = enemyTypes.homing.homingSpeed + difficultyLevel * 0.1;
                const homingStrength = enemyTypes.homing.homingStrength + difficultyLevel * 0.005;
                const bulletRadius = 10;
                const bulletColor = '#ff66b2'; // Pink for homing bullets

                const angleToPlayer = Math.atan2(player.y - entity.y, player.x - entity.x);
                createBullet(entity.x, entity.y + entity.height / 2, angleToPlayer, bulletSpeed, bulletRadius, bulletColor, enemyProjectiles, true, homingStrength, false, 'homingBeam'); // Added type

                if (difficultyLevel >= 18) {
                    const numHoming = 2 + Math.floor((difficultyLevel - 18) / 2);
                    const spreadAngle = Math.PI / 6;
                    for (let i = 0; i < numHoming; i++) {
                        const angleOffset = (i - (numHoming - 1) / 2) * (spreadAngle / numHoming);
                        createBullet(entity.x, entity.y + entity.height / 2, angleToPlayer + angleOffset, bulletSpeed * 0.8, bulletRadius * 0.8, bulletColor, enemyProjectiles, true, homingStrength * 0.8, false, 'homingBeam'); // Added type
                    }
                }
            }
        }


        function updateEnemies(deltaTime) {
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];

                // Apply boss time stop
                const effectiveDeltaTime = bossTimeStopActive ? 0 : deltaTime;

                if (enemy.frozen) {
                    enemy.freezeTimer -= effectiveDeltaTime;
                    if (enemy.freezeTimer <= 0) {
                        enemy.frozen = false;
                        enemy.color = enemy.originalColor; // Revert color
                    } else {
                        // Skip movement and shooting if frozen
                        continue;
                    }
                }

                // Handle special skills
                if (enemy.skillType === 'charge') {
                    if (!enemy.isCharging && (enemy.lastSkillTime >= enemy.skillInterval)) {
                        // Start charge
                        enemy.isCharging = true;
                        enemy.chargeTimer = enemyTypes.charger.chargeDuration;
                        enemy.chargeTargetX = player.x; // Target player's current position
                        enemy.chargeTargetY = player.y;
                        enemy.lastSkillTime = 0; // Reset skill timer
                        enemy.color = '#ff0000'; // Indicate charging
                        // Emit particles when starting charge
                        for (let p = 0; p < 10; p++) {
                            createParticle(enemy.x, enemy.y, '#ffaa00'); // Orange particles
                        }
                    }

                    if (enemy.isCharging) {
                        // Move rapidly towards target
                        const angleToTarget = Math.atan2(enemy.chargeTargetY - enemy.y, enemy.chargeTargetX - enemy.x);
                        enemy.x += Math.cos(angleToTarget) * (enemyTypes.charger.chargeSpeed + difficultyLevel * 0.1) * effectiveDeltaTime; // Scale charge speed
                        enemy.y += Math.sin(angleToTarget) * (enemyTypes.charger.chargeSpeed + difficultyLevel * 0.1) * effectiveDeltaTime;
                        enemy.chargeTimer -= effectiveDeltaTime;
                        if (enemy.chargeTimer <= 0) {
                            enemy.isCharging = false;
                            enemy.color = enemy.originalColor; // Revert color
                            enemy.lastSkillTime = -enemyTypes.charger.chargeCooldown; // Apply cooldown
                            // Emit particles when ending charge
                            for (let p = 0; p < 10; p++) {
                                createParticle(enemy.x, enemy.y, '#ffff00'); // Yellow particles
                            }
                        }
                    } else {
                        // Regular movement when not charging
                        if (enemy.movePattern === 'horizontal') {
                            enemy.x += enemy.moveSpeed * enemy.moveDirection * effectiveDeltaTime;
                            if (enemy.x - enemy.width / 2 < 0 || enemy.x + enemy.width / 2 > CANVAS_WIDTH) {
                                enemy.moveDirection *= -1; // Reverse direction
                            }
                        } else if (enemy.movePattern === 'zigzag') {
                            enemy.x += enemy.moveSpeed * enemy.moveDirection * effectiveDeltaTime;
                            enemy.y += Math.sin(performance.now() * 0.005) * enemy.moveSpeed * 0.5 * effectiveDeltaTime; // Sine wave vertical movement
                            if (enemy.x - enemy.width / 2 < 0 || enemy.x + enemy.width / 2 > CANVAS_WIDTH) {
                                enemy.moveDirection *= -1;
                            }
                        }
                    }
                } else if (enemy.skillType === 'hybrid') { // New logic for hybrid enemy
                    enemy.lastAttackSwitchTime += effectiveDeltaTime;
                    enemy.lastShotTime += effectiveDeltaTime;
                    enemy.lastSkillTime += effectiveDeltaTime;

                    if (enemy.lastAttackSwitchTime >= enemy.attackSwitchInterval) {
                        enemy.currentAttackIndex = (enemy.currentAttackIndex + 1) % enemy.attackPatterns.length;
                        enemy.lastAttackSwitchTime = 0; // Reset timer for new switch
                        enemy.lastShotTime = 0; // Reset attack cooldown for new pattern
                        enemy.lastSkillTime = 0; // Reset skill cooldown for new pattern
                    }

                    const currentPattern = enemy.attackPatterns[enemy.currentAttackIndex];
                    switch (currentPattern) {
                        case 'rapidFire':
                            shootRapidFire(enemy, effectiveDeltaTime);
                            break;
                        case 'scatterShot':
                            shootScatterShot(enemy, effectiveDeltaTime);
                            break;
                        case 'homingShot':
                            shootHomingShot(enemy, effectiveDeltaTime);
                            break;
                        case 'waveShot':
                            shootWaveShot(enemy, effectiveDeltaTime);
                            break;
                    }

                    // Hybrid enemy movement (can be different from other types)
                    if (enemy.movePattern === 'chase') {
                        const angleToPlayer = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                        enemy.x += Math.cos(angleToPlayer) * enemy.moveSpeed * effectiveDeltaTime;
                        enemy.y += Math.sin(angleToPlayer) * enemy.moveSpeed * effectiveDeltaTime;
                    }

                } else {
                    // Regular enemy movement patterns for non-charging enemies
                    if (enemy.movePattern === 'horizontal') {
                        enemy.x += enemy.moveSpeed * enemy.moveDirection * effectiveDeltaTime;
                        if (enemy.x - enemy.width / 2 < 0 || enemy.x + enemy.width / 2 > CANVAS_WIDTH) {
                            enemy.moveDirection *= -1; // Reverse direction
                        }
                    } else if (enemy.movePattern === 'zigzag') {
                        enemy.x += enemy.moveSpeed * enemy.moveDirection * effectiveDeltaTime;
                        enemy.y += Math.sin(performance.now() * 0.005) * enemy.moveSpeed * 0.5 * effectiveDeltaTime; // Sine wave vertical movement
                        if (enemy.x - enemy.width / 2 < 0 || enemy.x + enemy.width / 2 > CANVAS_WIDTH) {
                            enemy.moveDirection *= -1;
                        }
                    } else if (enemy.movePattern === 'chase') {
                        const angleToPlayer = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                        enemy.x += Math.cos(angleToPlayer) * enemy.moveSpeed * effectiveDeltaTime;
                        enemy.y += Math.sin(angleToPlayer) * enemy.moveSpeed * effectiveDeltaTime;
                    }
                    // Regular enemies still shoot bullets if not hybrid or charging
                    enemyShootDispatcher(enemy, effectiveDeltaTime, enemy.skillType);
                }


                // Clamp enemy position to canvas bounds
                enemy.x = Math.max(enemy.width / 2, Math.min(CANVAS_WIDTH - enemy.width / 2, enemy.x));
                enemy.y = Math.max(enemy.height / 2, Math.min(CANVAS_HEIGHT / 2 - enemy.height / 2, enemy.y)); // Keep enemies in upper half

                // Check if enemy is defeated
                if (enemy.health <= 0) {
                    enemies.splice(i, 1);
                    score += 20; // Reward for defeating enemy
                    playBossHitSFX(); // Use boss hit SFX for enemy defeat
                }
            }
        }

        // Dispatcher function for enemy shooting (excluding hybrid which has its own logic)
        function enemyShootDispatcher(entity, deltaTime, skillType) {
            entity.lastShotTime += deltaTime;
            entity.lastSkillTime += deltaTime;

            if (skillType === 'rapidFire') {
                shootRapidFire(entity, deltaTime);
            } else if (skillType === 'scatterShot') {
                shootScatterShot(entity, deltaTime);
            } else if (skillType === 'waveShot') {
                shootWaveShot(entity, deltaTime);
            } else if (skillType === 'homingShot') {
                shootHomingShot(entity, deltaTime);
            }
            // Charger enemy doesn't shoot regular bullets while charging, handled in updateEnemies
        }


        function createBoss() {
            currentBossPhaseIndex = 0; // Start at phase 0
            const initialPhase = BOSS_PHASES[currentBossPhaseIndex];
            boss = {
                x: CANVAS_WIDTH / 2,
                y: 100,
                width: 80,
                height: 80,
                color: '#ff4500', // OrangeRed
                health: initialPhase.maxHealth,
                maxHealth: initialPhase.maxHealth,
                shootInterval: initialPhase.shootInterval,
                lastShotTime: 0,
                moveSpeed: 2, // Boss horizontal movement speed
                moveDirection: 1 // 1 for right, -1 for left
            };
            bossActive = true;
            enemies.length = 0; // Clear regular enemies (INTENTIONAL GAME DESIGN)
            enemyProjectiles.length = 0; // Clear existing bullets
            playerProjectiles.length = 0; // Clear player bullets
            bulletTrails.length = 0;
            artifacts.length = 0; // Clear artifacts
            particles.length = 0;
            beams.length = 0; // Clear beams
            darkZones.length = 0; // Clear dark zones
            spectralSpikes.length = 0;
            phantomBlasters.length = 0;
            crushingDescents.length = 0; // Clear crushing descents
            bossTimeStopActive = false; // Reset boss time stop

            difficultyLevel = 1; // Reset difficulty for boss fight patterns
            difficultyDisplay.textContent = `${currentLanguage === 'en' ? 'Difficulty: BOSS PHASE' : 'Độ khó: BOSS GIAI ĐOẠN'} ${currentBossPhaseIndex + 1}`;
            lastBossDamageTime = performance.now(); // Reset damage timer
            updateBossHealthBar();
        }

        function updateBoss(deltaTime) {
            if (!boss) return;

            // Boss movement (simple horizontal patrol) - ALWAYS MOVE UNLESS FROZEN by player skill
            if (!boss.frozen) {
                boss.x += boss.moveSpeed * boss.moveDirection * deltaTime;
                if (boss.x + boss.width / 2 > CANVAS_WIDTH || boss.x - boss.width / 2 < 0) {
                    boss.moveDirection *= -1; // Reverse direction
                }
            }

            // Always decrement boss's attack cooldown timer
            boss.lastShotTime += deltaTime;

            // Handle boss time stop (from its own Temporal Stasis skill)
            // This timer ALWAYS decrements, regardless of other states
            if (bossTimeStopActive) {
                bossTimeStopTimer -= deltaTime;
                if (bossTimeStopTimer <= 0) {
                    bossTimeStopActive = false;
                    // Time Manipulator performs an attack immediately after time stop ends
                    if (currentBossPhaseIndex === 3) { // Ensure it's the Time Manipulator
                        const patternRoll = Math.random();
                        if (patternRoll < 0.5) {
                            shootFistOfFuryBarrage(boss);
                        } else {
                            createCrushingDescent(Math.random() * (CANVAS_WIDTH - 100), -200, 100, 150, 2);
                        }
                    }
                }
            }

            // Handle boss frozen state (from player skills like Cirno's Absolute Zero Form)
            // This will affect boss's own attacks and damage over time
            let effectiveDeltaTimeForAttacks = deltaTime;
            if (boss.frozen) {
                boss.freezeTimer -= deltaTime; // Freeze timer always decrements
                if (boss.freezeTimer <= 0) {
                    boss.frozen = false;
                    boss.color = boss.originalColor;
                }
                effectiveDeltaTimeForAttacks = 0; // If frozen, no attacks, no damage over time
            }

            // Boss takes damage over time (survival damage) - ONLY IF NOT FROZEN
            if (!boss.frozen && performance.now() - lastBossDamageTime >= BOSS_DAMAGE_INTERVAL * 1000) {
                boss.health -= 100;
                lastBossDamageTime = performance.now();
                playBossHitSFX();
                console.log(`Boss health: ${boss.health}`);
            }

            // Check for phase transition
            const currentPhaseData = BOSS_PHASES[currentBossPhaseIndex];
            if (boss.health <= 0 && currentBossPhaseIndex < BOSS_PHASES.length - 1) {
                currentBossPhaseIndex++;
                const nextPhaseData = BOSS_PHASES[currentBossPhaseIndex];
                boss.maxHealth = nextPhaseData.maxHealth;
                boss.health = nextPhaseData.maxHealth; // Reset health for new phase
                boss.shootInterval = nextPhaseData.shootInterval;
                // Clear all boss-specific attacks on phase transition
                beams.length = 0;
                darkZones.length = 0;
                spectralSpikes.length = 0;
                phantomBlasters.length = 0;
                crushingDescents.length = 0;
                enemyProjectiles.length = 0;
                bulletTrails.length = 0;
                bossTimeStopActive = false; // Reset boss time stop

                difficultyDisplay.textContent = `${currentLanguage === 'en' ? 'Difficulty: BOSS PHASE' : 'Độ khó: BOSS GIAI ĐOẠN'} ${currentBossPhaseIndex + 1}`;
                playDifficultyUpSFX();
            } else if (boss.health <= 0 && currentBossPhaseIndex === BOSS_PHASES.length - 1) {
                gameWin();
                return;
            }

            // Boss attack patterns based on current phase
            // Only trigger attacks if not in own time stop and not frozen by player
            if (!bossTimeStopActive && !boss.frozen && boss.lastShotTime >= boss.shootInterval) { // Added boss.lastShotTime check here
                boss.lastShotTime = 0; // Reset cooldown ONLY when an attack is triggered
                bossAttack(boss, effectiveDeltaTimeForAttacks, currentBossPhaseIndex);
            }

            updateBossHealthBar();
        }

        // --- Boss Specific Attack Patterns ---
        function bossAttack(bossEntity, deltaTime, phaseIndex) {
            // The bossEntity.lastShotTime is now incremented in updateBoss, so we just check it here.
            // This function is only called if !bossTimeStopActive && !boss.frozen
            // So, we just need to check if it's time to shoot.

            // bossEntity.lastShotTime is reset to 0 in updateBoss right before calling this function
            // if it's time to attack. So we don't need to check bossEntity.lastShotTime here.
            // We just need to choose an attack.

            switch (phaseIndex) {
                case 0: // Shadow Weaver Phase (Cid): Energy Beams, Grenade Barrage
                    const patternRollP1 = Math.random();
                    if (patternRollP1 < 0.6) { // Existing beam attacks
                        const beamWidth = 8;
                        const beamLength = CANVAS_WIDTH * 1.5;
                        let warningDuration = 1.5;
                        let activeDuration = 1.8;
                        const beamColor = '#00ff00';

                        const subPatternRoll = Math.random();
                        if (subPatternRoll < 0.3) { // Horizontal sweeping beam (common)
                            const startY = Math.random() * (CANVAS_HEIGHT / 2) + 50;
                            const numSweeps = 2;
                            for (let i = 0; i < numSweeps; i++) {
                                addTimer('timeout', () => {
                                    createBeamHazard(0, startY + i * 40, CANVAS_WIDTH, startY + i * 40, beamWidth, beamColor, warningDuration, activeDuration);
                                }, i * 200);
                            }
                        } else if (subPatternRoll < 0.6) { // Aimed cross beams (common)
                            const angleToPlayer = Math.atan2(player.y - bossEntity.y, player.x - bossEntity.x);
                            createBeamHazard(bossEntity.x, bossEntity.y, bossEntity.x + Math.cos(angleToPlayer) * beamLength, bossEntity.y + Math.sin(angleToPlayer) * beamLength, beamWidth, beamColor, warningDuration, activeDuration);
                            createBeamHazard(bossEntity.x, bossEntity.y, bossEntity.x + Math.cos(angleToPlayer + Math.PI / 2) * beamLength, bossEntity.y + Math.sin(angleToPlayer + Math.PI / 2) * beamLength, beamWidth, beamColor, warningDuration, activeDuration);
                            createBeamHazard(bossEntity.x, bossEntity.y, bossEntity.x + Math.cos(angleToPlayer - Math.PI / 2) * beamLength, bossEntity.y + Math.sin(angleToPlayer - Math.PI / 2) * beamLength, beamWidth, beamColor, warningDuration, activeDuration);
                        } else if (subPatternRoll < 0.8) { // Converging Beams (new, moderate difficulty)
                            const numConvergingBeams = 3;
                            for (let i = 0; i < numConvergingBeams; i++) {
                                const startX = (i / (numConvergingBeams - 1)) * CANVAS_WIDTH;
                                const startY = (i % 2 === 0) ? 0 : CANVAS_HEIGHT;
                                addTimer('timeout', () => {
                                    createBeamHazard(startX, startY, player.x, player.y, beamWidth * 0.8, beamColor, warningDuration * 0.8, activeDuration * 0.8);
                                }, i * 150);
                            }
                        } else { // Grid Beams (new, harder, but scaled down)
                            const numGridLines = 3;
                            for (let i = 0; i < numGridLines; i++) {
                                // Horizontal
                                createBeamHazard(0, (i + 1) * (CANVAS_HEIGHT / (numGridLines + 1)), CANVAS_WIDTH, (i + 1) * (CANVAS_HEIGHT / (numGridLines + 1)), beamWidth * 0.7, beamColor, warningDuration * 0.7, activeDuration * 0.7);
                                // Vertical
                                createBeamHazard((i + 1) * (CANVAS_WIDTH / (numGridLines + 1)), 0, (i + 1) * (CANVAS_WIDTH / (numGridLines + 1)), CANVAS_HEIGHT, beamWidth * 0.7, beamColor, warningDuration * 0.7, activeDuration * 0.7);
                            }
                        }
                    } else { // New: Grenade Barrage (Cid)
                        shootGrenadeBarrage(bossEntity);
                    }
                    break;

                case 1: // Lich Overlord Phase (Overlord): Dark Zones, Abyssal Vortex
                    const zonePatternRollP2 = Math.random();
                    let zoneRadius = 50;
                    const zoneDamage = 1;
                    let warningDurationZone = 1.2;
                    let activeDurationZone = 2.5;
                    const zoneColor = '#330033';

                    if (zonePatternRollP2 < 0.5) { // Existing dark zone attacks
                        const subZonePatternRoll = Math.random();
                        if (subZonePatternRoll < 0.35) { // Static zones at player and random spots
                            createDarkZone(player.x, player.y, zoneRadius, zoneDamage, warningDurationZone, activeDurationZone, zoneColor);
                            const numRandomZones = 1;
                            for (let i = 0; i < numRandomZones; i++) {
                                const randX = Math.random() * CANVAS_WIDTH;
                                const randY = Math.random() * (CANVAS_HEIGHT - 100) + 50;
                                createDarkZone(randX, randY, zoneRadius * 0.7, zoneDamage, warningDurationZone * 0.8, activeDurationZone * 0.8, zoneColor);
                            }
                        } else if (subZonePatternRoll < 0.65) { // Moving dark zones
                            const numMovingZones = 1;
                            for (let i = 0; i < numMovingZones; i++) {
                                const startX = Math.random() * CANVAS_WIDTH;
                                const startY = Math.random() * (CANVAS_HEIGHT / 2);
                                const targetX = Math.random() * CANVAS_WIDTH;
                                const targetY = Math.random() * (CANVAS_HEIGHT / 2);
                                const moveSpeed = 30;
                                createMovingDarkZone(startX, startY, zoneRadius * 0.8, zoneDamage, warningDurationZone, activeDurationZone, zoneColor, targetX, targetY, moveSpeed);
                            }
                        } else if (subZonePatternRoll < 0.85) { // Expanding/Shrinking Zones (new)
                            const zoneType = Math.random() < 0.5 ? 'expanding' : 'shrinking';
                            const x = Math.random() * (CANVAS_WIDTH - zoneRadius * 2) + zoneRadius;
                            const y = Math.random() * (CANVAS_HEIGHT / 2 - zoneRadius * 2) + zoneRadius;
                            createDarkZone(x, y, zoneRadius, zoneDamage, warningDurationZone * 0.9, activeDurationZone * 0.9, zoneColor, zoneType);
                        } else { // Chaining Zones (new, slightly harder)
                            const numChains = 3;
                            for (let i = 0; i < numChains; i++) {
                                addTimer('timeout', () => {
                                    const x = Math.random() * (CANVAS_WIDTH - zoneRadius * 2) + zoneRadius;
                                    const y = Math.random() * (CANVAS_HEIGHT / 2 - zoneRadius * 2) + zoneRadius;
                                    createDarkZone(x, y, zoneRadius * 0.7, zoneDamage, warningDurationZone * 0.7, activeDurationZone * 0.7, zoneColor);
                                }, i * 500);
                            }
                        }
                    } else { // New: Abyssal Vortex (Overlord)
                        createAbyssalVortex(bossEntity);
                    }
                    break;

                case 2: // Spirit of Retribution Phase (Sans): Spectral Spikes, Phantom Blasters, Bone Walls, Gaster Blaster Barrage
                    const retributionPatternP3 = Math.random();
                    let spikeSpeed = 3;
                    let blasterSize = 40;
                    let blasterChargeDuration = 1.2;
                    let blasterFireDuration = 0.7;

                    if (retributionPatternP3 < 0.3) { // Spectral Spike attack (common)
                        const spikeWidth = 20;
                        const spikeHeight = 80;
                        const spikeColor = '#ffffff';

                        // Horizontal spike wall with gaps
                        const numSpikes = Math.floor(CANVAS_WIDTH / (spikeWidth + 40));
                        const gapPosition = Math.floor(Math.random() * (numSpikes - 1));
                        const startY = bossEntity.y + bossEntity.height / 2 + 50;

                        for (let i = 0; i < numSpikes; i++) {
                            if (i !== gapPosition && i !== gapPosition + 1) {
                                createSpectralSpike(i * (spikeWidth + 40), startY, spikeWidth, spikeHeight, 0, spikeSpeed, spikeColor);
                            }
                        }
                    } else if (retributionPatternP3 < 0.5) { // Phantom Blaster attack (common)
                        const blasterColor = '#3333ff';
                        createPhantomBlaster(bossEntity.x, bossEntity.y, player.x, player.y, blasterSize, blasterChargeDuration, blasterFireDuration, blasterColor);
                    } else if (retributionPatternP3 < 0.7) { // New: Bone Walls (Sans)
                        createBoneWall(bossEntity, Math.random() < 0.5); // Randomly vertical or horizontal
                    } else { // New: Gaster Blaster Barrage (Sans)
                        createGasterBlasterBarrage(bossEntity);
                    }
                    break;
                case 3: // Time Manipulator Phase (Dio): Crushing Descent, Fist of Fury Barrage, Temporal Stasis, Knife Throw
                    const timeManipulatorPatternP4 = Math.random();
                    if (timeManipulatorPatternP4 < 0.3) { // Fist of Fury Barrage
                        shootFistOfFuryBarrage(bossEntity);
                    } else if (timeManipulatorPatternP4 < 0.6) { // Crushing Descent
                        const rollerWidth = 120;
                        const rollerHeight = 180;
                        const rollerSpeed = 1.5 + difficultyLevel * 0.05;
                        const rollerColor = '#a0a0a0';
                        createCrushingDescent(Math.random() * (CANVAS_WIDTH - rollerWidth), -rollerHeight, rollerWidth, rollerHeight, rollerSpeed, rollerColor);
                    } else if (timeManipulatorPatternP4 < 0.8) { // Temporal Stasis
                        const timeStopDuration = 2 + difficultyLevel * 0.05;
                        activateBossTemporalStasis(bossEntity, timeStopDuration);
                    } else { // New: Knife Throw (Dio)
                        shootKnifeThrow(bossEntity);
                    }
                    break;
            }
        }

        // --- NEW BOSS ATTACK FUNCTIONS ---

        // Phase 1 (Cid) - Grenade Barrage
        function shootGrenadeBarrage(bossEntity) {
            const numGrenades = 3;
            const grenadeSpeed = 3; // Slower initial speed
            const grenadeRadius = 15;
            const grenadeColor = '#666666'; // Dark grey
            const explosionY = player.y - 100; // Explode above player

            for (let i = 0; i < numGrenades; i++) {
                const angle = Math.atan2(explosionY - bossEntity.y, player.x - bossEntity.x) + (Math.random() - 0.5) * (Math.PI / 8); // Aimed with slight spread
                addTimer('timeout', () => {
                    createBullet(bossEntity.x, bossEntity.y, angle, grenadeSpeed, grenadeRadius, grenadeColor, enemyProjectiles, false, 0, false, 'grenade', explosionY);
                }, i * 300); // Staggered launch
            }
            // Play a grenade launch SFX
            playGrenadeLaunchSFX();
        }

        function explodeGrenade(grenade) {
            const numShrapnel = 12 + Math.floor(difficultyLevel / 3);
            const shrapnelSpeed = 5 + difficultyLevel * 0.1;
            const shrapnelRadius = 5;
            const shrapnelColor = '#ff8c00'; // Dark orange for explosion

            for (let i = 0; i < numShrapnel; i++) {
                const angle = (i / numShrapnel) * Math.PI * 2;
                createBullet(grenade.x, grenade.y, angle, shrapnelSpeed, shrapnelRadius, shrapnelColor, enemyProjectiles, false, 0, false, 'kiBlast'); // Use kiBlast type for shrapnel
            }
            // Play an explosion SFX
            playExplosionSFX();
        }

        // Phase 2 (Overlord) - Abyssal Vortex
        function createAbyssalVortex(bossEntity) {
            const vortexRadius = 80 + difficultyLevel * 2; // Scales with difficulty
            const vortexDamage = 1;
            const warningDurationVortex = 1.8;
            const activeDurationVortex = 4;
            const vortexColor = '#1a001a'; // Very dark purple
            const vortexSpeed = 0.5 + difficultyLevel * 0.02; // Slow movement

            // Spawn vortex at boss's current position, moving towards player
            const angleToPlayer = Math.atan2(player.y - bossEntity.y, player.x - bossEntity.x);
            const targetX = bossEntity.x + Math.cos(angleToPlayer) * 200; // Target a point in player's direction
            const targetY = bossEntity.y + Math.sin(angleToPlayer) * 200;

            createMovingDarkZone(bossEntity.x, bossEntity.y, vortexRadius, vortexDamage, warningDurationVortex, activeDurationVortex, vortexColor, targetX, targetY, vortexSpeed);
            playVortexSFX();
        }

        // Phase 3 (Sans) - Bone Walls
        function createBoneWall(bossEntity, isVertical) {
            const boneWidth = 25;
            const boneHeight = 70;
            const boneColor = '#f0f0f0'; // Light grey
            const wallSpeed = 2 + difficultyLevel * 0.05;

            if (isVertical) {
                const numBones = Math.floor(CANVAS_HEIGHT / (boneHeight + 20));
                const gapPosition = Math.floor(Math.random() * (numBones - 1));
                const startX = Math.random() < 0.5 ? 0 : CANVAS_WIDTH - boneWidth; // From left or right

                for (let i = 0; i < numBones; i++) {
                    if (i !== gapPosition && i !== gapPosition + 1) { // Create a gap of 2 bones
                        createSpectralSpike(startX, i * (boneHeight + 20), boneWidth, boneHeight, startX === 0 ? wallSpeed : -wallSpeed, 0, boneColor);
                    }
                }
            } else { // Horizontal
                const numBones = Math.floor(CANVAS_WIDTH / (boneWidth + 20));
                const gapPosition = Math.floor(Math.random() * (numBones - 1));
                const startY = Math.random() < 0.5 ? 0 : CANVAS_HEIGHT - boneHeight; // From top or bottom

                for (let i = 0; i < numBones; i++) {
                    if (i !== gapPosition && i !== gapPosition + 1) { // Create a gap of 2 bones
                        createSpectralSpike(i * (boneWidth + 20), startY, boneWidth, boneHeight, 0, startY === 0 ? wallSpeed : -wallSpeed, boneColor);
                    }
                }
            }
            playBoneWallSFX();
        }

        // Phase 3 (Sans) - Gaster Blaster Barrage
        function createGasterBlasterBarrage(bossEntity) {
            const numBlasters = 3 + Math.floor(difficultyLevel / 5);
            const blasterSize = 35;
            const blasterChargeDuration = 0.8;
            const blasterFireDuration = 0.5;
            const blasterColor = '#00ffff'; // Cyan for Gaster Blasters

            for (let i = 0; i < numBlasters; i++) {
                const angleOffset = (i - (numBlasters - 1) / 2) * (Math.PI / 10); // Spread angle
                const targetAngle = Math.atan2(player.y - bossEntity.y, player.x - bossEntity.x) + angleOffset;
                addTimer('timeout', () => {
                    createPhantomBlaster(bossEntity.x, bossEntity.y, bossEntity.x + Math.cos(targetAngle) * 500, bossEntity.y + Math.sin(targetAngle) * 500, blasterSize, blasterChargeDuration, blasterFireDuration, blasterColor);
                }, i * 200); // Staggered firing
            }
            // Blaster SFX are handled in updatePhantomBlasters
        }

        // Phase 4 (Dio) - Fist of Fury Barrage
        function shootFistOfFuryBarrage(bossEntity) {
            const numPunches = 10 + Math.floor(difficultyLevel / 2);
            const punchSpeed = 10 + difficultyLevel * 0.2;
            const punchRadius = 6;
            const punchColor = '#ff0000'; // Red for Fist of Fury

            for (let i = 0; i < numPunches; i++) {
                const angle = Math.atan2(player.y - bossEntity.y, player.x - bossEntity.x) + (Math.random() - 0.5) * (Math.PI / 6); // Aimed with slight spread
                addTimer('timeout', () => {
                    createBullet(bossEntity.x, bossEntity.y, angle, punchSpeed, punchRadius, punchColor, enemyProjectiles, false, 0, false, 'fistOfFury');
                }, i * 50); // Rapid fire
            }
            playFistOfFurySFX();
        }

        // Phase 4 (Dio) - Temporal Stasis
        function activateBossTemporalStasis(bossEntity, duration) {
            bossTimeStopActive = true;
            bossTimeStopTimer = duration; // This timer will be decremented in updateBoss
            playTemporalStasisSFX();

            // Move boss to a new random position during time stop
            bossEntity.x = Math.random() * (CANVAS_WIDTH - bossEntity.width) + bossEntity.width / 2;
            bossEntity.y = Math.random() * (CANVAS_HEIGHT / 3 - bossEntity.height) + bossEntity.height / 2;
            
            // Clear all current player projectiles during boss time stop
            playerProjectiles.length = 0;
            bulletTrails.length = 0;
        }

        // Phase 4 (Dio) - Knife Throw
        function shootKnifeThrow(bossEntity) {
            const numKnives = 5 + Math.floor(difficultyLevel / 4);
            const knifeSpeed = 12 + difficultyLevel * 0.3;
            const knifeRadius = 8;
            const knifeColor = '#cccccc'; // Silver

            for (let i = 0; i < numKnives; i++) {
                const angle = Math.atan2(player.y - bossEntity.y, player.x - bossEntity.x) + (i - (numKnives - 1) / 2) * (Math.PI / 12); // Fan spread
                addTimer('timeout', () => {
                    createBullet(bossEntity.x, bossEntity.y, angle, knifeSpeed, knifeRadius, knifeColor, enemyProjectiles, false, 0, false, 'knife');
                }, i * 80); // Staggered throw
            }
            playKnifeThrowSFX();
        }


        // --- Collision detection (circle vs circle) ---
        function checkCollision(circle1, circle2) {
            const dx = circle1.x - circle2.x;
            const dy = circle1.y - circle2.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            return distance < circle1.radius + circle2.radius;
        }

        // Collision for Player (rectangle) and Beam (line segment)
        function checkBeamCollision(playerRect, beam) {
            // Only active beams cause damage
            if (beam.state !== 'active') return false;

            // Simplified line-rectangle collision: check if any of the beam's endpoints are inside the player
            // or if the beam crosses any of the player's rectangle sides.
            // For a thin beam, checking if the player's hitbox overlaps the beam's path is more accurate.
            // Approximate player as a circle for simpler collision with beam line.
            const playerCircle = { x: playerRect.x, y: playerRect.y, radius: playerRect.hitboxRadius };

            // Line segment (beam) defined by (x1, y1) to (x2, y2)
            const x1 = beam.startX;
            const y1 = beam.startY;
            const x2 = beam.endX;
            const y2 = beam.endY;

            // Closest point on the line segment to the player's circle center
            const lenSq = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
            let t = ((playerCircle.x - x1) * (x2 - x1) + (playerCircle.y - y1) * (y2 - y1)) / lenSq;
            t = Math.max(0, Math.min(1, t)); // Clamp t to [0, 1] for segment

            const closestX = x1 + t * (x2 - x1);
            const closestY = y1 + t * (y2 - y1);

            const dx = playerCircle.x - closestX;
            const dy = playerCircle.y - closestY;
            const distanceSq = dx * dx + dy * dy;

            // Check if distance to closest point on segment is less than player's radius + beam width/2
            return distanceSq < (playerCircle.radius + beam.width / 2) * (playerCircle.radius + beam.width / 2);
        }

        // Collision for Player (rectangle) and Dark Zone (circle)
        function checkDarkZoneCollision(playerRect, darkZone) {
            // Player is approximated as a circle for this collision
            const playerCircle = { x: playerRect.x, y: playerRect.y, radius: playerRect.hitboxRadius };
            const dx = playerCircle.x - darkZone.x;
            const dy = playerCircle.y - darkZone.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            return distance < playerCircle.radius + darkZone.radius;
        }

        // Collision for Player (rectangle) and Spectral Spike (rectangle)
        function checkSpectralSpikeCollision(playerRect, spikeRect) {
            // Player's actual rectangle bounds
            const pLeft = playerRect.x - playerRect.width / 2;
            const pRight = playerRect.x + playerRect.width / 2;
            const pTop = playerRect.y - playerRect.height / 2;
            const pBottom = playerRect.y + playerRect.height / 2;

            // Spike's rectangle bounds
            const sLeft = spikeRect.x;
            const sRight = spikeRect.x + spikeRect.width;
            const sTop = spikeRect.y;
            const sBottom = spikeRect.y + spikeRect.height;

            // Check for overlap
            return pLeft < sRight && pRight > sLeft && pTop < sBottom && pBottom > sTop;
        }

        // Collision for Player (rectangle) and Phantom Blaster laser (line)
        function checkPhantomBlasterCollision(playerRect, blaster) {
            if (blaster.state !== 'firing') return false;

            // Player's actual rectangle bounds
            const pLeft = playerRect.x - playerRect.width / 2;
            const pRight = playerRect.x + playerRect.width / 2;
            const pTop = playerRect.y - playerRect.height / 2;
            const pBottom = playerRect.y + playerRect.height / 2;

            // Laser is a line segment from blaster's muzzle to far end, rotated
            // For simplicity, let's assume the laser is a rectangle aligned with its angle
            // This is a complex geometric collision. For game purposes, approximate.
            // A simpler approach: check if player's hitbox (circle) intersects the laser's path.
            // The laser is a thick line. Treat it as a rectangle for collision.

            // Calculate laser end points in global coordinates
            const laserStartX = blaster.x + Math.cos(blaster.angle) * (blaster.size * 0.5);
            const laserStartY = blaster.y + Math.sin(blaster.angle) * (blaster.size * 0.5);
            const laserEndX = blaster.x + Math.cos(blaster.angle) * (blaster.size * 0.5 + CANVAS_WIDTH); // Extend far
            const laserEndY = blaster.y + Math.sin(blaster.angle) * (blaster.size * 0.5 + CANVAS_WIDTH);
            const laserWidth = blaster.size * 0.2; // Thickness of the laser

            // Create a simplified collision check for the laser as a fat line segment
            // using the same logic as checkBeamCollision, but with player's hitboxRadius
            const playerCircle = { x: playerRect.x, y: playerRect.y, radius: playerRect.hitboxRadius };

            const x1 = laserStartX;
            const y1 = laserStartY;
            const x2 = laserEndX;
            const y2 = laserEndY;

            const lenSq = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
            let t = ((playerCircle.x - x1) * (x2 - x1) + (playerCircle.y - y1) * (y2 - y1)) / lenSq;
            t = Math.max(0, Math.min(1, t)); // Clamp t to [0, 1] for segment

            const closestX = x1 + t * (x2 - x1);
            const closestY = y1 + t * (y2 - y1);

            const dx = playerCircle.x - closestX;
            const dy = playerCircle.y - closestY;
            const distanceSq = dx * dx + dy * dy;

            return distanceSq < (playerCircle.radius + laserWidth / 2) * (playerCircle.radius + laserWidth / 2);
        }

        // Collision for Player (rectangle) and Crushing Descent (rectangle)
        function checkCrushingDescentCollision(playerRect, rollerRect) {
            // Player's actual rectangle bounds
            const pLeft = playerRect.x - playerRect.width / 2;
            const pRight = playerRect.x + playerRect.width / 2;
            const pTop = playerRect.y - playerRect.height / 2;
            const pBottom = playerRect.y + playerRect.height / 2;

            // Roller's rectangle bounds
            const rLeft = rollerRect.x;
            const rRight = rollerRect.x + rollerRect.width;
            const rTop = rollerRect.y;
            const rBottom = rollerRect.y + rollerRect.height;

            // Check for overlap
            return pLeft < rRight && pRight > rLeft && pTop < rBottom && pBottom > rTop;
        }


        // --- Background music (using Tone.js) ---
        let synth;
        let bassSynth;
        let drumSynth;
        let reverb;
        let delay;
        let masterGain;
        let melodyLoop;
        let bassLoop;
        let drumLoop;
        let isMusicPlaying = false;

        function initMusic() {
            if (!synth) {
                // Ensure Tone.js context is started before creating nodes
                Tone.start().then(() => {
                    // Reverb and Delay effects
                    reverb = new Tone.Reverb(2).toDestination();
                    delay = new Tone.FeedbackDelay("8n", 0.5).toDestination();

                    // Synth for main melody
                    synth = new Tone.PolySynth(Tone.Synth, {
                        oscillator: { type: "triangle" },
                        envelope: { attack: 0.01, decay: 0.2, sustain: 0.4, release: 0.8 }
                    }).chain(reverb, delay, Tone.Destination);

                    // Synth for bassline
                    bassSynth = new Tone.Synth({
                        oscillator: { type: "sine" },
                        envelope: { attack: 0.01, decay: 0.1, sustain: 0.5, release: 1.2 }
                    }).chain(reverb, Tone.Destination);

                    // Synth for simple drums (kick and snare)
                    drumSynth = new Tone.MembraneSynth({
                        pitchDecay: 0.05,
                        octaves: 10,
                        envelope: {
                            attack: 0.001,
                            decay: 0.4,
                            sustain: 0.01,
                            release: 1.4,
                            attackCurve: "exponential"
                        }
                    }).toDestination();
                    drumSynth.volume.value = -10; // Reduce drum volume

                    masterGain = new Tone.Gain(0.4).toDestination();
                    synth.connect(masterGain);
                    bassSynth.connect(masterGain);
                    drumSynth.connect(masterGain);

                    // Main melody
                    const melodyNotes = [
                        "C4", "E4", "G4", "A4",
                        "G4", "E4", "C4", "F4",
                        "E4", "G4", "C5", "A4",
                        "G4", "E4", "D4", "C4"
                    ];
                    let melodyIndex = 0;
                    melodyLoop = new Tone.Loop((time) => {
                        synth.triggerAttackRelease(melodyNotes[melodyIndex % melodyNotes.length], "8n", time);
                        melodyIndex++;
                    }, "4n").start(0);

                    // Bassline
                    const bassNotes = ["C2", "C2", "F2", "F2", "G2", "G2", "C2", "C2"];
                    let bassIndex = 0;
                    bassLoop = new Tone.Loop((time) => {
                        bassSynth.triggerAttackRelease(bassNotes[bassIndex % bassNotes.length], "2n", time);
                        bassIndex++;
                    }, "2n").start(0);

                    // Simple drum beat
                    const drumPattern = [
                        ["C1"], [], ["C1"], [],
                        ["C1"], [], ["C1"], [],
                        ["C1"], [], ["C1"], [],
                        ["C1"], [], ["C1"], []
                    ]; // Kick drum on quarter notes
                    let drumIndex = 0;
                    drumLoop = new Tone.Sequence((time, note) => {
                        drumSynth.triggerAttackRelease(note, "16n", time);
                    }, drumPattern, "8n").start(0); // Every 1/8th note

                    Tone.Transport.bpm.value = 140;
                }).catch(e => console.error("Error starting Tone.js context:", e));
            }
        }

        async function toggleMusic() {
            if (Tone.context.state !== 'running') {
                await Tone.start();
            }
            initMusic(); // Ensure music components are initialized

            if (isMusicPlaying) {
                Tone.Transport.stop();
                musicToggleButton.textContent = texts[currentLanguage].toggleMusic;
                masterGain.gain.linearRampToValueAtTime(0, Tone.context.currentTime + 0.5);
            } else {
                Tone.Transport.start();
                musicToggleButton.textContent = texts[currentLanguage].toggleMusic;
                masterGain.gain.linearRampToValueAtTime(0.4, Tone.context.currentTime + 0.2);
            }
            isMusicPlaying = !isMusicPlaying;
        }

        // --- Sound effects (SFX) ---
        let hitSynth;
        let difficultyUpSynth;
        let artifactCollectSynth; // SFX for artifacts
        let skillActivateSynth; // SFX for skill
        let bossHitSynth; // SFX for boss taking damage
        let marisaSkillSynth; // SFX for Marisa's Spiral Orb
        let sakuyaSkillSynth; // SFX for Sakuya's Temporal Blink/Wind Blade
        let blasterChargeSFX; // New SFX for Phantom Blaster charge
        let blasterFireSFX; // New SFX for Phantom Blaster fire
        let lightningDashSFX; // New SFX for Marisa's Lightning Dash
        let windBladeSFX; // New SFX for Sakuya's Wind Blade Volley
        let rapidStrikeSFX; // New SFX for Youmu's Rapid Strike Flurry
        let glacialBeamSFX; // New SFX for Cirno's Glacial Beam
        let temporalStasisSFX; // New SFX for Time Manipulator's Temporal Stasis
        let fistOfFurySFX; // New SFX for Time Manipulator's Fist of Fury Barrage
        let grenadeLaunchSFX; // New SFX for Cid's Grenade Barrage
        let explosionSFX; // New SFX for grenade explosion
        let vortexSFX; // New SFX for Overlord's Abyssal Vortex
        let boneWallSFX; // New SFX for Sans' Bone Walls
        let knifeThrowSFX; // New SFX for Dio's Knife Throw


        function initSFX() {
            // Initialize only once
            if (!hitSynth) {
                Tone.start().then(() => { // Ensure context is running for SFX too
                    hitSynth = new Tone.NoiseSynth({
                        envelope: {
                            attack: 0.001,
                            decay: 0.1,
                            sustain: 0,
                            release: 0.1
                        },
                        noise: { type: 'white' }
                    }).toDestination();
                    hitSynth.volume.value = -10; // Reduce volume

                    difficultyUpSynth = new Tone.Synth({
                        oscillator: { type: 'square' },
                        envelope: { attack: 0.01, decay: 0.1, sustain: 0.0, release: 0.2 }
                    }).toDestination();
                    difficultyUpSynth.volume.value = -10; // Reduce volume

                    artifactCollectSynth = new Tone.Synth({
                        oscillator: { type: 'sine' },
                        envelope: { attack: 0.005, decay: 0.05, sustain: 0.0, release: 0.1 }
                    }).toDestination();
                    artifactCollectSynth.volume.value = -8; // Increase artifact SFX volume

                    skillActivateSynth = new Tone.PolySynth(Tone.Synth, {
                        oscillator: { type: "sawtooth" },
                        envelope: { attack: 0.01, decay: 0.05, sustain: 0.0, release: 0.2 }
                    }).toDestination();
                    skillActivateSynth.volume.value = -5;

                    bossHitSynth = new Tone.MembraneSynth({
                        pitchDecay: 0.02,
                        octaves: 5,
                        envelope: {
                            attack: 0.001,
                            decay: 0.2,
                            sustain: 0.01,
                            release: 0.5,
                            attackCurve: "exponential"
                        }
                    }).toDestination();
                    bossHitSynth.volume.value = -10;

                    marisaSkillSynth = new Tone.PolySynth(Tone.Synth, { // Now for Spiral Orb
                        oscillator: { type: "square" },
                        envelope: { attack: 0.005, decay: 0.1, sustain: 0.0, release: 0.3 }
                    }).toDestination();
                    marisaSkillSynth.volume.value = -7;

                    sakuyaSkillSynth = new Tone.PolySynth(Tone.Synth, { // Now for Temporal Blink/Wind Blade
                        oscillator: { type: "sine" },
                        envelope: { attack: 0.001, decay: 0.05, sustain: 0.0, release: 0.1 }
                    }).toDestination();
                    sakuyaSkillSynth.volume.value = -12;

                    // New SFX for Phantom Blaster
                    blasterChargeSFX = new Tone.Synth({
                        oscillator: { type: 'sawtooth' },
                        envelope: { attack: 0.01, decay: 0.5, sustain: 0.1, release: 0.2 }
                    }).toDestination();
                    blasterChargeSFX.volume.value = -15;

                    blasterFireSFX = new Tone.NoiseSynth({
                        envelope: {
                            attack: 0.001,
                            decay: 0.2,
                            sustain: 0,
                            release: 0.1
                        },
                        noise: { type: 'pink' }
                    }).toDestination();
                    blasterFireSFX.volume.value = -8;

                    lightningDashSFX = new Tone.Synth({ // For Marisa's Lightning Dash
                        oscillator: { type: 'triangle' },
                        envelope: { attack: 0.001, decay: 0.1, sustain: 0, release: 0.2 }
                    }).toDestination();
                    lightningDashSFX.volume.value = -8;

                    windBladeSFX = new Tone.PolySynth(Tone.Synth, { // For Sakuya's Wind Blade Volley
                        oscillator: { type: 'sawtooth' },
                        envelope: { attack: 0.001, decay: 0.05, sustain: 0, release: 0.1 }
                    }).toDestination();
                    windBladeSFX.volume.value = -10;

                    rapidStrikeSFX = new Tone.PolySynth(Tone.Synth, { // For Youmu's Rapid Strike Flurry
                        oscillator: { type: 'square' },
                        envelope: { attack: 0.001, decay: 0.05, sustain: 0, release: 0.1 }
                    }).toDestination();
                    rapidStrikeSFX.volume.value = -10;

                    glacialBeamSFX = new Tone.Synth({ // For Cirno's Glacial Beam
                        oscillator: { type: 'sine' },
                        envelope: { attack: 0.01, decay: 0.3, sustain: 0.1, release: 0.5 }
                    }).toDestination();
                    glacialBeamSFX.volume.value = -8;

                    temporalStasisSFX = new Tone.Synth({ // For Time Manipulator's Temporal Stasis
                        oscillator: { type: 'square' },
                        envelope: { attack: 0.001, decay: 0.5, sustain: 0.1, release: 0.8 }
                    }).toDestination();
                    temporalStasisSFX.volume.value = -10;

                    fistOfFurySFX = new Tone.PolySynth(Tone.Synth, { // For Time Manipulator's Fist of Fury Barrage
                        oscillator: { type: 'triangle' },
                        envelope: { attack: 0.001, decay: 0.02, sustain: 0, release: 0.05 }
                    }).toDestination();
                    fistOfFurySFX.volume.value = -12;

                    grenadeLaunchSFX = new Tone.Synth({ // For Cid's Grenade Launch
                        oscillator: { type: 'square' },
                        envelope: { attack: 0.01, decay: 0.1, sustain: 0, release: 0.1 }
                    }).toDestination();
                    grenadeLaunchSFX.volume.value = -10;

                    explosionSFX = new Tone.NoiseSynth({ // For Grenade Explosion
                        envelope: { attack: 0.001, decay: 0.3, sustain: 0, release: 0.2 },
                        noise: { type: 'brown' }
                    }).toDestination();
                    explosionSFX.volume.value = -8;

                    vortexSFX = new Tone.Synth({ // For Overlord's Abyssal Vortex
                        oscillator: { type: 'sawtooth' },
                        envelope: { attack: 0.5, decay: 1, sustain: 0.5, release: 1 }
                    }).toDestination();
                    vortexSFX.volume.value = -12;

                    boneWallSFX = new Tone.MembraneSynth({ // For Sans' Bone Walls
                        pitchDecay: 0.05,
                        octaves: 5,
                        envelope: { attack: 0.001, decay: 0.1, sustain: 0, release: 0.1 }
                    }).toDestination();
                    boneWallSFX.volume.value = -10;

                    knifeThrowSFX = new Tone.Synth({ // For Dio's Knife Throw
                        oscillator: { type: 'triangle' },
                        envelope: { attack: 0.001, decay: 0.05, sustain: 0, release: 0.05 }
                    }).toDestination();
                    knifeThrowSFX.volume.value = -15;

                }).catch(e => console.error("Error starting Tone.js context:", e));
            }
        }

        async function playHitSFX() {
            if (Tone.context.state !== 'running') await Tone.start();
            if (hitSynth) hitSynth.triggerAttackRelease("C3", "8n");
        }

        async function playDifficultyUpSFX() {
            if (Tone.context.state !== 'running') await Tone.start();
            if (difficultyUpSynth) {
                difficultyUpSynth.triggerAttackRelease("C5", "16n", Tone.now());
                difficultyUpSynth.triggerAttackRelease("G5", "16n", Tone.now() + 0.1);
            }
        }

        async function playArtifactCollectSFX() {
            if (Tone.context.state !== 'running') await Tone.start();
            if (artifactCollectSynth) {
                artifactCollectSynth.triggerAttackRelease("E6", "16n");
                artifactCollectSynth.triggerAttackRelease("G6", "16n", Tone.now() + 0.05);
            }
        }

        async function playSkillActivateSFX() {
            if (Tone.context.state !== 'running') await Tone.start();
            if (skillActivateSynth) skillActivateSynth.triggerAttackRelease(["C5", "E5", "G5"], "8n");
        }

        async function playBossHitSFX() {
            if (Tone.context.state !== 'running') await Tone.start();
            if (bossHitSynth) bossHitSynth.triggerAttackRelease("C2", "8n");
        }

        async function playMarisaSkillSFX() { // Now for Spiral Orb
            if (Tone.context.state !== 'running') await Tone.start();
            if (marisaSkillSynth) marisaSkillSynth.triggerAttackRelease(["C4", "E4", "G4", "C5"], "16n");
        }

        async function playSakuyaSkillSFX() { // Now for Temporal Blink/Wind Blade
            if (Tone.context.state !== 'running') await Tone.start();
            if (sakuyaSkillSynth) sakuyaSkillSynth.triggerAttackRelease(["A4", "F4", "D4"], "32n");
        }

        async function playBlasterChargeSFX() {
            if (Tone.context.state !== 'running') await Tone.start();
            if (blasterChargeSFX) blasterChargeSFX.triggerAttackRelease("C3", "1s");
        }

        async function playBlasterFireSFX() {
            if (Tone.context.state !== 'running') await Tone.start();
            if (blasterFireSFX) blasterFireSFX.triggerAttackRelease("8n");
        }

        async function playLightningDashSFX() { // For Marisa's Lightning Dash
            if (Tone.context.state !== 'running') await Tone.start();
            if (lightningDashSFX) lightningDashSFX.triggerAttackRelease("E5", "0.2s");
        }

        async function playWindBladeSFX() { // For Sakuya's Wind Blade Volley
            if (Tone.context.state !== 'running') await Tone.start();
            if (windBladeSFX) windBladeSFX.triggerAttackRelease(["D5", "F5", "A5"], "32n");
        }

        async function playRapidStrikeSFX() { // For Youmu's Rapid Strike Flurry
            if (Tone.context.state !== 'running') await Tone.start();
            if (rapidStrikeSFX) rapidStrikeSFX.triggerAttackRelease(["C4", "E4"], "64n");
        }

        async function playGlacialBeamSFX() { // For Cirno's Glacial Beam
            if (Tone.context.state !== 'running') await Tone.start();
            if (glacialBeamSFX) glacialBeamSFX.triggerAttackRelease("G3", "0.5s");
        }

        async function playTemporalStasisSFX() { // For Time Manipulator's Temporal Stasis
            if (Tone.context.state !== 'running') await Tone.start();
            if (temporalStasisSFX) temporalStasisSFX.triggerAttackRelease("C6", "0.5s");
        }

        async function playFistOfFurySFX() { // For Time Manipulator's Fist of Fury Barrage
            if (Tone.context.state !== 'running') await Tone.start();
            if (fistOfFurySFX) fistOfFurySFX.triggerAttackRelease("C4", "128n");
        }

        async function playGrenadeLaunchSFX() {
            if (Tone.context.state !== 'running') await Tone.start();
            if (grenadeLaunchSFX) grenadeLaunchSFX.triggerAttackRelease("G3", "0.1s");
        }

        async function playExplosionSFX() {
            if (Tone.context.state !== 'running') await Tone.start();
            if (explosionSFX) explosionSFX.triggerAttackRelease("0.3s");
        }

        async function playVortexSFX() {
            if (Tone.context.state !== 'running') await Tone.start();
            if (vortexSFX) vortexSFX.triggerAttackRelease("C2", "1s");
        }

        async function playBoneWallSFX() {
            if (Tone.context.state !== 'running') await Tone.start();
            if (boneWallSFX) boneWallSFX.triggerAttackRelease("C3", "0.1s");
        }

        async function playKnifeThrowSFX() {
            if (Tone.context.state !== 'running') await Tone.start();
            if (knifeThrowSFX) knifeThrowSFX.triggerAttackRelease("F5", "0.05s");
        }


        // --- Assist function ---
        function triggerAssist() {
            enemyProjectiles.length = 0; // Clear all bullets
            bulletTrails.length = 0; // Clear bullet trails
            beams.length = 0; // Clear boss attacks
            darkZones.length = 0;
            spectralSpikes.length = 0;
            phantomBlasters.length = 0;
            crushingDescents.length = 0; // Clear crushing descents
            isInvincible = true;
            let currentInvincibleDuration = INVINCIBLE_DURATION * 1.5;
            // Cirno's passive: Icy Resilience
            if (player.passive && player.passive.type === 'icyResilience') {
                currentInvincibleDuration += player.passive.shieldDuration; // Extend invincibility as a shield
            }
            invincibleTimer = currentInvincibleDuration;
            player.x = CANVAS_WIDTH / 2;
            player.y = CANVAS_HEIGHT - player.height / 2 - 30; // Move player to safe position relative to its height
            playDifficultyUpSFX(); // Play assist sound
            console.log("Assist Mode Activated!");
        }

        // --- Skill function ---
        function useSkill(skillIndex) {
            if (!gameRunning || gamePaused) return;
            
            const currentTime = performance.now() / 1000; // in seconds
            const skill = player.activeSkills[skillIndex];
            if (!skill) return; // Should not happen if skillIndex is 0 or 1

            let actualSkillCooldown = skill.cooldown;
            // Marisa's passive: Arcane Flow skill cooldown reduction
            if (player.passive && player.passive.type === 'arcaneFlow') {
                actualSkillCooldown *= (1 - player.passive.value);
            }

            if ((currentTime - skill.lastUseTime) >= actualSkillCooldown) {
                // Create particles for skill effect (general for all skills)
                for (let i = 0; i < 50; i++) {
                    createParticle(player.x, player.y, player.color);
                }

                switch (skill.id) {
                    case 'spiritualSealBurst': // Reimu Skill 1
                        enemyProjectiles.length = 0;
                        bulletTrails.length = 0;
                        beams.length = 0; // Clear boss attacks too
                        darkZones.length = 0;
                        spectralSpikes.length = 0;
                        phantomBlasters.length = 0;
                        crushingDescents.length = 0; // Clear crushing descents
                        // Add a visual burst effect
                        for (let i = 0; i < 100; i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const speed = Math.random() * 10 + 5;
                            createParticle(player.x, player.y, '#ff4500', Math.random() * 8 + 3, Math.cos(angle) * speed, Math.sin(angle) * speed, 1, 0.03, 0.9);
                        }
                        // Deal damage to nearby enemies/boss
                        enemies.forEach(enemy => {
                            const dx = player.x - enemy.x;
                            const dy = player.y - enemy.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            if (distance < skill.clearRadius) {
                                enemy.health -= skill.damage;
                            }
                        });
                        if (bossActive && boss) {
                            const dx = player.x - boss.x;
                            const dy = player.y - boss.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            if (distance < skill.clearRadius + Math.max(boss.width, boss.height) / 2) {
                                boss.health -= skill.damage * 0.5; // Less damage to boss
                            }
                        }
                        playSkillActivateSFX();
                        break;
                    case 'illusoryDuplicate': // Reimu Skill 2
                        const numClones = skill.numClones;
                        const cloneBulletSpeed = 5;
                        const cloneBulletRadius = 4;
                        const cloneColor = '#00ffff'; // Reimu's color
                        playSkillActivateSFX();

                        for (let i = 0; i < numClones; i++) {
                            const cloneX = player.x + (Math.random() - 0.5) * 100;
                            const cloneY = player.y + (Math.random() - 0.5) * 50;
                            // Create a temporary "clone" that shoots
                            addTimer('interval', () => { // Use addTimer
                                if (gameRunning && !gamePaused) {
                                    const angleToEnemy = Math.atan2(enemies[0]?.y - cloneY || boss?.y - cloneY, enemies[0]?.x - cloneX || boss?.x - cloneX);
                                    createBullet(cloneX, cloneY, angleToEnemy, cloneBulletSpeed, cloneBulletRadius, cloneColor, playerProjectiles, false, 0, false, 'illusoryCloneBullet');
                                }
                            }, 500); // Shoot every 0.5 seconds
                        }
                        // Clones will disappear after skill.duration
                        addTimer('timeout', () => {
                            // Logic to remove clones or stop their shooting (if implemented as actual objects)
                            // This implementation assumes the clones are just temporary shooting effects.
                        }, skill.duration * 1000);
                        break;
                    case 'spiralOrbBarrage': // Marisa Skill 1
                        playMarisaSkillSFX();
                        createBullet(player.x, player.y, -Math.PI / 2, skill.speed, skill.radius, '#0000ff', playerProjectiles, false, 0, skill.piercing, 'spiralOrb');
                        break;
                    case 'lightningDash': // Marisa Skill 2
                        playLightningDashSFX();
                        const dashTargetY = player.y - 200; // Dash upwards
                        const originalPlayerSpeed = player.speed;
                        player.speed = skill.dashSpeed; // Temporarily increase speed for dash
                        isInvincible = true;
                        invincibleTimer = skill.invincibilityDuringDash;
                        player.isDashing = true; // Set dashing flag

                        // Store the interval ID for cleanup
                        let lightningDashIntervalId = addTimer('interval', () => { // Use addTimer
                            if (player.y > dashTargetY && gameRunning && !gamePaused) {
                                player.y -= player.speed * (1/60); // Move frame by frame
                                // Clear bullets during dash and damage enemies
                                for (let i = enemyProjectiles.length - 1; i >= 0; i--) {
                                    const bullet = enemyProjectiles[i];
                                    const dx = player.x - bullet.x;
                                    const dy = player.y - bullet.y;
                                    const distance = Math.sqrt(dx * dx + dy * dy);
                                    if (distance < 50) { // Clear bullets in a small radius
                                        enemyProjectiles.splice(i, 1);
                                    }
                                }
                                enemies.forEach(enemy => {
                                    const dx = player.x - enemy.x;
                                    const dy = player.y - enemy.y;
                                    const distance = Math.sqrt(dx * dx + dy * dy);
                                    if (distance < player.width / 2 + enemy.width / 2) { // Collision with enemy
                                        enemy.health -= skill.damage * (1/60); // Continuous damage during dash
                                    }
                                });
                                if (bossActive && boss) {
                                    const dx = player.x - boss.x;
                                    const dy = player.y - boss.y;
                                    const distance = Math.sqrt(dx * dx + dy * dy);
                                    if (distance < player.width / 2 + boss.width / 2) {
                                        boss.health -= skill.damage * 0.5 * (1/60); // Continuous damage to boss
                                    }
                                }
                                // Add dash particles/afterimage
                                createParticle(player.x + (Math.random() - 0.5) * 10, player.y + (Math.random() - 0.5) * 10, player.color, Math.random() * 3 + 1, (Math.random() - 0.5) * 5, (Math.random() - 0.5) * 5, 0.5, 0.05, 0.9);
                            } else {
                                clearSpecificTimer(lightningDashIntervalId); // Clear this specific interval
                                player.speed = originalPlayerSpeed; // Revert speed
                                player.isDashing = false; // Reset dashing flag when dash ends
                            }
                        }, 1000 / 60); // 60 FPS update

                        addTimer('timeout', () => { // Use addTimer
                            isInvincible = false;
                        }, skill.invincibilityDuringDash * 1000);
                        break;
                    case 'temporalBlink': // Sakuya Skill 1
                        playSakuyaSkillSFX();
                        const dashAngle = -Math.PI / 2; // Always dash upwards for now
                        player.x += Math.cos(dashAngle) * skill.dashDistance;
                        player.y += Math.sin(dashAngle) * skill.dashDistance;
                        player.x = Math.max(player.width / 2, Math.min(CANVAS_WIDTH - player.width / 2, player.x));
                        player.y = Math.max(player.height / 2, Math.min(CANVAS_HEIGHT - player.height / 2, player.y));
                        isInvincible = true;
                        invincibleTimer = skill.invincibilityDuration;
                        break;
                    case 'windBladeVolley': // Sakuya Skill 2
                        playWindBladeSFX();
                        const numWindBlades = skill.numProjectiles;
                        const windBladeSpeed = skill.speed;
                        const windBladeRadius = skill.radius;
                        const windBladeColor = '#87ceeb'; // Light blue for air blades

                        for (let i = 0; i < numWindBlades; i++) {
                            const angle = -Math.PI / 2 + (i - (numWindBlades - 1) / 2) * (Math.PI / 6); // Cone spread
                            createBullet(player.x, player.y, angle, windBladeSpeed, windBladeRadius, windBladeColor, playerProjectiles, false, 0, false, 'windBlade');
                        }
                        break;
                    case 'overdrivePulse': // Youmu Skill 1
                        playSkillActivateSFX(); // General skill activate for Youmu
                        const originalYoumuSpeed = player.speed;
                        const originalBulletSlowActive = bulletSlowEffectActive;
                        const originalBulletSlowTimer = bulletSlowTimer;

                        player.speed *= skill.speedMultiplier;
                        bulletSlowEffectActive = true;
                        bulletSlowTimer = skill.duration;

                        addTimer('timeout', () => {
                            player.speed = originalYoumuSpeed;
                            bulletSlowEffectActive = originalBulletSlowActive;
                            bulletSlowTimer = originalBulletSlowTimer;
                        }, skill.duration * 1000);
                        break;
                    case 'rapidStrikeFlurry': // Youmu Skill 2
                        playRapidStrikeSFX();
                        const numRapidStrikes = skill.numProjectiles;
                        const rapidStrikeSpeed = skill.speed;
                        const rapidStrikeRadius = skill.radius;
                        const rapidStrikeColor = '#ff0000'; // Red for strikes

                        for (let i = 0; i < numRapidStrikes; i++) {
                            const angle = -Math.PI / 2 + (i - (numRapidStrikes - 1) / 2) * (Math.PI / 4); // Wide cone
                            addTimer('timeout', () => {
                                createBullet(player.x, player.y, angle, rapidStrikeSpeed, rapidStrikeRadius, rapidStrikeColor, playerProjectiles, false, 0, false, 'strikeProjectile');
                            }, i * 30); // Very rapid fire
                        }
                        break;
                    case 'absoluteZeroForm': // Cirno Skill 1
                        playSkillActivateSFX(); // General skill activate for Cirno
                        isInvincible = true;
                        invincibleTimer = skill.invincibilityDuration;
                        player.damageBoostActive = true; // Activate damage boost
                        // Clear all bullets and boss attacks
                        enemyProjectiles.length = 0;
                        bulletTrails.length = 0;
                        beams.length = 0;
                        darkZones.length = 0;
                        spectralSpikes.length = 0;
                        phantomBlasters.length = 0;
                        crushingDescents.length = 0;

                        // Visual effect for Absolute Zero Form
                        for (let i = 0; i < 150; i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const speed = Math.random() * 15 + 5;
                            createParticle(player.x, player.y, '#ffffff', Math.random() * 10 + 5, Math.cos(angle) * speed, Math.sin(angle) * speed, 1, 0.02, 0.9);
                        }

                        addTimer('timeout', () => {
                            player.damageBoostActive = false; // Deactivate damage boost
                        }, skill.duration * 1000);
                        break;
                    case 'glacialBeam': // Cirno Skill 2
                        playGlacialBeamSFX();
                        const glacialBeamSpeed = skill.speed;
                        const glacialBeamWidth = skill.width;
                        const glacialBeamLength = skill.length;
                        const glacialBeamDamage = skill.damage;
                        const glacialBeamColor = '#800080'; // Purple for Glacial Beam

                        // Create a temporary beam that moves with the player
                        const glacialBeam = {
                            startX: player.x,
                            startY: player.y,
                            endX: player.x,
                            endY: player.y - glacialBeamLength,
                            width: glacialBeamWidth,
                            color: glacialBeamColor,
                            activeTimer: 1.0, // Glacial Beam fires for a short duration
                            maxActive: 1.0,
                            state: 'active',
                            isPlayerSpark: true, // Custom property to identify
                            damage: glacialBeamDamage,
                            piercing: skill.piercing
                        };
                        beams.push(glacialBeam);
                        break;
                }

                skill.lastUseTime = currentTime; // Set last use time for cooldown
                updateSkillButtonState();
            }
        }

        function updateSkillButtonState() {
            const currentTime = performance.now() / 1000;
            
            player.activeSkills.forEach((skill, index) => {
                let actualSkillCooldown = skill.cooldown;
                if (player.passive && player.passive.type === 'arcaneFlow') {
                    actualSkillCooldown *= (1 - player.passive.value);
                }

                const timeSinceLastUse = currentTime - skill.lastUseTime;
                const button = index === 0 ? skill1Button : skill2Button;
                
                if (timeSinceLastUse < actualSkillCooldown) {
                    button.disabled = true;
                    const timeLeft = Math.ceil(actualSkillCooldown - timeSinceLastUse);
                    button.textContent = `${texts[currentLanguage][`skill${index + 1}`]}: (${timeLeft}s)`;
                } else {
                    button.disabled = false;
                    button.textContent = `${texts[currentLanguage][`skill${index + 1}`]}: ∞`;
                }
            });
            
            // Schedule next update to show countdown if any skill is on cooldown
            if (player.activeSkills.some(skill => (currentTime - skill.lastUseTime) < (player.passive && player.passive.type === 'arcaneFlow' ? skill.cooldown * (1 - player.passive.value) : skill.cooldown))) {
                addTimer('timeout', updateSkillButtonState, 1000); // Use addTimer
            }
        }


        // --- Pause/Resume game function ---
        function togglePause() {
            if (!gameRunning) return;

            gamePaused = !gamePaused;
            if (gamePaused) {
                pauseButton.textContent = texts[currentLanguage].resume;
                pausedOverlay.style.display = 'flex';
                if (isMusicPlaying) {
                    Tone.Transport.pause();
                    masterGain.gain.linearRampToValueAtTime(0, Tone.context.currentTime + 0.5);
                }
            } else {
                pauseButton.textContent = texts[currentLanguage].pause;
                pausedOverlay.style.display = 'none';
                lastFrameTime = performance.now();
                if (isMusicPlaying) {
                    Tone.Transport.start();
                    masterGain.gain.linearRampToValueAtTime(0.4, Tone.context.currentTime + 0.2);
                }
            }
            
            if (bulletSlowEffectActive) {
                bulletSlowEffectActive = false; // Reset bullet slow effect on pause
            }

            // Check for boss spawn
            if (!bossActive && score >= BOSS_SPAWN_SCORE) {
                createBoss();
            }

            // Update difficulty or boss
            if (!bossActive) {
                difficultyTimer += deltaTime;
                const difficultyIncreaseInterval = 4;
                if (difficultyTimer >= difficultyIncreaseInterval) {
                    difficultyLevel++;
                    difficultyTimer = 0;
                    difficultyDisplay.textContent = `${texts[currentLanguage].difficulty}: ${difficultyLevel}`;
                    playDifficultyUpSFX(); // Play SFX when difficulty increases
                }

                // Spawn new enemy if below MAX_ENEMIES_ON_SCREEN
                if (enemies.length < MAX_ENEMIES_ON_SCREEN) {
                    const enemyTypesArray = Object.keys(enemyTypes);
                    // Prioritize special enemies at higher difficulty
                    let availableEnemyTypes = ['basic'];
                    if (difficultyLevel >= 3) {
                        availableEnemyTypes.push('charger');
                    }
                    if (difficultyLevel >= 5) {
                        availableEnemyTypes.push('scatter');
                    }
                    if (difficultyLevel >= 8) {
                        availableEnemyTypes.push('wave');
                    }
                    if (difficultyLevel >= 12) {
                        availableEnemyTypes.push('homing');
                    }
                    if (difficultyLevel >= 15) { // Hybrid enemy appears at higher difficulty
                        availableEnemyTypes.push('hybrid');
                    }
                    // Randomly pick from available types, weighting towards newer/harder ones
                    const randomEnemyType = availableEnemyTypes[Math.floor(Math.random() * availableEnemyTypes.length)];
                    createEnemy(randomEnemyType);
                }
            } else {
                updateBoss(deltaTime);
                updateBossHealthBar();
            }


            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            updatePlayer(deltaTime);
            drawPlayer();

            // Update and draw regular enemy projectiles
            updateEnemyProjectiles(deltaTime); // Pass deltaTime to update bullet speed based on boss time stop
            enemyProjectiles.forEach(drawBullet);

            // Update and draw player skill projectiles
            updatePlayerProjectiles();
            playerProjectiles.forEach(drawBullet);

            updateArtifacts(deltaTime);
            artifacts.forEach(drawArtifact);

            updateParticles(deltaTime); // Update particles
            drawParticles(); // Draw particles

            if (!bossActive) { // Only draw regular enemies if boss is not active
                updateEnemies(deltaTime); // Update enemy positions/logic
                enemies.forEach(enemy => {
                    drawEnemy(enemy);
                });
                // Create artifact only if boss is not active
                if (score >= nextArtifactScore) {
                    createArtifact();
                    nextArtifactScore += ARTIFACT_SPAWN_INTERVAL;
                }
            } else { // Draw boss and its unique attacks if active
                drawBoss(boss);
                // Update and draw boss-specific attacks
                updateBeams(deltaTime);
                beams.forEach(drawBeam);

                updateDarkZones(deltaTime);
                darkZones.forEach(drawDarkZone);

                updateSpectralSpikes(deltaTime);
                spectralSpikes.forEach(drawSpectralSpike);

                updatePhantomBlasters(deltaTime);
                phantomBlasters.forEach(blaster => {
                    drawPhantomBlaster(blaster);
                    // Play SFX for Phantom Blaster
                    if (blaster.state === 'charging' && blaster.chargeTimer > 0.05 && blaster.chargeTimer <= blaster.maxCharge - 0.05) { // Play once at start of charge
                        playBlasterChargeSFX();
                    } else if (blaster.state === 'firing' && blaster.fireTimer > 0.05 && blaster.fireTimer <= blaster.maxFire - 0.05) { // Play once at start of fire
                        playBlasterFireSFX();
                    }
                });

                updateCrushingDescents(deltaTime);
                crushingDescents.forEach(drawCrushingDescent);
            }

            // --- Collision checks ---

            // Player-enemyProjectile collision (using player's hitboxRadius)
            if (!isInvincible) {
                for (let i = enemyProjectiles.length - 1; i >= 0; i--) { // Iterate backwards for safe removal
                    const bullet = enemyProjectiles[i];
                    if (checkCollision({ x: player.x, y: player.y, radius: player.hitboxRadius }, bullet)) {
                        
                        // Sakuya's passive: Evasive Insight
                        if (player.passive && player.passive.type === 'evasiveInsight' && Math.random() < player.passive.chance) {
                            bulletSlowEffectActive = true;
                            bulletSlowTimer = player.passive.duration;
                            // Clear bullets in radius
                            for (let j = enemyProjectiles.length - 1; j >= 0; j--) { // Iterate backwards for safe removal
                                const b = enemyProjectiles[j];
                                const dx = player.x - b.x;
                                const dy = player.y - b.y;
                                const distance = Math.sqrt(dx * dx + dy * dy);
                                if (distance < player.passive.radius) {
                                    enemyProjectiles.splice(j, 1);
                                }
                            }
                            bulletTrails.length = 0; // Clear trails too
                            playSakuyaSkillSFX(); // Use Sakuya's skill SFX for dodge slow
                            enemyProjectiles.splice(i, 1); // Remove the bullet that was "dodged"
                            continue; // Skip damage and revive logic
                        }

                        // Youmu's passive: Resilient Spirit invincibility on hit
                        if (player.passive && player.passive.type === 'resilientSpirit' && Math.random() < player.passive.chance) {
                            isInvincible = true;
                            invincibleTimer = player.passive.duration;
                            playDifficultyUpSFX(); // Play a sound indicating invincibility
                            enemyProjectiles.splice(i, 1); // Remove the bullet that hit
                            continue; // Skip damage and revive logic
                        }


                        playHitSFX(); // Play SFX when hit

                        // Check assist conditions
                        deathCount++;
                        if (deathCount >= ASSIST_DEATH_THRESHOLD && (score - scoreAtLastDeath < ASSIST_SCORE_THRESHOLD)) {
                             triggerAssist();
                             deathCount = 0; // Reset death counter after assist
                             scoreAtLastDeath = score; // Update score at assist
                        } else if (revivesLeft > 0) {
                            revivesLeft--;
                            revivesDisplay.textContent = `${texts[currentLanguage].revives}: ${revivesLeft}`;
                            isInvincible = true;
                            let currentInvincibleDuration = INVINCIBLE_DURATION;
                            // Cirno's passive: Icy Resilience
                            if (player.passive && player.passive.type === 'icyResilience') {
                                currentInvincibleDuration += player.passive.shieldDuration; // Extend invincibility as a shield
                            }
                            invincibleTimer = currentInvincibleDuration;
                            player.x = CANVAS_WIDTH / 2;
                            player.y = CANVAS_HEIGHT - player.height / 2 - 30; // Move player to safe position
                            enemyProjectiles.length = 0; // Clear all bullets on screen
                            bulletTrails.length = 0; // Clear bullet trails
                            beams.length = 0; // Clear all boss attacks
                            darkZones.length = 0;
                            spectralSpikes.length = 0;
                            phantomBlasters.length = 0;
                            crushingDescents.length = 0; // Clear crushing descents
                            enemyProjectiles.length = 0;
                            bulletTrails.length = 0;
                            scoreAtLastDeath = score; // Update score at revive
                        } else {
                            gameOver();
                            return;
                        }
                        enemyProjectiles.splice(i, 1); // Remove the bullet that hit the player
                        break; // Exit loop to avoid multiple collisions
                    }
                }

                // Player-Beam collision (Shadow Weaver)
                for (let i = beams.length - 1; i >= 0; i--) {
                    const beam = beams[i];
                    if (checkBeamCollision(player, beam)) {
                        playHitSFX();
                        if (revivesLeft > 0) {
                            revivesLeft--;
                            revivesDisplay.textContent = `${texts[currentLanguage].revives}: ${revivesLeft}`;
                            isInvincible = true;
                            let currentInvincibleDuration = INVINCIBLE_DURATION;
                            if (player.passive && player.passive.type === 'icyResilience') {
                                currentInvincibleDuration += player.passive.shieldDuration;
                            }
                            invincibleTimer = currentInvincibleDuration;
                            player.x = CANVAS_WIDTH / 2;
                            player.y = CANVAS_HEIGHT - player.height / 2 - 30;
                            // Clear all boss attacks on screen for a moment of relief
                            beams.length = 0;
                            darkZones.length = 0;
                            spectralSpikes.length = 0;
                            phantomBlasters.length = 0;
                            crushingDescents.length = 0; // Clear crushing descents
                            enemyProjectiles.length = 0;
                            bulletTrails.length = 0;
                        } else {
                            gameOver();
                            return;
                        }
                        // Beams are not removed on hit, they fade naturally
                        break;
                    }
                }

                // Player-DarkZone collision (Lich Overlord)
                for (let i = darkZones.length - 1; i >= 0; i--) {
                    const zone = darkZones[i];
                    if (zone.state === 'active' && checkDarkZoneCollision(player, zone)) {
                        playHitSFX();
                        if (revivesLeft > 0) {
                            revivesLeft--;
                            revivesDisplay.textContent = `${texts[currentLanguage].revives}: ${revivesLeft}`;
                            isInvincible = true;
                            let currentInvincibleDuration = INVINCIBLE_DURATION;
                            if (player.passive && player.passive.type === 'icyResilience') {
                                currentInvincibleDuration += player.passive.shieldDuration;
                            }
                            invincibleTimer = currentInvincibleDuration;
                            player.x = CANVAS_WIDTH / 2;
                            player.y = CANVAS_HEIGHT - player.height / 2 - 30;
                            // Clear all boss attacks on screen for a moment of relief
                            beams.length = 0;
                            darkZones.length = 0;
                            spectralSpikes.length = 0;
                            phantomBlasters.length = 0;
                            crushingDescents.length = 0; // Clear crushing descents
                            enemyProjectiles.length = 0;
                            bulletTrails.length = 0;
                        } else {
                            gameOver();
                            return;
                        }
                        darkZones.splice(i, 1); // Remove active zone on hit
                        break;
                    }
                }

                // Player-SpectralSpike collision (Spirit of Retribution)
                for (let i = spectralSpikes.length - 1; i >= 0; i--) {
                    const spike = spectralSpikes[i];
                    if (checkSpectralSpikeCollision(player, spike)) {
                        playHitSFX();
                        if (revivesLeft > 0) {
                            revivesLeft--;
                            revivesDisplay.textContent = `${texts[currentLanguage].revives}: ${revivesLeft}`;
                            isInvincible = true;
                            let currentInvincibleDuration = INVINCIBLE_DURATION;
                            if (player.passive && player.passive.type === 'icyResilience') {
                                currentInvincibleDuration += player.passive.shieldDuration;
                            }
                            invincibleTimer = currentInvincibleDuration;
                            player.x = CANVAS_WIDTH / 2;
                            player.y = CANVAS_HEIGHT - player.height / 2 - 30;
                            // Clear all boss attacks on screen for a moment of relief
                            beams.length = 0;
                            darkZones.length = 0;
                            spectralSpikes.length = 0;
                            phantomBlasters.length = 0;
                            crushingDescents.length = 0; // Clear crushing descents
                            enemyProjectiles.length = 0;
                            bulletTrails.length = 0;
                        } else {
                            gameOver();
                            return;
                        }
                        // Spikes are not removed on hit, they move naturally
                        break;
                    }
                }

                // Player-PhantomBlaster collision (Spirit of Retribution)
                for (let i = phantomBlasters.length - 1; i >= 0; i--) {
                    const blaster = phantomBlasters[i];
                    if (checkPhantomBlasterCollision(player, blaster)) {
                        playHitSFX();
                        if (revivesLeft > 0) {
                            revivesLeft--;
                            revivesDisplay.textContent = `${texts[currentLanguage].revives}: ${revivesLeft}`;
                            isInvincible = true;
                            let currentInvincibleDuration = INVINCIBLE_DURATION;
                            if (player.passive && player.passive.type === 'icyResilience') {
                                currentInvincibleDuration += player.passive.shieldDuration;
                            }
                            invincibleTimer = currentInvincibleDuration;
                            player.x = CANVAS_WIDTH / 2;
                            player.y = CANVAS_HEIGHT - player.height / 2 - 30;
                            // Clear all boss attacks on screen for a moment of relief
                            beams.length = 0;
                            darkZones.length = 0;
                            spectralSpikes.length = 0;
                            phantomBlasters.length = 0;
                            crushingDescents.length = 0; // Clear crushing descents
                            enemyProjectiles.length = 0;
                            bulletTrails.length = 0;
                        } else {
                            gameOver();
                            return;
                        }
                        // Blasters are not removed on hit, they fire and fade
                        break;
                    }
                }

                // Player-CrushingDescent collision (Time Manipulator)
                for (let i = crushingDescents.length - 1; i >= 0; i--) {
                    const roller = crushingDescents[i];
                    if (checkCrushingDescentCollision(player, roller)) {
                        playHitSFX();
                        if (revivesLeft > 0) {
                            revivesLeft--;
                            revivesDisplay.textContent = `${texts[currentLanguage].revives}: ${revivesLeft}`;
                            isInvincible = true;
                            let currentInvincibleDuration = INVINCIBLE_DURATION;
                            if (player.passive && player.passive.type === 'icyResilience') {
                                currentInvincibleDuration += player.passive.shieldDuration;
                            }
                            invincibleTimer = currentInvincibleDuration;
                            player.x = CANVAS_WIDTH / 2;
                            player.y = CANVAS_HEIGHT - player.height / 2 - 30;
                            // Clear all boss attacks on screen for a moment of relief
                            beams.length = 0;
                            darkZones.length = 0;
                            spectralSpikes.length = 0;
                            phantomBlasters.length = 0;
                            crushingDescents.length = 0;
                            enemyProjectiles.length = 0;
                            bulletTrails.length = 0;
                        } else {
                            gameOver();
                            return;
                        }
                        crushingDescents.splice(i, 1); // Remove crushing descent on hit
                        break;
                    }
                }
            }

            // Player skill bullets hitting enemies/boss
            for (let i = playerProjectiles.length - 1; i >= 0; i--) {
                const bullet = playerProjectiles[i];
                let hitSomething = false;
                let damageMultiplier = player.damageBoostActive ? (1 + playerCharacters[currentPlayerType].activeSkills[0].damageBoost) : 1; // For Cirno's Absolute Zero Form

                if (bossActive && boss) {
                    // Check collision with boss
                    const dx = bullet.x - boss.x;
                    const dy = bullet.y - boss.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance < bullet.radius + Math.max(boss.width, boss.height) / 2) {
                        let damage = 75; // Default player bullet damage
                        if (bullet.type === 'spiralOrb') damage = playerCharacters.marisa.activeSkills[0].damage;
                        if (bullet.type === 'glacialBeam') damage = playerCharacters.cirno.activeSkills[1].damage;
                        
                        boss.health -= damage * damageMultiplier; // Player bullet deals more damage to boss
                        playBossHitSFX();
                        hitSomething = true;
                    }
                } else {
                    // Check collision with regular enemies
                    for (let j = enemies.length - 1; j >= 0; j--) { // Iterate backwards for safe removal
                        const enemy = enemies[j];
                        // Check collision between player bullet and enemy
                        const dx = bullet.x - enemy.x;
                        const dy = enemy.y - bullet.y; // Bullet is moving upwards, enemy is above
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        if (distance < bullet.radius + Math.max(enemy.width, enemy.height) / 2) {
                            let damage = 75; // Default damage
                            if (bullet.type === 'spiralOrb') damage = playerCharacters.marisa.activeSkills[0].damage;
                            if (bullet.type === 'strikeProjectile') damage = 30; // Rapid Strike Flurry damage
                            if (bullet.type === 'windBlade') damage = 40; // Wind Blade Volley damage
                            if (bullet.type === 'illusoryCloneBullet') damage = 10; // Illusory Duplicate damage

                            enemy.health -= damage * damageMultiplier; // Player bullet deals more damage to enemy
                            playBossHitSFX(); // Use boss hit SFX for enemy hit
                            hitSomething = true;
                            if (!bullet.piercing) { // If not piercing, remove bullet and break
                                playerProjectiles.splice(i, 1);
                                break;
                            }
                        }
                    }
                }
                if (hitSomething && !bullet.piercing) {
                    playerProjectiles.splice(i, 1); // Remove bullet if it hit and is not piercing
                }
            }

            // Marisa's Lightning Dash damage to enemies/boss during dash
            if (player.isDashing) {
                const lightningDashDamage = playerCharacters.marisa.activeSkills[1].damage;
                for (let i = enemies.length - 1; i >= 0; i--) {
                    const enemy = enemies[i];
                    const pLeft = player.x - player.width / 2;
                    const pRight = player.x + player.width / 2;
                    const pTop = player.y - player.height / 2;
                    const pBottom = player.y + player.height / 2;

                    const eLeft = enemy.x - enemy.width / 2;
                    const eRight = enemy.x + enemy.width / 2;
                    const eTop = enemy.y - enemy.height / 2;
                    const eBottom = enemy.y + enemy.height / 2;

                    if (pLeft < eRight && pRight > eLeft && pTop < eBottom && pBottom > eTop) {
                        enemy.health -= lightningDashDamage * (1/60); // Continuous damage
                        playBossHitSFX();
                    }
                }
                if (bossActive && boss) {
                    const pLeft = player.x - player.width / 2;
                    const pRight = player.x + player.width / 2;
                    const pTop = player.y - player.height / 2;
                    const pBottom = player.y + player.height / 2;

                    const bLeft = boss.x - boss.width / 2;
                    const bRight = boss.x + boss.width / 2;
                    const bTop = boss.y - boss.height / 2;
                    const bBottom = boss.y + boss.height / 2;

                    if (pLeft < bRight && pRight > bLeft && pTop < bBottom && pBottom > bTop) {
                        boss.health -= lightningDashDamage * 0.5 * (1/60); // Continuous damage to boss
                        playBossHitSFX();
                    }
                }
            }


            // Player-artifact collision
            for (let i = artifacts.length - 1; i >= 0; i--) {
                const artifact = artifacts[i];
                // For artifact collision, use the player's full visual bounds for easier collection
                // (Simple rectangle-circle check or approximate with player's width/height)
                const dx = player.x - artifact.x;
                const dy = player.y - artifact.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance < (Math.max(player.width, player.height)/2 + artifact.radius)) { // Check collision with player's bounding box
                    playArtifactCollectSFX(); // Play SFX when collecting artifact
                    // Activate artifact effect
                    if (artifact.type === 0) { // Slow
                        // Apply slow to enemy projectiles
                        enemyProjectiles.forEach(b => b.speed *= 0.6); 
                        // Apply slow to spectralSpikes
                        spectralSpikes.forEach(b => { b.vx *= 0.6; b.vy *= 0.6; });
                        // Apply slow to Phantom Blaster charge/fire timers
                        phantomBlasters.forEach(gb => {
                            gb.chargeTimer *= 0.6;
                            gb.fireTimer *= 0.6;
                        });
                        // Apply slow to Crushing Descents
                        crushingDescents.forEach(rr => rr.vy *= 0.6);

                        addTimer('timeout', () => { // Use addTimer
                            enemyProjectiles.forEach(b => b.speed /= 0.6); 
                            spectralSpikes.forEach(b => { b.vx /= 0.6; b.vy /= 0.6; });
                            phantomBlasters.forEach(gb => {
                                gb.chargeTimer /= 0.6;
                                gb.fireTimer /= 0.6;
                            });
                            crushingDescents.forEach(rr => rr.vy /= 0.6);
                        }, 3000); // Lasts 3 seconds
                    } else if (artifact.type === 1) { // Speed
                        player.speed *= 1.5; // Increase player speed
                        addTimer('timeout', () => { // Use addTimer
                            player.speed /= 1.5; // Revert to original speed
                        }, 3000); // Lasts 3 seconds
                    } else if (artifact.type === 2) { // Clear
                        enemyProjectiles.length = 0; // Clear all bullets on screen
                        bulletTrails.length = 0;
                        beams.length = 0; // Clear beams
                        darkZones.length = 0; // Clear dark zones
                        spectralSpikes.length = 0; // Clear spikes
                        phantomBlasters.length = 0; // Clear blasters
                        crushingDescents.length = 0; // Clear crushing descents
                    }
                    artifacts.splice(i, 1); // Remove collected artifact
                }
            }

            updateSkillButtonState(); // Update skill button state continuously

            requestAnimationFrame(gameLoop);
        }

        // --- Language Translation ---
        const texts = {
            en: {
                gameTitle: "Touhou Bullet Dodge Game",
                startScreenTitle: "TOUHOU BULLET DODGE GAME",
                startScreenStory: "You are a fragment of forgotten magic, awakened in a chaotic realm. Dodge the relentless magical distortions and face the source of the chaos to bring temporary peace. Survive as long as you can! As you delve deeper, you sense a formidable presence, the source of these distortions, awaiting your challenge. After defeating the initial manifestations, a deeper, more ancient evil stirs, threatening to engulf all. Your journey is far from over...",
                characterSelectionTitle: "Select Your Character:",
                reimu: "Reimu (Balanced)",
                marisa: "Marisa (Fast)",
                sakuya: "Sakuya (Precise)",
                youmu: "Youmu (Swift)",
                cirno: "Cirno (Resilient)",
                startButton: "Start Game",
                gameOverTitle: "GAME OVER!",
                gameOverScoreText: "You survived for ",
                playAgain: "Play Again",
                home: "Home",
                gameWinTitle: "VICTORY!",
                gameWinText: "You have defeated the Boss and brought temporary peace to the realm! However, the true source of chaos remains elusive, hinting at future challenges...",
                finalScore: "Final Score: ",
                pausedTitle: "PAUSED",
                pausedHint: "Press ESC or \"Resume\" button to continue",
                pause: "Pause",
                resume: "Resume",
                toggleMusic: "Toggle Music",
                score: "Score",
                difficulty: "Difficulty",
                revives: "Revives",
                skill1: "Skill 1",
                skill2: "Skill 2",
                bossHealth: "BOSS HEALTH",
                bossPhase: "BOSS PHASE",
                activeSkills: "Active Skills",
                passiveSkill: "Passive Skill",
                enemyInspirations: "Enemy Inspirations"
            },
            vi: {
                gameTitle: "Trò chơi Touhou: Né đạn",
                startScreenTitle: "TRÒ CHƠI TOUHOU: NÉ ĐẠN",
                startScreenStory: "Bạn là một mảnh vỡ của ma thuật bị lãng quên, thức tỉnh trong một vương quốc hỗn loạn. Né tránh những biến dạng ma thuật không ngừng và đối mặt với nguồn gốc của sự hỗn loạn để mang lại hòa bình tạm thời. Sống sót càng lâu càng tốt! Khi bạn đi sâu hơn, bạn cảm nhận một sự hiện diện đáng gờm, nguồn gốc của những biến dạng này, đang chờ đợi thử thách của bạn. Sau khi đánh bại những biểu hiện ban đầu, một thế lực tà ác sâu xa, cổ xưa hơn đang trỗi dậy, đe dọa nhấn chìm tất cả. Cuộc hành trình của bạn còn lâu mới kết thúc...",
                characterSelectionTitle: "Chọn nhân vật của bạn:",
                reimu: "Reimu (Cân bằng)",
                marisa: "Marisa (Nhanh nhẹn)",
                sakuya: "Sakuya (Chính xác)",
                youmu: "Youmu (Né tránh)",
                cirno: "Cirno (Kiên cường)",
                startButton: "Bắt đầu trò chơi",
                gameOverTitle: "HẾT GAME!",
                gameOverScoreText: "Bạn đã sống sót trong ",
                playAgain: "Chơi lại",
                home: "Trang chủ",
                gameWinTitle: "CHIẾN THẮNG!",
                gameWinText: "Bạn đã đánh bại Boss và mang lại hòa bình tạm thời cho vương quốc! Tuy nhiên, nguồn gốc thực sự của sự hỗn loạn vẫn còn khó nắm bắt, báo hiệu những thử thách trong tương lai...",
                finalScore: "Điểm cuối cùng: ",
                pausedTitle: "TẠM DỪNG",
                pausedHint: "Nhấn ESC hoặc nút \"Tiếp tục\" để tiếp tục",
                pause: "Tạm dừng",
                resume: "Tiếp tục",
                toggleMusic: "Bật/Tắt nhạc",
                score: "Điểm",
                difficulty: "Độ khó",
                revives: "Hồi sinh",
                skill1: "Kỹ năng 1",
                skill2: "Kỹ năng 2",
                bossHealth: "MÁU BOSS",
                bossPhase: "BOSS GIAI ĐOẠN",
                activeSkills: "Kỹ năng chủ động",
                passiveSkill: "Kỹ năng bị động",
                enemyInspirations: "Nguồn cảm hứng quái vật"
            }
        };

        let currentLanguage = 'vi'; // Default language

        function setLanguage(lang) {
            currentLanguage = lang;
            const t = texts[lang];

            // Update static texts
            gameTitle.textContent = t.gameTitle;
            startScreenTitle.textContent = t.startScreenTitle;
            startScreenStory.textContent = t.startScreenStory;
            characterSelectionTitle.textContent = t.characterSelectionTitle;
            startButton.textContent = t.startButton;
            gameOverTitle.textContent = t.gameOverTitle;
            gameOverScoreText.childNodes[0].nodeValue = t.gameOverScoreText; // Update only the text node
            restartButton.textContent = t.playAgain;
            homeButtonGameOver.textContent = t.home; // Home button text
            gameWinTitle.textContent = t.gameWinTitle;
            gameWinText.textContent = t.gameWinText;
            finalWinScoreText.childNodes[0].nodeValue = t.finalScore; // Update only the text node
            winRestartButton.textContent = t.playAgain;
            homeButtonGameWin.textContent = t.home; // Home button text
            pausedTitle.textContent = t.pausedTitle;
            pausedHint.textContent = t.pausedHint;
            homeButtonPaused.textContent = t.home; // Home button text
            pauseButton.textContent = gamePaused ? t.resume : t.pause; // Update based on current state
            musicToggleButton.textContent = t.toggleMusic;

            // Update character button texts and descriptions
            document.getElementById('reimuButton').textContent = t.reimu;
            document.getElementById('marisaButton').textContent = t.marisa;
            document.getElementById('sakuyaButton').textContent = t.sakuya;
            document.getElementById('youmuButton').textContent = t.youmu;
            document.getElementById('cirnoButton').textContent = t.cirno;

            // Update dynamic game info texts (if game is running)
            if (gameRunning) {
                scoreDisplay.textContent = `${t.score}: ${score}`;
                if (bossActive) {
                    difficultyDisplay.textContent = `${t.difficulty}: ${t.bossPhase} ${currentBossPhaseIndex + 1}`;
                } else {
                    difficultyDisplay.textContent = `${t.difficulty}: ${difficultyLevel}`;
                }
                revivesDisplay.textContent = `${t.revives}: ${revivesLeft}`;
                // Skill display updated by updateSkillButtonState
                updateSkillButtonState(); // Update skill button text immediately
                updateBossHealthBar(); // Update boss health bar text
            } else {
                updateCharacterDescription(currentPlayerType); // Update description on start screen
            }

            // Update language button selected state
            languageButtons.forEach(btn => {
                if (btn.dataset.lang === lang) {
                    btn.classList.add('selected');
                } else {
                    btn.classList.remove('selected');
                }
            });
        }

        // Add event listeners for language buttons
        languageButtons.forEach(button => {
            button.addEventListener('click', () => {
                setLanguage(button.dataset.lang);
            });
        });

        // Initialize master gain if needed
        if (masterGain) {
            masterGain.gain.linearRampToValueAtTime(0.4, Tone.context.currentTime + 0.2);
        }

        // --- Game over function ---
        function gameOver() {
            gameRunning = false;
            gamePaused = true;
            finalScoreDisplay.textContent = score;
            gameOverScreen.style.display = 'flex';
            if (isMusicPlaying) {
                Tone.Transport.stop();
                masterGain.gain.linearRampToValueAtTime(0, Tone.context.currentTime + 0.5);
            }
            // Clear all game elements to prevent lingering issues
            enemyProjectiles.length = 0;
            playerProjectiles.length = 0;
            bulletTrails.length = 0;
            artifacts.length = 0;
            particles.length = 0;
            beams.length = 0;
            darkZones.length = 0;
            spectralSpikes.length = 0;
            phantomBlasters.length = 0;
            crushingDescents.length = 0; // Clear crushing descents
            enemies.length = 0;
            clearAllTimers(); // Clear any active intervals/timeouts
            if (Tone.Transport.state !== 'stopped') {
                Tone.Transport.stop();
            }
        }

        // --- Game Win function ---
        function gameWin() {
            gameRunning = false;
            gamePaused = true;
            finalWinScoreDisplay.textContent = score;
            gameWinScreen.style.display = 'flex';
            if (isMusicPlaying) {
                Tone.Transport.stop();
                masterGain.gain.linearRampToValueAtTime(0, Tone.context.currentTime + 0.5);
            }
            // Clear all game elements to prevent lingering issues
            enemyProjectiles.length = 0;
            playerProjectiles.length = 0;
            bulletTrails.length = 0;
            artifacts.length = 0;
            particles.length = 0;
            beams.length = 0;
            darkZones.length = 0;
            spectralSpikes.length = 0;
            phantomBlasters.length = 0;
            crushingDescents.length = 0; // Clear crushing descents
            enemies.length = 0;
            clearAllTimers(); // Clear any active intervals/timeouts
            if (Tone.Transport.state !== 'stopped') {
                Tone.Transport.stop();
            }
        }

        // --- Function to return to Start Screen ---
        function returnToStartScreen() {
            gameRunning = false;
            gamePaused = true; // Ensure game is paused when returning to start screen
            gameOverScreen.style.display = 'none';
            gameWinScreen.style.display = 'none';
            pausedOverlay.style.display = 'none';
            startScreen.style.display = 'flex'; // Show the start screen
            if (isMusicPlaying) {
                Tone.Transport.stop();
                masterGain.gain.linearRampToValueAtTime(0, Tone.context.currentTime + 0.5);
                isMusicPlaying = false; // Reset music state
            }
            // Clear all game elements to prevent lingering issues
            enemyProjectiles.length = 0;
            playerProjectiles.length = 0;
            bulletTrails.length = 0;
            artifacts.length = 0;
            particles.length = 0;
            beams.length = 0;
            darkZones.length = 0;
            spectralSpikes.length = 0;
            phantomBlasters.length = 0;
            crushingDescents.length = 0; // Clear crushing descents
            enemies.length = 0;
            clearAllTimers(); // Clear any active intervals/timeouts
            if (Tone.Transport.state !== 'stopped') {
                Tone.Transport.stop();
            }
            updateCharacterDescription(currentPlayerType); // Update description on start screen
        }

        // --- Character Selection Logic ---
        const characterSelectButtons = document.querySelectorAll('.character-button');
        const characterDescElement = document.getElementById('characterDescription');
        const defaultCharacter = 'reimu'; // Default to Reimu if none selected
        
        // Function to update character description
        function updateCharacterDescription(characterType) {
            if (!characterType || !playerCharacters[characterType]) return;
            
            const charData = playerCharacters[characterType];
            const t = texts[currentLanguage] || texts['en']; // Fallback to English
            let desc = charData.description ? (charData.description[currentLanguage] || charData.description.en || '') : '';

            // Append specific skill descriptions for clarity
            if (charData.activeSkills) {
                desc += `<br><br><b>${t.activeSkills || 'Active Skills'}:</b><br>`;
                charData.activeSkills.forEach((skill, index) => {
                    const skillName = t[`skill${index + 1}`] || `Skill ${index + 1}`;
                    const skillDesc = skill.description ? (skill.description[currentLanguage] || skill.description.en || '') : '';
                    desc += `- ${skillName}: ${skillDesc} (CD: ${skill.cooldown || 'N/A'}s)<br>`;
                });
            }
            
            if (charData.passive && charData.passive.description) {
                const passiveDesc = charData.passive.description[currentLanguage] || charData.passive.description.en || '';
                desc += `<br><b>${t.passiveSkill || 'Passive Skill'}:</b> ${passiveDesc}`;
            }

            if (characterDescElement) {
                characterDescElement.innerHTML = desc;
            }
        }
        
        // Initialize default character selection
        function initializeCharacterSelection() {
            // Set default selected character (Reimu)
            if (characterSelectButtons.length > 0) {
                const defaultButton = Array.from(characterSelectButtons).find(btn => btn.dataset.character === defaultCharacter);
                if (defaultButton) {
                    defaultButton.classList.add('selected');
                    currentPlayerType = defaultCharacter;
                } else {
                    characterSelectButtons[0].classList.add('selected');
                    currentPlayerType = characterSelectButtons[0].dataset.character;
                }
                updateCharacterDescription(currentPlayerType);
            }
        }
        
        // Add click event listeners to character buttons
        characterSelectButtons.forEach(button => {
            button.addEventListener('click', () => {
                // Remove 'selected' class from all buttons
                characterSelectButtons.forEach(btn => btn.classList.remove('selected'));
                // Add 'selected' class to the clicked button
                button.classList.add('selected');
                currentPlayerType = button.dataset.character;
                updateCharacterDescription(currentPlayerType);
                console.log(`Selected character: ${currentPlayerType}`);
            });
        });
        
        // Initialize character selection when the page loads
        document.addEventListener('DOMContentLoaded', initializeCharacterSelection);
        // Also initialize immediately in case DOM is already loaded
        if (document.readyState === 'complete' || document.readyState === 'interactive') {
            setTimeout(initializeCharacterSelection, 0);
        }

        // --- Event Listeners for buttons ---
        startButton.addEventListener('click', () => {
            // Ensure a character is selected before starting
            const selectedButton = document.querySelector('.character-button.selected');
            if (!selectedButton && characterSelectButtons.length > 0) {
                // If no character is selected, select the first one by default
                characterSelectButtons[0].classList.add('selected');
                currentPlayerType = characterSelectButtons[0].dataset.character;
            }
            startGame();
        });
        
        restartButton.addEventListener('click', startGame);
        winRestartButton.addEventListener('click', startGame); // Restart from win screen
        winMenuButton.addEventListener('click', returnToStartScreen);
        menuButton.addEventListener('click', returnToStartScreen);
        musicToggleButton.addEventListener('click', toggleMusic);
        helpButton.addEventListener('click', toggleHelp);
        closeHelpButton.addEventListener('click', toggleHelp);
        assistButton.addEventListener('click', triggerAssist);
        pauseButton.addEventListener('click', togglePause);
        resumeButton.addEventListener('click', togglePause);
        
        // Skill buttons with cooldown indicators
        const skill1Cooldown = document.createElement('div');
        skill1Cooldown.className = 'skill-cooldown';
        skill1Button.appendChild(skill1Cooldown);
        
        const skill2Cooldown = document.createElement('div');
        skill2Cooldown.className = 'skill-cooldown';
        skill2Button.appendChild(skill2Cooldown);
        
        // Add skill button event listeners
        skill1Button.addEventListener('click', () => useSkill(0));
        skill2Button.addEventListener('click', () => useSkill(1));
        
        // Keyboard controls for skills
        document.addEventListener('keydown', (e) => {
            if (!gameRunning || gamePaused) return;
            
            // Use Z for skill 1 and X for skill 2
            if (e.key.toLowerCase() === 'z') {
                useSkill(0);
                e.preventDefault(); // Prevent default browser action
            } else if (e.key.toLowerCase() === 'x') {
                useSkill(1);
                e.preventDefault(); // Prevent default browser action
            }
        });
        
        // Update skill button states
        function updateSkillButtons() {
            if (!gameRunning) return;
            
            const currentTime = performance.now() / 1000; // in seconds
            
            // Update skill 1 button
            if (player.activeSkills && player.activeSkills[0]) {
                const skill = player.activeSkills[0];
                const cooldown = skill.cooldown * (player.passive?.type === 'arcaneFlow' ? (1 - player.passive.value) : 1);
                const remaining = Math.max(0, cooldown - (currentTime - (skill.lastUseTime || 0)));
                const percentage = Math.min(100, (remaining / cooldown) * 100);
                
                skill1Cooldown.style.height = `${percentage}%`;
                skill1Button.disabled = remaining > 0;
            }
            
            // Update skill 2 button
            if (player.activeSkills && player.activeSkills[1]) {
                const skill = player.activeSkills[1];
                const cooldown = skill.cooldown * (player.passive?.type === 'arcaneFlow' ? (1 - player.passive.value) : 1);
                const remaining = Math.max(0, cooldown - (currentTime - (skill.lastUseTime || 0)));
                const percentage = Math.min(100, (remaining / cooldown) * 100);
                
                skill2Cooldown.style.height = `${percentage}%`;
                skill2Button.disabled = remaining > 0;
            }
        }

        // Main game loop
        function gameLoop(timestamp) {
            if (!gameRunning) return;
            
            if (gamePaused) {
                requestAnimationFrame(gameLoop);
                return;
            }

            if (!lastTimestamp) lastTimestamp = timestamp;
            const deltaTime = Math.min(0.1, (timestamp - lastTimestamp) / 1000); // Limit deltaTime to prevent physics issues
            lastTimestamp = timestamp;
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Update game state
            updatePlayer(deltaTime);
            updateEnemies(deltaTime);
            updateEnemyProjectiles(deltaTime);
            updatePlayerProjectiles();
            updateParticles(deltaTime);
            updateArtifacts(deltaTime);
            
            // Update boss and boss attacks if boss exists
            if (boss) {
                updateBoss(deltaTime);
                updateBeams(deltaTime);
                updateDarkZones(deltaTime);
                updateSpectralSpikes(deltaTime);
                updatePhantomBlasters(deltaTime);
                updateCrushingDescents(deltaTime);
            }
            
            // Draw everything
            drawParticles();
            drawPlayer();
            enemies.forEach(drawEnemy);
            enemyProjectiles.forEach(drawBullet);
            playerProjectiles.forEach(drawBullet);
            artifacts.forEach(drawArtifact);
            
            // Draw boss and boss attacks if boss exists
            if (boss) {
                drawBoss(boss);
                beams.forEach(drawBeam);
                darkZones.forEach(drawDarkZone);
                spectralSpikes.forEach(drawSpectralSpike);
                phantomBlasters.forEach(drawPhantomBlaster);
                crushingDescents.forEach(drawCrushingDescent);
            }
            
            // Update UI
            updateSkillButtons();
            
            // Continue the game loop
            requestAnimationFrame(gameLoop);
        }

        // Khởi tạo game loop
        let lastTimestamp;
        requestAnimationFrame(gameLoop);

        // Character selection is now handled at the beginning of the file
        
        // Function to update character description is now at the beginning of the file

        // Home button listeners
        homeButtonGameOver.addEventListener('click', returnToStartScreen);
        homeButtonGameWin.addEventListener('click', returnToStartScreen);
        homeButtonPaused.addEventListener('click', returnToStartScreen);
        
        // Initial setup on window load is handled by the 'load' event listener
        // Character description is initialized in initializeCharacterSelection()
    </script>
</body>
</html>
